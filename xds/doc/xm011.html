<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Mapping to C</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<P><HR>
<A NAME="0533">
<A HREF="xm000.html#root" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="xm010.html#0532" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0534" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H1>Mapping to C</H1>

<P>Almost all features of Modula-2 and Oberon-2 have direct equivalents in ANSI C. If some construct is not directly available in C, the most simple and effective solution preserving the language semantics is used. 
<P>Many features are implemented in the run-time system. The file <TT>X2C.h </TT>is a C header file of the run-time support library. It contains a set of type definitions, macros and functions necessary for compilation and execution of a translated code. 
<P><B>Note:</B> In the examples of a generated C code throughout this appendix some unimportant details may be omitted for simplicity. 
<P><UL>
<LI><A HREF="#0534" TARGET=body>Layout of a generated code</A>
<LI><A HREF="#0535" TARGET=body>Identifiers</A>
<LI><A HREF="#0537" TARGET=body>Data types</A>
<LI><A HREF="#0546" TARGET=body>Procedure declarations</A>
<LI><A HREF="#0555" TARGET=body>Module initialization and finalization</A>
<LI><A HREF="#0557" TARGET=body>Oberon-2 object-oriented features</A>
<LI><A HREF="#0558" TARGET=body>Oberon-2 run-time data structures</A>
<LI><A HREF="#0560" TARGET=body>Options</A>
</UL>
<P><HR>
<A NAME="0534">
<A HREF="#0533" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0533" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0535" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Layout of a generated code</H2>

<P>The compiler generates the header files and C code files (See also <A HREF="xm004.html#0046" TARGET=body>Files generated during compilation</A>). A generated header file has the following general layout: 
<OL>
 
<LI>a user defined copyright statement (See the <B>COPYRIGHT</B> equation) </LI>
<LI>two header lines, including time of compilation, the name of the file, a version of the XDS compiler. </LI>
<LI><TT>#ifdef&nbsp;&lt;module_name&gt;_H_</TT> </LI>
<LI>a set of &quot;include&quot; directives (always contains &quot;include&quot; directive for the run-time header file <TT>X2C.h</TT>). </LI>
<LI>external declarations </LI>
<LI><TT>#endif</TT> </LI>
</OL>

<P><B>Note:</B> External declarations may contain implicitly exported identifiers. E.g. a structure always contains non-exported fields. 
<P>For a sample definition module: 
<P><PRE>DEFINITION&nbsp;MODULE&nbsp;MyLib;

PROCEDURE&nbsp;Foo;

END&nbsp;MyLib.
</PRE>

<P>the following header file will be produced under on assumption that the <B>COPYRIGHT</B> equation is properly set): <FONT SIZE=2>
<P><PRE>/*&nbsp;(c)&nbsp;1994&nbsp;Widget&nbsp;Databases&nbsp;Ltd&nbsp;*/
/*&nbsp;&quot;@(#)MyLib.h&nbsp;Sep&nbsp;15&nbsp;12:50:16&nbsp;1995&quot;&nbsp;*/
/*&nbsp;Generated&nbsp;by&nbsp;XDS&nbsp;Modula-2&nbsp;to&nbsp;ANSI&nbsp;C&nbsp;v3.14&nbsp;translator&nbsp;*/

#ifndef&nbsp;MyLib_H_
#define&nbsp;MyLib_H_
#ifndef&nbsp;X2C_H_
#include&nbsp;&quot;X2C.h&quot;
#endif

extern&nbsp;void&nbsp;X2C_PROCLASS&nbsp;MyLib_Foo(void);

extern&nbsp;void&nbsp;X2C_PROCLASS&nbsp;MyLib_BEGIN(void);

#endif&nbsp;/*&nbsp;MyLib_H_&nbsp;*/
</PRE>

<P></FONT> 
<P>A generated C code file has the following general layout: 
<OL>
 
<LI>a user defined copyright statement (See the <B>COPYRIGHT</B> equation) </LI>
<LI>two header lines, including time of compilation (See the option <B>GENDATE</B>), the name of the file, a version of the XDS compiler. </LI>
<LI>definitions of the pre-processor symbols corresponding to the settings of some options (See <A HREF="#0561" TARGET=body>Describing platform</A>) </LI>
<LI>a set of include directives (for program module it contains &quot;include&quot; directive for the run-time header file <TT>X2C.h</TT>). </LI>
<LI>the generated source text </LI>
</OL>

<P>For the implementation module: 
<P><PRE>IMPLEMENTATION&nbsp;MODULE&nbsp;MyLib;

IMPORT&nbsp;&nbsp;InOut;

VAR&nbsp;count:&nbsp;INTEGER;

PROCEDURE&nbsp;Foo;
BEGIN
&nbsp;&nbsp;INC(count);
&nbsp;&nbsp;InOut.WriteInt(count,0);
&nbsp;&nbsp;InOut.WriteLn;
END&nbsp;Foo;

BEGIN
&nbsp;&nbsp;count:=0;
END&nbsp;MyLib.
</PRE>

<P>the following code file will be produced: <FONT SIZE=2>
<P><PRE>/*&nbsp;(c)&nbsp;1994&nbsp;Widget&nbsp;Databases&nbsp;Ltd&nbsp;*/
/*&nbsp;&quot;@(#)MyLib.c&nbsp;Jan&nbsp;12&nbsp;12:50:36&nbsp;1995&quot;&nbsp;*/
/*&nbsp;Generated&nbsp;by&nbsp;XDS&nbsp;Modula-2&nbsp;to&nbsp;ANSI&nbsp;C&nbsp;v3.12&nbsp;translator&nbsp;*/

#define&nbsp;X2C_int32
#define&nbsp;X2C_index32
#ifndef&nbsp;InOut_H_
#include&nbsp;&quot;InOut.h&quot;
#endif
#include&nbsp;&quot;MyLib.h&quot;

static&nbsp;X2C_INT32&nbsp;count;

extern&nbsp;&nbsp;void&nbsp;X2C_PROCLASS&nbsp;MyLib_Foo(void)
{
&nbsp;&nbsp;count&nbsp;+=&nbsp;1l;
&nbsp;&nbsp;InOut_WriteInt(count,0ul);
&nbsp;&nbsp;InOut_WriteLn();
}&nbsp;/*&nbsp;END&nbsp;Foo&nbsp;*/

extern&nbsp;void&nbsp;X2C_PROCLASS&nbsp;MyLib_BEGIN(void)
{
&nbsp;&nbsp;static&nbsp;int&nbsp;MyLib_init=0;
&nbsp;&nbsp;if&nbsp;(MyLib_init)&nbsp;return;
&nbsp;&nbsp;MyLib_init=1;
&nbsp;&nbsp;InOut_BEGIN();
&nbsp;&nbsp;count=0ul;
}
</PRE>

<P></FONT> <B>Note:</B> for an Oberon module both the header and code files are generated. 
<P><HR>
<A NAME="0535">
<A HREF="#0533" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0534" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0536" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Identifiers</H2>

<P>The compiler tries to copy identifiers from the source text to the C code without modifications. In some cases it can be necessary to expand an identifier or to reduce it (See also the <B>GENIDLEN</B> equation). 
<P><B>Note:</B> The compiler does not change identifiers which are marked as C identifiers via the direct language specification facility. See <A HREF="xm010.html#0523" TARGET=body>Direct language specification</A>. 
<P>All exported identifiers<FONT SIZE=2>&nbsp;/Identifiers that are declared in a definition module, or marked as exported in an oberon module./ </FONT> are prefixed by the module name. 
<P>If an identifier to be declared is already defined in the C text it is postfixed with a number. It can occur for a various reasons: 
<OL>
 
<LI>an identifier coincides with the C keyword or standard identifier. 
<P><PRE>&nbsp;&nbsp;VAR&nbsp;char:&nbsp;CHAR;
</PRE>

<P>translates to: 
<P><PRE>&nbsp;&nbsp;X2C_CHAR&nbsp;char1;
</PRE>

<P>The compiler uses postfixing for all identifiers listed in the <TT>xm.kwd</TT> file. The file provided by the distribution contains a list of all ANSI C/C++ keywords and some identifiers from the C standard libraries. 
<P>One can extend the file with other identifiers. For example, if you program contains (non-exported) identifier <TT>pi</TT> and imports a standard C <TT>math</TT> library, it is necessary to include <TT>pi</TT> into the <TT>xm.kwd</TT> file. </LI>
<LI>a local identifier coincides with the global one. 
<P><PRE>VAR&nbsp;i:&nbsp;INTEGER;

PROCEDURE&nbsp;Foo;
&nbsp;&nbsp;VAR&nbsp;i:&nbsp;INTEGER;
BEGIN
&nbsp;&nbsp;i:=1;
END&nbsp;Foo;
</PRE>

<P>translates to: 
<P><PRE>static&nbsp;X2C_INT32&nbsp;i;

static&nbsp;void&nbsp;Foo(void)
{
&nbsp;&nbsp;X2C_INT32&nbsp;i1;
&nbsp;&nbsp;i1&nbsp;=&nbsp;1;
}
</PRE>
</LI>
<LI>an identifier is exported/imported to/from the context, where such an identifier is already defined. E.g. 
<P><PRE>PROCEDURE&nbsp;Foo;&nbsp;END&nbsp;Foo;

MODULE&nbsp;Local;

EXPORT&nbsp;QUALIFIED&nbsp;Foo;

PROCEDURE&nbsp;Foo;&nbsp;END&nbsp;Foo;

END&nbsp;Local;
</PRE>

<P>The compiler does not extend identifiers defined in the local modules with the module name. It will use postfixing to distinguish between two <TT>Foo</TT> procedures. 
<P><PRE>static&nbsp;void&nbsp;Foo(void)
{
}

static&nbsp;void&nbsp;Foo1(void)&nbsp;/*&nbsp;Local.Foo&nbsp;*/
{
}
</PRE>
</LI>
</OL>

<P>If the length of a generated identifier length is greater than the limit defined by the <B>GENIDLEN</B> equation, the compiler will reduce the identifier. Let us consider the definition module: 
<P><PRE>DEFINITION&nbsp;MODULE&nbsp;MyModule;

VAR&nbsp;int:&nbsp;INTEGER;

PROCEDURE&nbsp;proc;

END&nbsp;MyModule.
</PRE>

<P>If the limit is large enough (in our case greater than 13), the following declarations will be generated in the header file: 
<P><PRE>extern&nbsp;X2C_INT32&nbsp;MyModule_int;
extern&nbsp;void&nbsp;X2C_PROCLASS&nbsp;MyModule_proc(void);
</PRE>

<P>If the <B>GENIDLEN</B> equation is set to 6, all identifiers will be reduced: 
<P><PRE>extern&nbsp;X2C_INT32&nbsp;MyModu;
extern&nbsp;void&nbsp;X2C_PROCLASS&nbsp;MyMod1(void);
</PRE>

<P>This feature can be used for satisfying the obsolete C compilers or linkers, which imposes strong restrictions on the length of identifiers. 
<P>A special naming scheme is used for the identifiers of the functions corresponding to the initialization parts of compilation units (module bodies). If the option <B>VERSIONKEY</B> is off, the compiler generates a function identifier of the form: 
<P><PRE>&lt;module_name&gt;_BEGIN
</PRE>

<P>For the above example, the initialization part will be declared as 
<P><PRE>extern&nbsp;void&nbsp;X2C_PROCLASS&nbsp;MyModule_BEGIN(void);
</PRE>

<P>or, if <TT>GENIDLEN=6</TT>, as 
<P><PRE>extern&nbsp;void&nbsp;X2C_PROCLASS&nbsp;MyMod2(void);
</PRE>

<P>If the option is on, the compiler generates the name of a module body as a composition of 
<UL>
 
<LI>a module name </LI>
<LI>a string <TT>&quot;_BEGIN_&quot;</TT> </LI>
<LI>a time stamp </LI>
<LI>values of options <B>TARGET16</B>, <B>INDEX16</B> and <B>DIFADR16</B> in the packed form. All modules constituting the project should be compiled with the same values of these options. </LI>
</UL>

<P>If the definition (or Oberon) module imported by different compilation units has the same version, the same name will be generated for each call of the module body. In all other cases unresolved references will occur at a link time. 
<P><A NAME="0536">
<A HREF="xm009.html#0516" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0535" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0537" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Example</H5>

<P><PRE>extern&nbsp;void&nbsp;X2C_PROCLASS&nbsp;MyModule_BEGIN_A0FE6691B(void);
</PRE>

<P>or, if <TT>GENIDLEN=6</TT>, as 
<P><PRE>extern&nbsp;void&nbsp;X2C_PROCLASS&nbsp;MyMod2_A0FE6691B(void);
</PRE>

<P>We recommend to switch ON the option <B>VERSIONKEY</B> whenever possible. 
<P><HR>
<A NAME="0537">
<A HREF="#0533" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0536" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0538" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Data types</H2>

<P><UL>
<LI><A HREF="#0538" TARGET=body>Basic types</A>
<LI><A HREF="#0539" TARGET=body>Special system types</A>
<LI><A HREF="#0540" TARGET=body>Modula-2 enumeration types</A>
<LI><A HREF="#0541" TARGET=body>Modula-2 set types</A>
<LI><A HREF="#0542" TARGET=body>Record types</A>
<LI><A HREF="#0543" TARGET=body>Pointer types</A>
<LI><A HREF="#0544" TARGET=body>Dynamic arrays</A>
</UL>
<P><HR>
<A NAME="0538">
<A HREF="#0537" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0537" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0539" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Basic types</H3>

<P>The correspondence between Modula-2/Oberon-2 basic types and C types is described in the tables <A HREF=#table13>13. Representation of Modula-2 basic types</A> and <A HREF=#table14>14. Representation of Oberon-2 basic types</A>. A representation of system types is described in the table <A HREF=#table15>15. Representation of SYSTEM types</A>. <B>Note:</B> Subrange types are represented by their host types. 
<P>If the option <B>GENCTYPES</B> is off, the compiler uses identifiers defined the in run-time module <TT>X2C.h</TT> for all basic types; see the last column of the tables. If the option is on, the compiler generates C type identifiers. 
<P><PRE>VAR&nbsp;ch:&nbsp;CHAR;
</PRE>

<P>translates to (<B>GENCTYPES</B> is off): 
<P><PRE>X2C_CHAR&nbsp;ch;
</PRE>

<P>or, if the option is on, to: 
<P><PRE>char&nbsp;ch;
</PRE>

<P><P ALIGN=CENTER><B><A NAME=table13>Table 13. </A></B>Representation of Modula-2 basic types

<P ALIGN=CENTER><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid solid;border-width: 1px 1px 1px 1px"><B>Basic type </B></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px"><B>Bits </B></TD>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px"><B>C type </B></TD>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px"><B>X2C type </B></TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>SHORTINT </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">8 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">signed char </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_INT8</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>INTEGER </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">16 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">short </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_INT16</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>INTEGER </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">32 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">long </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_INT32</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>LONGINT </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">32 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">long </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_INT32</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>SHORTCARD </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">8 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">unsigned char </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_CARD8</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>CARDINAL </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">16 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">unsigned short </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_CARD16</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>CARDINAL </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">32 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">unsigned long </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_CARD32</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>LONGCARD </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">32 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">long </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_CARD32</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>REAL </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">32 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">float </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_REAL</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>LONGREAL </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">64 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">double </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_LONGREAL</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>CHAR </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">8 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">unsigned char </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_CHAR</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>BOOLEAN </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">8 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">unsigned char </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_BOOLEAN</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>BITSET </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">16 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">unsigned short </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_SET16</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid solid solid;border-width: 0px 1px 1px 1px"><TT>BITSET </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px">32 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px">unsigned long </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px"><TT>X2C_SET32</TT> </TD>
</TR>
</TABLE>
<P>
<P>In Modula-2, the size of <TT>INTEGER</TT>, <TT>CARDINAL</TT> and <TT>BITSET</TT> types is controlled via the option <B>M2BASE16</B>. If the option is set, <TT>INTEGER</TT> is equal to <TT>SYSTEM.INT16</TT>, <TT>CARDINAL</TT> is equal to <TT>SYSTEM.CARD16</TT> and <TT>BITSET</TT> is defined as <TT>PACKEDSET&nbsp;OF&nbsp;[0..15]</TT>. Otherwise, all these types are 32-bits wide. 
<P><P ALIGN=CENTER><B><A NAME=table14>Table 14. </A></B>Representation of Oberon-2 basic types

<P ALIGN=CENTER><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid solid;border-width: 1px 1px 1px 1px"><B>Basic type </B></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px"><B>Bits </B></TD>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px"><B>C type </B></TD>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px"><B>X2C type </B></TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>SHORTINT </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">8 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">signed char </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_INT8</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>INTEGER </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">16 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">short int </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_INT16</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>LONGINT </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">32 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">long int </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_INT32</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>REAL </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">32 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">float </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_REAL</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>LONGREAL </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">64 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">double </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_LONGREAL</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>CHAR </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">8 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">unsigned char </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_CHAR</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>BOOLEAN </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">8 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">unsigned char </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_BOOLEAN</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid solid solid;border-width: 0px 1px 1px 1px"><TT>SET </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px">32 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px">unsigned long </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px"><TT>X2C_SET32</TT> </TD>
</TR>
</TABLE>
<P>
<P><P ALIGN=CENTER><B><A NAME=table15>Table 15. </A></B>Representation of SYSTEM types

<P ALIGN=CENTER><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid solid;border-width: 1px 1px 1px 1px"><B>System type </B></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px"><B>Bits </B></TD>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px"><B>C type </B></TD>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px"><B>X2C type </B></TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>INT8 </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">8 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">signed char </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_INT8</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>INT16 </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">16 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">short int </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_INT16</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>INT32 </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">32 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">long </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_INT32</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>CARD8 </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">8 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">unsigned char </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_CARD8</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>CARD16 </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">16 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">unsigned short </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_CARD16</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>CARD32 </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">32 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">unsigned long </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_CARD32</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>LOC </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">8 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">char </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_LOC</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>BYTE </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">8 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">char </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_LOC</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>WORD </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">32 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">array of LOC </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_WORD</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid solid solid;border-width: 0px 1px 1px 1px"><TT>ADDRESS </TT></TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px">32 </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px">pointer to LOC </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px"><TT>X2C_ADDRESS</TT> </TD>
</TR>
</TABLE>
<P>
<P><HR>
<A NAME="0539">
<A HREF="#0537" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0538" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0540" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Special system types</H3>

<P>The module SYSTEM provides special types <TT>int</TT>, <TT>unsigned</TT>, <TT>size_t</TT> and <TT>void</TT>. A characteristic feature of these types is that they are generated exactly as the corresponding C types, i.e. 
<P><PRE>VAR
&nbsp;&nbsp;x:&nbsp;SYSTEM.size_t;
&nbsp;&nbsp;y:&nbsp;SYSTEM.int;
&nbsp;&nbsp;z:&nbsp;POINTER&nbsp;TO&nbsp;SYSTEM.void;
</PRE>

<P>translates to 
<P><PRE>&nbsp;&nbsp;size_t&nbsp;x;
&nbsp;&nbsp;int&nbsp;y;
&nbsp;&nbsp;void&nbsp;*&nbsp;z;
</PRE>

<P>The types should be used in the foreign definition modules (See <A HREF="xm010.html#0524" TARGET=body>Interfacing to C</A>). 
<P><HR>
<A NAME="0540">
<A HREF="#0537" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0539" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0541" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Modula-2 enumeration types</H3>

<P>An enumeration type is translated to the C <TT>enum</TT> declaration. 
<P><PRE>TYPE&nbsp;color&nbsp;=&nbsp;(red,green,blue);
</PRE>

<P>translates to: 
<P><PRE>enum&nbsp;color&nbsp;{red,green,blue};
</PRE>

<P>or, if the option <B>GENTYPEDEF</B> is set to: 
<P><PRE>enum&nbsp;color&nbsp;{red,green,blue};
typedef&nbsp;enum&nbsp;color&nbsp;color;
</PRE>

<P><HR>
<A NAME="0541">
<A HREF="#0537" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0540" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0542" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Modula-2 set types</H3>

<P>Modula-2 sets which have not more than 32 elements are represented as unsigned types of appropriate length. Large sets are declared as array of words. 
<P><PRE>TYPE
&nbsp;&nbsp;SmallSet&nbsp;=&nbsp;SET&nbsp;OF&nbsp;[-1..1];
&nbsp;&nbsp;Set16&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;SET&nbsp;OF&nbsp;[0..15];
&nbsp;&nbsp;LongSet&nbsp;&nbsp;=&nbsp;SET&nbsp;OF&nbsp;[-1..32];
</PRE>

<P>translates to: 
<P><PRE>&nbsp;&nbsp;typedef&nbsp;X2C_SET8&nbsp;SmallSet;
&nbsp;&nbsp;typedef&nbsp;X2C_SET16&nbsp;Set16;
&nbsp;&nbsp;typedef&nbsp;X2C_CARD32&nbsp;Long[2];
</PRE>

<P><HR>
<A NAME="0542">
<A HREF="#0537" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0541" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0543" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Record types</H3>

<P>A record is translated into a C struct. 
<P><PRE>TYPE
&nbsp;&nbsp;R&nbsp;=&nbsp;RECORD
&nbsp;&nbsp;&nbsp;&nbsp;b:&nbsp;BOOLEAN;
&nbsp;&nbsp;&nbsp;&nbsp;c:&nbsp;CHAR;
&nbsp;&nbsp;END;
</PRE>

<P>translates to: 
<P><PRE>&nbsp;&nbsp;struct&nbsp;R&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;X2C_BOOLEAN&nbsp;b;
&nbsp;&nbsp;&nbsp;&nbsp;X2C_CHAR&nbsp;c;
&nbsp;&nbsp;};
</PRE>

<P>If the option <B>GENTYPEDEF</B> is set, the compiler will generate the <TT>typedef</TT> declaration including both <I>tag name</I> and <I>type name</I>. 
<P><PRE>&nbsp;&nbsp;struct&nbsp;R;
&nbsp;&nbsp;typedef&nbsp;struct&nbsp;R&nbsp;R;
&nbsp;&nbsp;struct&nbsp;R&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;X2C_BOOLEAN&nbsp;b;
&nbsp;&nbsp;&nbsp;&nbsp;X2C_CHAR&nbsp;c;
&nbsp;&nbsp;};
</PRE>

<P>The tag names are needed for the recursive structure declarations (See the next section). 
<P>A dummy field is generated for an empty record, since the C compilers treat an empty structure as an error: 
<P><PRE>&nbsp;&nbsp;struct&nbsp;R&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;X2C_INT32&nbsp;_dummy_;
&nbsp;&nbsp;}
</PRE>

<P>A variant part is translated to a C <TT>union</TT>. 
<P><PRE>&nbsp;&nbsp;R&nbsp;=&nbsp;RECORD
&nbsp;&nbsp;&nbsp;&nbsp;CASE&nbsp;tag:&nbsp;BOOLEAN&nbsp;OF
&nbsp;&nbsp;&nbsp;&nbsp;|TRUE&nbsp;:&nbsp;c:&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;|FALSE:&nbsp;b:&nbsp;BOOLEAN;
&nbsp;&nbsp;&nbsp;&nbsp;END;
&nbsp;&nbsp;&nbsp;&nbsp;set:&nbsp;BITSET;
&nbsp;&nbsp;END;
</PRE>

<P>is translated to: 
<P><PRE>&nbsp;&nbsp;struct&nbsp;R&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;X2C_BOOLEAN&nbsp;tag;
&nbsp;&nbsp;&nbsp;&nbsp;union&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X2C_CHAR&nbsp;c;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;_1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X2C_BOOLEAN&nbsp;b;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;_2;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;_;
&nbsp;&nbsp;&nbsp;&nbsp;X2C_SET32&nbsp;set;
&nbsp;&nbsp;};
</PRE>

<P>An access to a field of a variant part (r is of type R) 
<P><PRE>&nbsp;&nbsp;r.c:='a';
</PRE>

<P>is translated to: 
<P><PRE>&nbsp;&nbsp;r._._1.c:='a';
</PRE>

<P><HR>
<A NAME="0543">
<A HREF="#0537" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0542" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0544" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Pointer types</H3>

<P>A pointer type is mapped to the corresponding C type. 
<P><PRE>&nbsp;&nbsp;P&nbsp;=&nbsp;POINTER&nbsp;TO&nbsp;R;
&nbsp;&nbsp;R&nbsp;=&nbsp;RECORD
&nbsp;&nbsp;&nbsp;&nbsp;next:&nbsp;P;
&nbsp;&nbsp;END;
</PRE>

<P>is translated to: 
<P><PRE>&nbsp;&nbsp;struct&nbsp;R;
&nbsp;&nbsp;typedef&nbsp;struct&nbsp;R&nbsp;*P;
&nbsp;&nbsp;struct&nbsp;R&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;next;
&nbsp;&nbsp;};
</PRE>

<P>Pointer types are often used in a declaration of recursive data structures. In C, a recursive data structure must contain at least one <TT>struct</TT> declaration. The compiler reports an error if detects a recursive data type without at least one record type, e.g.: 
<P><PRE>&nbsp;&nbsp;T&nbsp;=&nbsp;POINTER&nbsp;TO&nbsp;T;
</PRE>

<P>This limitation should not cause any problems since data structures that constitutes of pointers only are quite artificial. 
<P>A special case is a pointer to an open array (See <A HREF="#0544" TARGET=body>Dynamic arrays</A>). 
<P><HR>
<A NAME="0544">
<A HREF="#0537" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0543" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0545" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Dynamic arrays</H3>

<P>A dynamic array type<FONT SIZE=2>&nbsp;/Pointer to a (multidimensional) open array./ </FONT> is represented as a pointer to a descriptor of an open array. For an N-dimensional open array, the descriptor contains: 
<UL>
 
<LI>a pointer to the array body; </LI>
<LI>for each of N-1 higher dimensions: 
<UL>
 
<LI>a length of an array in this dimension; </LI>
<LI>a size of array element in this dimension; </LI>
</UL>
</LI>
<LI>an array length of the last dimension. </LI>
</UL>

<P><A NAME="0545">
<A HREF="xm009.html#0516" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0544" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0546" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Example</H5>

<P><PRE>TYPE
&nbsp;&nbsp;String&nbsp;=&nbsp;POINTER&nbsp;TO&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;Matrix&nbsp;=&nbsp;POINTER&nbsp;TO&nbsp;ARRAY&nbsp;OF&nbsp;ARRAY&nbsp;OF&nbsp;REAL;
</PRE>

<P>is translated to: 
<P><PRE>&nbsp;&nbsp;struct&nbsp;_0;
&nbsp;&nbsp;typedef&nbsp;struct&nbsp;_0&nbsp;*&nbsp;String;

&nbsp;&nbsp;struct&nbsp;_0&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;X2C_CHAR&nbsp;*&nbsp;Adr;&nbsp;/*&nbsp;pointer&nbsp;to&nbsp;an&nbsp;array&nbsp;body&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;X2C_INDEX&nbsp;Len0;
&nbsp;&nbsp;};

&nbsp;&nbsp;struct&nbsp;_1;
&nbsp;&nbsp;typedef&nbsp;struct&nbsp;_1&nbsp;*&nbsp;Matrix;

&nbsp;&nbsp;struct&nbsp;_1&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;X2C_REAL&nbsp;*&nbsp;Adr;&nbsp;&nbsp;/*&nbsp;pointer&nbsp;to&nbsp;an&nbsp;array&nbsp;body&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;X2C_INDEX&nbsp;Len0;&nbsp;&nbsp;/*&nbsp;length&nbsp;of&nbsp;the&nbsp;1st&nbsp;dimension&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;X2C_INDEX&nbsp;Size1;
&nbsp;&nbsp;&nbsp;&nbsp;X2C_INDEX&nbsp;Len1;&nbsp;&nbsp;/*&nbsp;length&nbsp;of&nbsp;the&nbsp;2nd&nbsp;dimension&nbsp;*/
&nbsp;&nbsp;};
</PRE>

<P>If m is of type <TT>Matrix</TT> then the call <TT>NEW(m,3,5)</TT> will set the following values: 
<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;"><TT>Len0 </TT></TD>
<TD  STYLE="padding:0px 3px;">5 </TD>
<TD  STYLE="padding:0px 3px;">a length of the inner dimension </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><TT>Len1 </TT></TD>
<TD  STYLE="padding:0px 3px;">3 </TD>
<TD  STYLE="padding:0px 3px;">a length of the outer dimension </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><TT>Size1 </TT></TD>
<TD  STYLE="padding:0px 3px;">20 </TD>
<TD  STYLE="padding:0px 3px;">5&middot;4, if <TT>sizeof(REAL)=4</TT> </TD>
</TR>
</TABLE>
<P><HR>
<A NAME="0546">
<A HREF="#0533" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0545" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0547" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Procedure declarations</H2>

<P>A Modula-2/Oberon-2 procedure is translated to a C function. A special case is translation of a nested procedure (See <A HREF="#0553" TARGET=body>Nested procedures</A>). A generated function prototype includes call of the <TT>X2C_PROCLASS</TT> macro, if the <A HREF="xm005.html#0091" TARGET=body>GENPROCLASS</A> option is ON. 
<P>Regardless of the <A HREF="xm005.html#0091" TARGET=body>GENPROCLASS</A> setting, function prototypes corresponding to foreign procedures contains the following macro call: 
<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px"><B>DLS string </B></TD>
<TD  STYLE="padding:0px 3px;border-style: none none solid none;border-width: 0px 0px 1px 0px"><B>Macro name </B></TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>&quot;C&quot; </TT></TD>
<TD  STYLE="padding:0px 3px;">none </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>&quot;Pascal&quot; </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>X2C_PASCAL </TT></TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>&quot;StdCall&quot; </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>X2C_STDCALL </TT></TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>&quot;SysCall&quot; </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>X2C_SYSCALL </TT></TD>
</TR>
</TABLE>
<P>A list of parameters is generated according to the value of the <A HREF="xm005.html#0090" TARGET=body>GENKRC</A> option (See <A HREF="#0562" TARGET=body>Code generation</A>). If <A HREF="xm005.html#0090" TARGET=body>GENKRC</A> is ON, the compiler generates parameter names only, otherwise the compiler generates full function prototype. 
<P><UL>
<LI><A HREF="#0547" TARGET=body>Parameters</A>
<LI><A HREF="#0548" TARGET=body>Open arrays</A>
<LI><A HREF="#0549" TARGET=body>Oberon-2 variable vecord parameters</A>
<LI><A HREF="#0550" TARGET=body>Sequence parameters</A>
<LI><A HREF="#0551" TARGET=body>Function results</A>
<LI><A HREF="#0552" TARGET=body>Procedure body</A>
<LI><A HREF="#0553" TARGET=body>Nested procedures</A>
</UL>
<P><HR>
<A NAME="0547">
<A HREF="#0546" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0546" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0548" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Parameters</H3>

<P>The parameter passing convention conforms, whenever possible, to the rules of the C language. Variable parameters are declared as pointers to the formal parameter type. Exceptions are parameters of array and large set types which are always passed by reference. 
<P>The procedure header 
<P><PRE>PROCEDURE&nbsp;Foo(a:&nbsp;INTEGER;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;b:&nbsp;INTEGER;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c:&nbsp;Array;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;d:&nbsp;Array);
</PRE>

<P>is translated to: 
<P><PRE>void&nbsp;X2C_PROCLASS&nbsp;Foo(X2C_INT32&nbsp;a,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X2C_INT32&nbsp;*b,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array&nbsp;c,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array&nbsp;d)
</PRE>

<P>In the case of value arrays and long sets, the procedure called is responsible for making a local copy. 
<P><PRE>TYPE&nbsp;Vector&nbsp;=&nbsp;ARRAY&nbsp;[0..2]&nbsp;OF&nbsp;REAL;

PROCEDURE&nbsp;Foo(v:&nbsp;Vector);
BEGIN
&nbsp;&nbsp;&lt;statements&gt;
END&nbsp;Foo;
</PRE>

<P>is translated to: 
<P><PRE>typedef&nbsp;X2C_REAL&nbsp;Vector[3];

static&nbsp;void&nbsp;X2C_PROCLASS&nbsp;Foo(Vector&nbsp;v)
{
&nbsp;&nbsp;V&nbsp;tmp;
&nbsp;&nbsp;v&nbsp;=&nbsp;(X2C_REAL&nbsp;*)memcpy(tmp,v2,sizeof(V));
&nbsp;&nbsp;&lt;statments&gt;
}&nbsp;/*&nbsp;END&nbsp;Foo&nbsp;*/
</PRE>

<P>A special case is a character array parameter of a fixed size. A string literal can be passed as an actual parameter for a such formal parameter. A string literal can be shorter than the formal parameter and a special care must be taken not to access memory location beyond the end of the actual parameter. The compiler copies a string literal to a temporary variable in the caller procedure. Then in the callee procedure, the parameter will be copied again according to the standard rules. <B>Note:</B> in some cases this double copying may be prevented by marking the parameter as read-only (See <A HREF="xm007.html#0446" TARGET=body>Read-only parameters</A>). 
<P><PRE>
TYPE&nbsp;Str&nbsp;=&nbsp;ARRAY&nbsp;[0..7]&nbsp;OF&nbsp;CHAR;

PROCEDURE&nbsp;Foo(s:&nbsp;Str);
END&nbsp;Foo;

PROCEDURE&nbsp;Callee;
BEGIN
&nbsp;&nbsp;Foo(&quot;hello&quot;);
END&nbsp;Callee;
</PRE>

<P>is translated to: 
<P><PRE>typedef&nbsp;X2C_CHAR&nbsp;Str[8];

static&nbsp;void&nbsp;X2C_PROCLASS&nbsp;Foo(Str&nbsp;s)
{
&nbsp;&nbsp;A&nbsp;tmp;
&nbsp;&nbsp;s=(X2C_CHAR&nbsp;*)memcpy(tmp,s,8u);
}&nbsp;/*&nbsp;END&nbsp;Foo&nbsp;*/

static&nbsp;void&nbsp;X2C_PROCLASS&nbsp;Callee(void)
{
&nbsp;&nbsp;Str&nbsp;tmp;
&nbsp;&nbsp;Foo(*(Str&nbsp;*)memcpy(&amp;tmp,&quot;hello&quot;,6u));
}&nbsp;/*&nbsp;END&nbsp;Callee&nbsp;*/
</PRE>

<P><HR>
<A NAME="0548">
<A HREF="#0546" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0547" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0549" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Open arrays</H3>

<P>Parameters of an open array are generated according to the following rules: 
<UL>
 
<LI>for a N-dimensional open array N additional parameters (a length of each dimension) are passed. </LI>
<LI>if the parameter is a value parameter, the space necessary for the local copy is allocated at a run-time. The allocated memory is free before the function termination. </LI>
</UL>

<P><PRE>PROCEDURE&nbsp;Foo(s:&nbsp;ARRAY&nbsp;OF&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
BEGIN
&nbsp;&nbsp;&lt;statements&gt;
END&nbsp;Foo;

PROCEDURE&nbsp;Callee;
&nbsp;&nbsp;VAR&nbsp;x:&nbsp;ARRAY&nbsp;[0..1],[0..1]&nbsp;OF&nbsp;CHAR;
BEGIN
&nbsp;&nbsp;Foo(x);
END&nbsp;Callee;
</PRE>

<P>is translated to: 
<P><PRE>static&nbsp;void&nbsp;X2C_PROCLASS&nbsp;Foo(X2C_CHAR&nbsp;s[],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X2C_CARD32&nbsp;s_len,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X2C_CARD32&nbsp;s_len1)
{
&nbsp;&nbsp;X2C_PCOPY((void&nbsp;**)&amp;s,s_len*s_len1);
&nbsp;&nbsp;&lt;statements&gt;
&nbsp;&nbsp;X2C_PFREE(s,s_len*s_len1);
}&nbsp;/*&nbsp;END&nbsp;Foo&nbsp;*/

static&nbsp;void&nbsp;X2C_PROCLASS&nbsp;Callee(void)
{
&nbsp;&nbsp;X2C_CHAR&nbsp;x[2][2];
&nbsp;&nbsp;Foo((X2C_CHAR&nbsp;*)x,&nbsp;2u,&nbsp;2u);
}&nbsp;/*&nbsp;END&nbsp;Callee&nbsp;*/
</PRE>

<P><HR>
<A NAME="0549">
<A HREF="#0546" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0548" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0550" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Oberon-2 variable vecord parameters</H3>

<P>For a variable record parameter in Oberon-2 an additional parameter (<I>type tag</I>) is passed. This parameter is needed for the dynamic type tests and for calling the type-bound procedures (See also <A HREF="#0557" TARGET=body>Oberon-2 object-oriented features</A>). 
<P><PRE>PROCEDURE&nbsp;Foo(VAR&nbsp;r:&nbsp;Rec);
</PRE>

<P>is translated to: 
<P><PRE>static&nbsp;void&nbsp;proc(struct&nbsp;Rec&nbsp;*&nbsp;r,&nbsp;X2C_TD&nbsp;r_type);
</PRE>

<P><HR>
<A NAME="0550">
<A HREF="#0546" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0549" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0551" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Sequence parameters</H3>

<P>For the sequence parameters, the compiler forms the byte array explicitly as a dynamic aggregate, according to the rules specified in <A HREF="xm007.html#0448" TARGET=body>Variable number of parameters</A>. 
<P><PRE>PROCEDURE&nbsp;write(SEQ&nbsp;x:&nbsp;SYSTEM.BYTE);
END&nbsp;write;

PROCEDURE&nbsp;Foo;
&nbsp;&nbsp;VAR
&nbsp;&nbsp;&nbsp;&nbsp;i:&nbsp;INTEGER;
&nbsp;&nbsp;&nbsp;&nbsp;c:&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;r:&nbsp;REAL;
&nbsp;&nbsp;&nbsp;&nbsp;a:&nbsp;ARRAY&nbsp;[0..7]&nbsp;OF&nbsp;CHAR;
BEGIN
&nbsp;&nbsp;write(i,c,r,a);
END&nbsp;Foo;
</PRE>

<P>is translated to: 
<P><PRE>static&nbsp;void&nbsp;X2C_PROCLASS&nbsp;write(X2C_LOC&nbsp;x[],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X2C_CARD32&nbsp;x_len)
{
}&nbsp;/*&nbsp;END&nbsp;write&nbsp;*/

static&nbsp;void&nbsp;X2C_PROCLASS&nbsp;Foo(void)
&nbsp;&nbsp;X2C_INT32&nbsp;i;
&nbsp;&nbsp;X2C_CHAR&nbsp;c;
&nbsp;&nbsp;X2C_REAL&nbsp;r;
&nbsp;&nbsp;X2C_CHAR&nbsp;a[8];
&nbsp;&nbsp;X2C_SEQ&nbsp;tmp[7];
&nbsp;&nbsp;write(
&nbsp;&nbsp;&nbsp;&nbsp;(tmp[0].val=i,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp[1].val=(X2C_CARD32)c,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(X2C_LONGREAL*)&amp;tmp[2]=(X2C_LONGREAL)r,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp[4].adr=a,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp[5].val=0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp[6].val=7,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(X2C_LOC&nbsp;*)tmp),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;28u);
}&nbsp;/*&nbsp;END&nbsp;Foo&nbsp;*/
</PRE>

<P>For this call, the actual array passed to <TT>write</TT> will contain: 
<UL>
 
<LI>4 bytes of a sign-extended value of <TT>i</TT> </LI>
<LI>4 bytes of a zero-extended value of <TT>c</TT> </LI>
<LI>8 bytes of a LONGREAL value <TT>r</TT> </LI>
<LI>12 bytes of an array descriptor 
<UL>
 
<LI>4 bytes containing the address of <TT>a</TT> </LI>
<LI>4 bytes containing the value 0 </LI>
<LI>4 bytes containing the value 7 (<TT>SIZE(a)-1</TT>) </LI>
</UL>
</LI>
</UL>

<P><HR>
<A NAME="0551">
<A HREF="#0546" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0550" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0552" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Function results</H3>

<P>XDS supports arbitrary return types for functions. If a function returns an array or a large set type, an additional parameter is declared. It is used as a pointer to a temporary variable receiving the result of function. 
<P><PRE>TYPE&nbsp;A&nbsp;=&nbsp;ARRAY&nbsp;[0..1]&nbsp;OF&nbsp;REAL;

PROCEDURE&nbsp;Foo():&nbsp;A;
&nbsp;&nbsp;VAR&nbsp;a:&nbsp;A;
BEGIN
&nbsp;&nbsp;RETURN&nbsp;a
END&nbsp;Foo;

PROCEDURE&nbsp;Callee;
&nbsp;&nbsp;VAR&nbsp;x:&nbsp;A;
BEGIN
&nbsp;&nbsp;x:=Foo();
END&nbsp;Callee;
</PRE>

<P>is translated to: 
<P><PRE>typedef&nbsp;X2C_REAL&nbsp;A[2];

static&nbsp;X2C_REAL&nbsp;*&nbsp;X2C_PROCLASS&nbsp;Foo(A&nbsp;Foo_ret)
{
&nbsp;&nbsp;A&nbsp;a1;
&nbsp;&nbsp;memcpy(Foo_ret,a1,sizeof(A));
&nbsp;&nbsp;return&nbsp;Foo_ret;
}&nbsp;/*&nbsp;END&nbsp;Foo&nbsp;*/

static&nbsp;void&nbsp;X2C_PROCLASS&nbsp;Callee(void)
{
&nbsp;&nbsp;A&nbsp;x;
&nbsp;&nbsp;A&nbsp;tmp;
&nbsp;&nbsp;memcpy(x,Foo(tmp),sizeof(A));
}&nbsp;/*&nbsp;END&nbsp;Callee&nbsp;*/
</PRE>

<P><HR>
<A NAME="0552">
<A HREF="#0546" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0551" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0553" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Procedure body</H3>

<P>In most cases the translation of a procedure body is transparent. Most statements of the source languages have direct analog in C. However, in some cases a special care must be taken to preserve the language semantics. 
<P>The following example illustrates the situation where <TT>return</TT> statements are replaced with <TT>goto</TT> to free the memory allocated for a parameter. 
<P><PRE>PROCEDURE&nbsp;Length(s:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR):&nbsp;CARDINAL;
&nbsp;&nbsp;VAR&nbsp;i:&nbsp;CARDINAL;
BEGIN
&nbsp;&nbsp;i:=0;
&nbsp;&nbsp;WHILE&nbsp;i&lt;HIGH(s)&nbsp;DO
&nbsp;&nbsp;&nbsp;&nbsp;IF&nbsp;s[i]=0C&nbsp;THEN&nbsp;RETURN&nbsp;i&nbsp;END;
&nbsp;&nbsp;&nbsp;&nbsp;INC(i)
&nbsp;&nbsp;END;
&nbsp;&nbsp;RETURN&nbsp;i
END&nbsp;Length;
</PRE>

<P>is translated to: 
<P><PRE>static&nbsp;X2C_CARD32&nbsp;Length(X2C_CHAR&nbsp;s[],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X2C_CARD32&nbsp;s_len)
{
&nbsp;&nbsp;X2C_CARD32&nbsp;i;
&nbsp;&nbsp;X2C_CARD32&nbsp;Length_ret;
&nbsp;&nbsp;X2C_PCOPY((void&nbsp;**)&amp;s,s_len);
&nbsp;&nbsp;i&nbsp;=&nbsp;0;
&nbsp;&nbsp;while&nbsp;(i&lt;s_len-1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(s[i]=='\0')&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Length_ret=i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto&nbsp;label;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;+=&nbsp;1;
&nbsp;&nbsp;}&nbsp;/*&nbsp;END&nbsp;WHILE&nbsp;*/
&nbsp;&nbsp;Length_ret=i;
&nbsp;&nbsp;label:;
&nbsp;&nbsp;X2C_PFREE(s,s_len);
&nbsp;&nbsp;return&nbsp;Length_ret;
}&nbsp;/*&nbsp;END&nbsp;Length&nbsp;*/
</PRE>

<P>If a procedure contains local modules, its initialization and finalization parts (See <A HREF="xm007.html#0407" TARGET=body>Finalization</A>) are inserted into the appropriate places: 
<P><PRE>VAR&nbsp;Foo_in_operation:&nbsp;BOOLEAN;

PROCEDURE&nbsp;Foo():&nbsp;INTEGER;
&nbsp;&nbsp;MODULE&nbsp;M;
&nbsp;&nbsp;&nbsp;&nbsp;IMPORT&nbsp;Foo_in_operation;
&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;Foo_in_operation:=TRUE;
&nbsp;&nbsp;FINALLY
&nbsp;&nbsp;&nbsp;&nbsp;Foo_in_operation:=FALSE;
&nbsp;&nbsp;END&nbsp;M;
BEGIN
&nbsp;&nbsp;RETURN&nbsp;1
END&nbsp;Foo;
</PRE>

<P>is translated to: 
<P><PRE>static&nbsp;X2C_BOOLEAN&nbsp;Foo_in_operation;

static&nbsp;X2C_INT32&nbsp;Foo(void)
{
&nbsp;&nbsp;X2C_INT32&nbsp;Foo_ret;
&nbsp;&nbsp;Foo_in_operation=1;&nbsp;/*&nbsp;M&nbsp;initialization&nbsp;*/
&nbsp;&nbsp;Foo_ret=0x01l;
&nbsp;&nbsp;Foo_in_operation=0;&nbsp;/*&nbsp;M&nbsp;finalization&nbsp;*/
&nbsp;&nbsp;return&nbsp;Foo_ret;
}&nbsp;/*&nbsp;END&nbsp;Foo&nbsp;*/
</PRE>

<P>If a procedure contains an exceptional part (See <A HREF="xm007.html#0408" TARGET=body>Exceptions</A>), the procedure body is generated as <TT>if</TT> statement, where one branch corresponds to a normal part, and another to an exceptional part. The calls of run-time functions are generated to provide all necessary actions. The finalization statements (if any) are generated after the <TT>if</TT> statement. 
<P><PRE>PROCEDURE&nbsp;Div(a,b:&nbsp;INTEGER):&nbsp;INTEGER;
BEGIN
&nbsp;&nbsp;RETURN&nbsp;a&nbsp;DIV&nbsp;b
EXCEPT
&nbsp;&nbsp;RETURN&nbsp;MAX(INTEGER)
END&nbsp;Div;
</PRE>

<P>is translated to: 
<P><PRE>static&nbsp;X2C_INT32&nbsp;Div(X2C_INT32&nbsp;a,&nbsp;X2C_INT32&nbsp;b)
{
&nbsp;&nbsp;X2C_XHandler_STR&nbsp;tmp;
&nbsp;&nbsp;X2C_INT32&nbsp;Div_ret;
&nbsp;&nbsp;if&nbsp;(X2C_XTRY(&amp;tmp))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;Div_ret&nbsp;=&nbsp;X2C_DIV(a,b);
&nbsp;&nbsp;&nbsp;&nbsp;X2C_XOFF();
&nbsp;&nbsp;}
&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;Div_ret=X2C_max_longcard;
&nbsp;&nbsp;}
&nbsp;&nbsp;X2C_XREMOVE();
&nbsp;&nbsp;return&nbsp;Div_ret;
}&nbsp;/*&nbsp;END&nbsp;Div&nbsp;*/
</PRE>

<P><HR>
<A NAME="0553">
<A HREF="#0546" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0552" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0554" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Nested procedures</H3>

<P>There is no equivalent for Modula-2/Oberon-2 nested procedures in C. The compiler appends additional parameters to make an access to the local variables (and parameters) of an outer procedure(s). 
<P><A NAME="0554">
<A HREF="xm009.html#0516" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0553" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0555" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Example</H5>

<P><PRE>PROCEDURE&nbsp;proc(a:&nbsp;INTEGER);
&nbsp;&nbsp;VAR&nbsp;b,c,d:&nbsp;INTEGER;

&nbsp;&nbsp;PROCEDURE&nbsp;loc1(a:&nbsp;INTEGER);
&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;b:=a;
&nbsp;&nbsp;END&nbsp;loc1;

&nbsp;&nbsp;PROCEDURE&nbsp;loc2;
&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;loc1(d+a);
&nbsp;&nbsp;END&nbsp;loc2;

BEGIN
&nbsp;&nbsp;c:=1;
&nbsp;&nbsp;loc2;
END&nbsp;proc;
</PRE>

<P>is translated to: 
<P><PRE>static&nbsp;void&nbsp;loc1(X2C_INT32&nbsp;*&nbsp;b,&nbsp;X2C_INT32&nbsp;a)
{
&nbsp;&nbsp;*b=a;
}&nbsp;/*&nbsp;END&nbsp;loc1&nbsp;*/

static&nbsp;void&nbsp;loc2(X2C_INT32&nbsp;*&nbsp;b,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X2C_INT32&nbsp;*&nbsp;a,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X2C_INT32&nbsp;*&nbsp;d)
{
&nbsp;&nbsp;loc1(b,&nbsp;*d+*a);
}&nbsp;/*&nbsp;END&nbsp;loc2&nbsp;*/

static&nbsp;void&nbsp;X2C_PROCLASS&nbsp;proc(X2C_INT32&nbsp;a)
{
&nbsp;&nbsp;X2C_INT32&nbsp;c;
&nbsp;&nbsp;X2C_INT32&nbsp;b;
&nbsp;&nbsp;X2C_INT32&nbsp;d;
&nbsp;&nbsp;c=0x01l;
&nbsp;&nbsp;loc2(&amp;b,&nbsp;&amp;a,&nbsp;&amp;d);
}&nbsp;/*&nbsp;END&nbsp;proc&nbsp;*/
</PRE>

<P><B>Note:</B> Only the used variables are passed as additional parameters (e.g. the variable <TT>c</TT> is not used and not passed). 
<P><HR>
<A NAME="0555">
<A HREF="#0533" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0554" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0556" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Module initialization and finalization</H2>

<P>For each compilation unit the compiler generates the initialization function which contains the necessary initialization statements and statements constituting the module body. Initialization statements include the call of initialization functions of all imported modules. Two forms of an ideintifier of an initialization function are controlled by the <B>VERSIONKEY</B> option. 
<P>If the module body contains a finalization part (See <A HREF="xm007.html#0407" TARGET=body>Finalization</A>) this part is generated as a separate procedure, and the run-time support procedure is called to register it. 
<P><A NAME="0556">
<A HREF="xm009.html#0516" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0555" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0557" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Example</H5>

<P><PRE>IMPLEMENTATION&nbsp;MODULE&nbsp;M;

IMPORT&nbsp;&nbsp;A,&nbsp;B;

BEGIN
&nbsp;&nbsp;A.Foo();
FINALLY
&nbsp;&nbsp;B.Foo();
END&nbsp;M.
</PRE>

<P>is translated to (<B>VERSIONKEY</B> is OFF; the module header is omitted): 
<P><PRE>static&nbsp;void&nbsp;final(void)
/*&nbsp;finalization&nbsp;part&nbsp;*/
{
&nbsp;&nbsp;B_Foo();
}&nbsp;/*&nbsp;END&nbsp;*/

void&nbsp;M_BEGIN(void)
{
&nbsp;&nbsp;static&nbsp;int&nbsp;M_init=0;
&nbsp;&nbsp;if&nbsp;(M_init)&nbsp;return;
&nbsp;&nbsp;M_init=1;
&nbsp;&nbsp;A_BEGIN();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;initialize&nbsp;A&nbsp;*/
&nbsp;&nbsp;B_BEGIN();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;initialize&nbsp;B&nbsp;*/
&nbsp;&nbsp;X2C_FINALLY(final);&nbsp;&nbsp;/*&nbsp;register&nbsp;FINALLY&nbsp;*/
&nbsp;&nbsp;A_Foo();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;M&nbsp;initialization&nbsp;*/
}
</PRE>

<P>Each module initialization is executed only once (See the first three lines in <TT>M_BEGIN</TT>). Imported compilation units are initialized before the body of the module. 
<P>For a program module (or an Oberon-2 module marked with the <B>MAIN</B> option) the compiler uses the identifier <TT>main</TT> as the name of module body, and the <TT>main</TT> function contains a call of <TT>X2C_INIT</TT> to initialize run-time system. 
<P><HR>
<A NAME="0557">
<A HREF="#0533" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0556" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0558" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Oberon-2 object-oriented features</H2>

<P>The compiler uses the standard scheme to implement object-oriented features in Oberon-2. A dynamic type of records is needed for type tests and a table of type-bound procedures (methods or virtual functions) is needed to call them. A type descriptor containing all necessary information is created for an Oberon-2 record (See <A HREF="#0558" TARGET=body>Oberon-2 run-time data structures</A>). 
<P>A C structure corresponding to an Oberon-2 record does not contain any additional fields<FONT SIZE=2>&nbsp;/Unlike the previous XDS release./ </FONT> since, for variables of a record type, the dynamic type is statically known to the compiler. A dynamic type of an object v may differ from a static one only if v is a variable parameter of a record type or v is a pointer. For a variable parameter of a record type an additional parameter (<I>type tag</I> or a pointer to type descriptor) is passed (See <A HREF="#0549" TARGET=body>Oberon-2 variable vecord parameters</A>). 
<P>For a dynamically allocated record, a type tag (and possibly some other information) is stored before the actual record data and is invisible to a programmer. 
<P>An extended record directly contains the fields of all the base types. 
<P><PRE>TYPE
&nbsp;&nbsp;Node&nbsp;=&nbsp;POINTER&nbsp;TO&nbsp;NodeDesc;
&nbsp;&nbsp;NodeDesc&nbsp;=&nbsp;RECORD
&nbsp;&nbsp;&nbsp;&nbsp;next:&nbsp;Node;
&nbsp;&nbsp;END;
&nbsp;&nbsp;IntNodeDesc&nbsp;=&nbsp;RECORD&nbsp;(NodeDesc)
&nbsp;&nbsp;&nbsp;&nbsp;val:&nbsp;INTEGER;
&nbsp;&nbsp;END;
</PRE>

<P>is translated to: 
<P><PRE>struct&nbsp;NodeDesc;
typedef&nbsp;struct&nbsp;NodeDesc&nbsp;*&nbsp;Node;

struct&nbsp;x_NodeDesc&nbsp;{
&nbsp;&nbsp;Node&nbsp;next;
};

struct&nbsp;x_IntNodeDesc&nbsp;{
&nbsp;&nbsp;Node&nbsp;next;
&nbsp;&nbsp;X2C_INT16&nbsp;val;
};
</PRE>

<P>A type-bound procedure is translated to a function which prototype includes both a receiver parameter (two parameters if receiver is a variable record parameter) and normal parameters. 
<P><PRE>PROCEDURE&nbsp;(n:&nbsp;Node)&nbsp;Print;
END&nbsp;Print;
</PRE>

<P>is translated to a function declaration and the corresponding function type: 
<P><PRE>typedef&nbsp;void&nbsp;(X2C_PROCLASS&nbsp;*Print_)(Node);

static&nbsp;&nbsp;void&nbsp;X2C_PROCLASS&nbsp;Print(Node&nbsp;n)
{
}&nbsp;/*&nbsp;END&nbsp;Print&nbsp;*/
</PRE>

<P>The call of type-bound procedure is made via a table of methods (<TT>node</TT> is of type <TT>Node</TT>). 
<P><PRE>&nbsp;&nbsp;node.Print;
</PRE>

<P>is translated to the call of run-time macro: 
<P><PRE>&nbsp;&nbsp;X2C_CALL(Print_,X2C_GET_TD(node),0)(node);
</PRE>

<P><TT>X2C_CALL</TT> macro evaluates a procedure to call; <TT>X2C_GET_TD</TT> function returns type tag; <TT>Print_</TT> is the function type and <TT>0</TT> is the ordinal number of the <TT>Print</TT> method. 
<P><HR>
<A NAME="0558">
<A HREF="#0533" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0557" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0559" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Oberon-2 run-time data structures</H2>

<P>Certain information about an Oberon-2 module must be available at run-time. This information is provided in the form of type descriptors (for each record type) and a module descriptor. 
<P>A type descriptor contains an information necessary for: 
<UL>
 
<LI>dynamic type tests and type guards (type descriptors of all base records); </LI>
<LI>calling type-bound procedures (a method table); </LI>
<LI>garbage collection (location of pointers in records and arrays). </LI>
</UL>

<P>The run-time system provides a set of pre-defined descriptors, that are used for dynamically allocated arrays (including dynamic arrays). 
<P>A module descriptor contains an information necessary for garbage collection (the locations of all global pointers) and meta-language programming. 
<P><A NAME="0559">
<A HREF="xm009.html#0516" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0558" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0560" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Example</H5>

<P><PRE>MODULE&nbsp;x;

TYPE
&nbsp;&nbsp;Node&nbsp;=&nbsp;POINTER&nbsp;TO&nbsp;NodeDesc;
&nbsp;&nbsp;NodeDesc&nbsp;=&nbsp;RECORD
&nbsp;&nbsp;&nbsp;&nbsp;next:&nbsp;Node;
&nbsp;&nbsp;END;
&nbsp;&nbsp;IntNode&nbsp;=&nbsp;POINTER&nbsp;TO&nbsp;IntNodeDesc;
&nbsp;&nbsp;IntNodeDesc&nbsp;=&nbsp;RECORD&nbsp;(NodeDesc)
&nbsp;&nbsp;&nbsp;&nbsp;val:&nbsp;INTEGER;
&nbsp;&nbsp;END;

VAR&nbsp;root:&nbsp;Node;&nbsp;(*&nbsp;global&nbsp;pointer&nbsp;*)

PROCEDURE&nbsp;(n:&nbsp;Node)&nbsp;Print;
END&nbsp;Print;

PROCEDURE&nbsp;(n:&nbsp;IntNode)&nbsp;Print;
END&nbsp;Print;

PROCEDURE&nbsp;(n:&nbsp;IntNode)&nbsp;Foo;
END&nbsp;Foo;

END&nbsp;x.
</PRE>

<P>The following data structure will be created for the above example (type descriptor of <TT>NodeDesc</TT> and some details are omitted, comments are added by hand): 
<P><PRE>/*&nbsp;Module&nbsp;descriptor:&nbsp;*/
static&nbsp;void&nbsp;*&nbsp;x_offs[]={&nbsp;&amp;root,X2C_OFS_END&nbsp;};
static&nbsp;X2C_MD_REC&nbsp;x_desc={
&nbsp;&nbsp;0,&quot;x&quot;,x_offs
};

/*&nbsp;IntNodeDesc&nbsp;type&nbsp;descriptor:&nbsp;*/

/*&nbsp;location&nbsp;of&nbsp;pointers&nbsp;(IntNodeDesc):&nbsp;*/
static&nbsp;void&nbsp;*&nbsp;x_IntNodeDesc_offs[]=&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X2C_OFS(struct&nbsp;x_IntNodeDesc,next),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X2C_OFS_END&nbsp;};

/*&nbsp;method&nbsp;table:&nbsp;*/
static&nbsp;X2C_PROC&nbsp;x_IntNodeDesc_proc[]=&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(X2C_PROC)&nbsp;Print1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(X2C_PROC)&nbsp;Foo&nbsp;};

/*&nbsp;IntNodeDesc&nbsp;type&nbsp;descriptor:&nbsp;*/
extern&nbsp;X2C_TD_REC&nbsp;x_IntNodeDesc_desc={
&nbsp;&nbsp;sizeof(struct&nbsp;x_IntNodeDesc),
&nbsp;&nbsp;&quot;IntNodeDesc&quot;,
&nbsp;&nbsp;&amp;x_desc,
&nbsp;&nbsp;0,1,1,
&nbsp;&nbsp;/*&nbsp;base&nbsp;type&nbsp;descriptors&nbsp;*/
&nbsp;&nbsp;{&nbsp;&amp;x_NodeDesc_desc,&nbsp;&amp;x_IntNodeDesc_desc,
&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0
&nbsp;&nbsp;},
&nbsp;&nbsp;x_IntNodeDesc_proc,&nbsp;/*&nbsp;method&nbsp;table&nbsp;*/
&nbsp;&nbsp;x_IntNodeDesc_offs&nbsp;&nbsp;/*&nbsp;pointer&nbsp;locations&nbsp;*/
};
</PRE>

<P><HR>
<A NAME="0560">
<A HREF="#0533" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0559" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0561" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Options</H2>

<P>This sections describes the options that affect the generated C code. Some of the options must remain the same for all modules that belongs to the same program (See <A HREF="#0561" TARGET=body>Describing platform</A>). 
<P><UL>
<LI><A HREF="#0561" TARGET=body>Describing platform</A>
<LI><A HREF="#0562" TARGET=body>Code generation</A>
<LI><A HREF="#0574" TARGET=body>Evaluating size of types</A>
<LI><A HREF="#0575" TARGET=body>Foreign language interface</A>
<LI><A HREF="#0580" TARGET=body>Code presentation</A>
</UL>
<P><HR>
<A NAME="0561">
<A HREF="#0560" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0560" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0562" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Describing platform</H3>

<P>The XDS compilers generate a highly portable ANSI C code. However, to get correct program one must appropriately describe target platform configuration (or a C compiler) by using the following options (all options are OFF by default): 
<DL>
 
<DT>TARGET16</DT>
<DD> 
<P>The option must be set for 16-bit platform. If the option is ON, the compiler will assume the C <TT>int</TT> type is 16 bits wide. <B>Note:</B> different settings may be required for different C compilers; consult your C compiler manual. </DD>
<DT>INDEX16</DT>
<DD> 
<P>The option defines a size of an index and the maximum size of an array or structure on the target platform. If the option is ON, the compiler will assume that an index is 16 bits wide, otherwise 32 bits wide. </DD>
<DT>DIFADR16</DT>
<DD> 
<P>The option defines a difference between addresses on the target platform. If the option is ON, the compiler assumes that the difference is a 16-bit integer value, otherwise a 32-bit integer value. 
<P>The correct setting of the option is required to implement <TT>ADDADR</TT>, <TT>SUBADR</TT> and <TT>DIFADR</TT> system functions. </DD>
</DL>

<P>These options must have the same settings for all the modules of a program. <B>Note:</B> the compiler inserts a definition of the corresponding macros in the C code file. 
<P><PRE>#define&nbsp;X2C_int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;target&nbsp;32&nbsp;*/
#define&nbsp;X2C_index32&nbsp;&nbsp;&nbsp;/*&nbsp;index&nbsp;&nbsp;32&nbsp;*/
</PRE>

<P>If the <TT>VERSIONKEY</TT> option is set, an identifier of an initialization function contains settings of these options in a packed form. 
<P><HR>
<A NAME="0562">
<A HREF="#0560" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0561" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0563" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Code generation</H3>

<P><UL>
<LI><A HREF="#0563" TARGET=body>Improving readability</A>
<LI><A HREF="#0564" TARGET=body>Generate C types</A>
<LI><A HREF="#0565" TARGET=body>Debug mode</A>
<LI><A HREF="#0567" TARGET=body>Profile mode</A>
<LI><A HREF="#0568" TARGET=body>Generate K&amp;R C</A>
<LI><A HREF="#0569" TARGET=body>Generate C++</A>
<LI><A HREF="#0570" TARGET=body>Procedure class specification</A>
<LI><A HREF="#0571" TARGET=body>Generate <TT>typedef</TT></A>
<LI><A HREF="#0572" TARGET=body>Version key</A>
<LI><A HREF="#0573" TARGET=body>The length of identifiers</A>
</UL>
<P><HR>
<A NAME="0563">
<A HREF="#0562" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0562" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0564" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Improving readability</H4>

<P>By default the compiler performs a set of optimizations, including constant expression evaluation, constant propagation, etc. In the expressions it generates constant values, not constant names. 
<P>If you are using XDS as a translator, we recommend to set the option <A HREF="xm005.html#0108" TARGET=body>NOOPTIMIZE</A> ON. In this case, the compiler generates constant names whenever possible. 
<P><HR>
<A NAME="0564">
<A HREF="#0562" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0563" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0565" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Generate C types</H4>

<P>The <A HREF="xm005.html#0085" TARGET=body>GENCTYPES</A> option forces the compiler to use C type identifiers instead of the identifiers, defined in <TT>X2C.h</TT>, see tables <A HREF=#table13>13. Representation of Modula-2 basic types</A>, <A HREF=#table14>14. Representation of Oberon-2 basic types</A> and <A HREF=#table15>15. Representation of SYSTEM types</A>. 
<P><B>Note:</B> Modula-2 <TT>INTEGER</TT>, <TT>CARDINAL</TT> and <TT>BITSET</TT> types are translated according to the value of the <B>M2BASE16</B> option. In spite of the option setting, the compiler generates the identifiers from <TT>X2C.h</TT> for the following types: 
<P ALIGN=CENTER><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid solid;border-width: 1px 1px 1px 1px"><B>Source type </B></TD>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px"><B>X2C type </B></TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px">WORD </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_WORD</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px">ADDRESS </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_ADDRESS</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px">PROC </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_PROC</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px">COMPLEX </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>X2C_COMPLEX</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid solid solid;border-width: 0px 1px 1px 1px">LONGCOMPLEX </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px"><TT>X2C_LONGCOMPLEX</TT> </TD>
</TR>
</TABLE>
<P><HR>
<A NAME="0565">
<A HREF="#0562" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0564" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0566" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Debug mode</H4>

<P>The <A HREF="xm005.html#0087" TARGET=body>GENDEBUG</A> option should be set to compile your program in the debug mode. If your program is compiled in this mode, the run-time system will print a stack of procedure calls (a file name and a line number) on abnormal termination of your program. 
<P><A NAME="0566">
<A HREF="#0565" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0565" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0567" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Example</H5>

<P><PRE>&lt;*+&nbsp;GENDEBUG&nbsp;*&gt;
MODULE&nbsp;test;

PROCEDURE&nbsp;Div(a,b:&nbsp;INTEGER):&nbsp;INTEGER;
BEGIN
&nbsp;&nbsp;RETURN&nbsp;a&nbsp;DIV&nbsp;b
END&nbsp;Div;

PROCEDURE&nbsp;Try;
&nbsp;&nbsp;VAR&nbsp;res:&nbsp;INTEGER;
BEGIN
&nbsp;&nbsp;res:=Div(1,0);
END&nbsp;Try;

BEGIN
&nbsp;&nbsp;Try;
END&nbsp;test.
</PRE>

<P>When this program is running, the exception is raised and the run-time system prints the exception location and a stack of procedure calls. If the option <B>LINENO</B> is ON, all information will be reported in terms of original (Oberon-2/Modula-2) source files: 
<P><PRE>#RTS:&nbsp;No&nbsp;exception&nbsp;handler&nbsp;#6:&nbsp;zero&nbsp;or&nbsp;negative&nbsp;divisor.
test.mod&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6
test.mod&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12
test.mod&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16
</PRE>

<P>The exception was raised in line 6 of <TT>test.mod</TT>, the <TT>Div</TT> procedure was called from line 12, while the <TT>Try</TT> procedure was called from line 16 (module body). 
<P>If the option <B>LINENO</B> is OFF, all information will be reported in terms of generated C files: 
<P><PRE>#RTS:&nbsp;No&nbsp;exception&nbsp;handler&nbsp;#6:&nbsp;zero&nbsp;or&nbsp;negative&nbsp;divisor.
test.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17
test.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;27
test.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;36
</PRE>

<P>In the debug mode the compiler inserts additional calls in the generated C code (some parts of code unimportant for this example are omitted): 
<P><PRE>#define&nbsp;X2C_DEBUG

static&nbsp;&nbsp;long&nbsp;X2C_PROCLASS&nbsp;Div(long&nbsp;a,&nbsp;long&nbsp;b)
{
&nbsp;&nbsp;long&nbsp;Div_ret;
&nbsp;&nbsp;X2C_PROC_INP();
&nbsp;&nbsp;Div_ret=X2C_DIV(a,b);
&nbsp;&nbsp;X2C_PROC_OUT();
&nbsp;&nbsp;return&nbsp;Div_ret;
}&nbsp;/*&nbsp;END&nbsp;Div&nbsp;*/

static&nbsp;&nbsp;void&nbsp;X2C_PROCLASS&nbsp;Try(void)
{
&nbsp;&nbsp;long&nbsp;res;
&nbsp;&nbsp;X2C_PROC_INP();
&nbsp;&nbsp;res&nbsp;=&nbsp;(X2C_SET_HINFO()&nbsp;Div(1l,&nbsp;0l));
&nbsp;&nbsp;X2C_PROC_OUT();
}&nbsp;/*&nbsp;END&nbsp;Try&nbsp;*/
</PRE>

<P>As can be seen from the above example, the compiler 
<OL>
 
<LI>inserts the <TT>#define&nbsp;X2C_DEBUG</TT> line in the module header. This definition switches all macros, defined in <TT>X2C.h</TT> run-time library, into the debug mode. </LI>
<LI>generates calls of <TT>X2C_PROC_INP</TT> and <TT>X2C_PROC_OUT</TT> into each procedure declaration. </LI>
<LI>inserts <TT>X2C_SET_HINFO</TT> macro (set history information) into each procedure call. </LI>
</OL>

<P><B>Important notes:</B> 
<UL>
 
<LI>If not all modules of the program are compiled in the debug mode, the stack of procedure calls may be incomplete. The XDS distribution contains libraries compiled in the debug mode. We recommend to use these libraries when debugging your program. </LI>
<LI>The XDS run-time system supports 64 levels of procedure calls. If this limit is exceeded, XDS will show only the first 64 procedure calls. </LI>
<LI>Switching the option ON will significantly increase the size of your program and slow it down. </LI>
</UL>

<P><HR>
<A NAME="0567">
<A HREF="#0562" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0566" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0568" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Profile mode</H4>

<P>If the option <A HREF="xm005.html#0092" TARGET=body>GENPROFILE</A> is set ON, the compiler generates additional code to provide a profile of the program. At the end of a program execution the run-time system will print the profile of the program to standard output. For each procedure in the program the output includes: 
<UL>
 
<LI>the name of procedure; </LI>
<LI>the number of calls; </LI>
<LI>the time of procedure execution, including all internal calls; </LI>
<LI>the time of procedure execution, excluding all calls. </LI>
</UL>

<P>The option may be not implemented for all platfomrs. See your on-line documentation. 
<P><HR>
<A NAME="0568">
<A HREF="#0562" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0567" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0569" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Generate K&amp;R C</H4>

<P>The option <A HREF="xm005.html#0090" TARGET=body>GENKRC</A> forces the compiler to generate K&amp;R C instead of ANSI C. If the option is ON, the procedure declaration 
<P><PRE>PROCEDURE&nbsp;Foo(a,b:&nbsp;INTEGER);
BEGIN
&nbsp;&nbsp;...
END&nbsp;Foo.
</PRE>

<P>is translated to: 
<P><PRE>static&nbsp;void&nbsp;X2C_PROCLASS&nbsp;Foo(a,&nbsp;b)
&nbsp;&nbsp;X2C_INT32&nbsp;a;
&nbsp;&nbsp;X2C_INT32&nbsp;b;
{
&nbsp;...
}&nbsp;/*&nbsp;END&nbsp;Foo&nbsp;*/
</PRE>

<P>By default the option is OFF and XDS generates the ANSI C code. 
<P><HR>
<A NAME="0569">
<A HREF="#0562" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0568" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0570" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Generate C++</H4>

<P>The option <A HREF="xm005.html#0083" TARGET=body>GENCPP</A> forces the compiler to generate C++ instead of ANSI C. In the current release there are only few differences between generated ANSI C and C++ code. In the future versions we will use specific C++ features to improve readability and efficiency of generated code. 
<P><HR>
<A NAME="0570">
<A HREF="#0562" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0569" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0571" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Procedure class specification</H4>

<P>The option <A HREF="xm005.html#0091" TARGET=body>GENPROCLASS</A> forces the compiler to insert special macro <TT>X2C_PROCLASS</TT> into all function prototypes. 
<P>This macro can be used as a specifier of a function class, e.g. it can be set to <TT>pascal</TT> to change parameter passing convention. For many platforms, this macro cannot be used in a meaningful way. In such cases, we recommend to set the option OFF to make the generated code more readable. 
<P><HR>
<A NAME="0571">
<A HREF="#0562" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0570" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0572" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Generate <TT>typedef</TT></H4>

<P>The option <A HREF="xm005.html#0094" TARGET=body>GENTYPEDEF</A> specifies the generation of a record, enumerations and dynamic arrays. If the option is OFF, the compiler generates only tag names in the corresponding C constructs. 
<P><PRE>&nbsp;&nbsp;struct&nbsp;Rec&nbsp;{...};
&nbsp;&nbsp;enum&nbsp;Color&nbsp;{...};
</PRE>

<P>If the option is ON, the compiler generates both tag names and type names, using <TT>typedef</TT>. 
<P><PRE>&nbsp;&nbsp;struct&nbsp;Rec&nbsp;{...};
&nbsp;&nbsp;typedef&nbsp;struct&nbsp;Rec&nbsp;Rec;
&nbsp;&nbsp;enum&nbsp;Color&nbsp;{...};
&nbsp;&nbsp;typedef&nbsp;enum&nbsp;Color&nbsp;Color;
</PRE>

<P>The option is essential in the development of an interface to a foreign library. An inline usage of the option is recommended in such cases. The following examples (from <TT>stdio.h</TT> and <TT>time.h</TT> illustrate inline usage. 
<P>From the interface to <TT>stdio.h</TT>: 
<P><PRE>TYPE
&lt;*&nbsp;PUSH&nbsp;*&gt;&nbsp;&lt;*&nbsp;GENTYPEDEF+&nbsp;*&gt;
&nbsp;&nbsp;FILE&nbsp;=&nbsp;RECORD&nbsp;END;
&lt;*&nbsp;POP&nbsp;*&gt;
</PRE>

<P>The option shall be ON, since <TT>FILE</TT> is usually defined as 
<P><PRE>typedef&nbsp;struct&nbsp;{...}&nbsp;FILE;
</PRE>

<P>Vice versa, we have to switch the option OFF, when defining the interface to <TT>time.h</TT>: 
<P><PRE>TYPE
&lt;*&nbsp;PUSH&nbsp;*&gt;&nbsp;&lt;*&nbsp;GENTYPEDEF-&nbsp;*&gt;
&nbsp;&nbsp;tm&nbsp;=&nbsp;RECORD
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;END;
&lt;*&nbsp;POP&nbsp;*&gt;
</PRE>

<P>since it is defined as 
<P><PRE>struct&nbsp;tm&nbsp;{...};
</PRE>

<P><HR>
<A NAME="0572">
<A HREF="#0562" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0571" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0573" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Version key</H4>

<P>The <A HREF="xm005.html#0120" TARGET=body>VERSIONKEY</A> option specifies the generation of an identifier for an initialization function. The option is introduced to perform version checks at a link time. If the symbol file (corresponding to a definition or Oberon module) has the same version, the same names will be generated for the calls of initialization functions. If the name of an actual initialization function and the name of the called function does not match the linker will report the unresolved reference error. It means that the program must be recompiled in the right order using MAKE or PROJECT operation mode (See Chapter <A HREF="xm004.html#0033" TARGET=body>Using the compiler</A>). 
<P><B>Note:</B> the option should be set when a definition or an Oberon module is compiled. See also <A HREF="#0535" TARGET=body>Identifiers</A> for further details. 
<P><HR>
<A NAME="0573">
<A HREF="#0562" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0572" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0574" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The length of identifiers</H4>

<P>The <A HREF="xm005.html#0146" TARGET=body>GENIDLEN</A> sets the maximum length of an identifier in the generated code. <B>Note:</B> the identifier&rsquo;s length cannot be less than 6 characters. The small value leads to more compact but non-readable text. See also <A HREF="#0535" TARGET=body>Identifiers</A>. 
<P><HR>
<A NAME="0574">
<A HREF="#0560" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0573" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0575" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Evaluating size of types</H3>

<P>The programmers are used to the fact that the sizes of types are known at the compilation time, i.e. one can write 
<P><PRE>TYPE&nbsp;Rec&nbsp;=&nbsp;RECORD&nbsp;...&nbsp;END;

CONST&nbsp;Size&nbsp;=&nbsp;SIZE(Rec);
</PRE>

<P>The portable nature of XDS compilers makes an evaluation of sizes at constant times somewhat tricky. Different C compilers on different platforms may use various alignment algorithms, not mentioning that the base types may have different sizes. 
<P>To generate a portable code, the XDS compilers do not allow (in default mode) the call of <TT>SIZE</TT> and <TT>TSIZE</TT> functions to be used in constant expressions. E.g. one can write 
<P><PRE>&nbsp;&nbsp;size:=SIZE(Rec);
</PRE>

<P>but not 
<P><PRE>CONST&nbsp;Size&nbsp;=&nbsp;SIZE(Rec);
</PRE>

<P>In most cases, it is not an essential restriction, since 
<UL>
 
<LI>a use of the size of a type is rare in high-level programming; </LI>
<LI>if a constant like <TT>Size</TT> is not used itself in a constant expression it can be replaced by a variable initialized in the module body. </LI>
</UL>
However, both Modula-2 and Oberon-2 languages can be used in the low-level programming and it can be desirable to know a size of a type in compilation time, in spite of a potential non-portability of a program. 
<P>If the <A HREF="xm005.html#0093" TARGET=body>GENSIZE</A> option is set ON, the compiler will calculate sizes of types using the value of the <A HREF="xm005.html#0126" TARGET=body>ALIGNMENT</A> equation. 
<P>You have to consult with your C compiler guide to set the proper value of the equation. To prevent that inappropriate setting, the compiler generates checks in the module initialization function. 
<P><PRE>&nbsp;&nbsp;if&nbsp;(sizeof(Rec)&nbsp;!=&nbsp;4)&nbsp;X2C_TRAP(X2C_ASSERT_TRAP);
</PRE>

<P>An exception will be reported at a run-time<FONT SIZE=2>&nbsp;/During the program initialization./ </FONT> if the size evaluated by the XDS compiler is not equal to those evaluated by the C compiler. 
<P><HR>
<A NAME="0575">
<A HREF="#0560" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0574" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0576" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Foreign language interface</H3>

<P>Certain options are introduced to specify an interface to foreign languages, namely <B>NOHEADER</B>, <B>NOEXTERN</B> and <B>CSTDLIB</B>. See also the <B>GENTYPEDEF</B> option (<A HREF="#0562" TARGET=body>Code generation</A>) which is often used for providing a correct foreign language interface. 
<P><UL>
<LI><A HREF="#0576" TARGET=body>Disable header file</A>
<LI><A HREF="#0577" TARGET=body>Disable function prototype</A>
<LI><A HREF="#0578" TARGET=body>Mark C interface library</A>
</UL>
<P><HR>
<A NAME="0576">
<A HREF="#0575" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0575" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0577" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Disable header file</H4>

<P>The <A HREF="xm005.html#0107" TARGET=body>NOHEADER</A> option disables the generation of a header file. The option is usually specified in the foreign definition module to force the C compiler to use the original header files (See also <A HREF="xm010.html#0524" TARGET=body>Interfacing to C</A>). 
<P><HR>
<A NAME="0577">
<A HREF="#0575" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0576" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0578" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Disable function prototype</H4>

<P>In some cases it may be desirable not to write a foreign definition module but to use a few C functions directly. The XDS compilers allow a C function to be declared as external: 
<P><PRE>PROCEDURE&nbsp;[2]&nbsp;/&nbsp;putchar(c:&nbsp;CHAR);
</PRE>

<P>The symbol <TT>&quot;/&quot;</TT> marks a procedure as external. Only procedure header must be specified for an external procedure. After the declaration the external procedure can be used as usual: 
<P><PRE>&nbsp;&nbsp;putchar('a');
</PRE>

<P>A function defined as external can be implemented as macro, or have some additional specifications in its prototype. The <A HREF="xm005.html#0106" TARGET=body>NOEXTERN</A> option prevents the compiler from generating a function&rsquo;s prototype. In this case, a C compiler will use an original prototype (if available). 
<P><HR>
<A NAME="0578">
<A HREF="#0575" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0577" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0579" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Mark C interface library</H4>

<P>The <A HREF="xm005.html#0078" TARGET=body>CSTDLIB</A> option must be set when compiling a foreign definition module, otherwise the option is ignored. For the foreign definition marked as <B>CSTDLIB</B>, the compiler will use angle brackets <TT>&lt;&gt;</TT> in the <TT>#include</TT> directive. Otherwise the compiler will use quotes. 
<P><A NAME="0579">
<A HREF="#0578" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0578" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0580" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Example</H5>

<P><PRE>&lt;*+&nbsp;CSTDLIB&nbsp;*&gt;&nbsp;&lt;*+&nbsp;NOHEADER&nbsp;*&gt;
DEFINITION&nbsp;MODULE&nbsp;stdio;
...
END&nbsp;stdio.

MODULE&nbsp;Test;

IMPORT&nbsp;&nbsp;stdio,&nbsp;MyLib;

END&nbsp;Test.
</PRE>

<P>The import section of the module <TT>Test</TT> is translated to: 
<P><PRE>#include&nbsp;&lt;stdio.h&gt;
#include&nbsp;&quot;MyLib.h&quot;
</PRE>

<P><HR>
<A NAME="0580">
<A HREF="#0560" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0579" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0581" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Code presentation</H3>

<P>In this section we describe options that do not affect the program execution, but the C code representation. 
<P><UL>
<LI><A HREF="#0581" TARGET=body>Insert line numbers</A>
<LI><A HREF="#0583" TARGET=body>Copy comments</A>
<LI><A HREF="#0584" TARGET=body>Insert copyright message</A>
<LI><A HREF="#0585" TARGET=body>Convert header file names</A>
<LI><A HREF="#0586" TARGET=body>Set line width</A>
</UL>
<P><HR>
<A NAME="0581">
<A HREF="#0580" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0580" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0582" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Insert line numbers</H4>

<P>The <A HREF="xm005.html#0096" TARGET=body>LINENO</A> option forces the compiler to a insert line number information into the generated C code in the form of <TT>#line</TT> directives. 
<P><A NAME="0582">
<A HREF="#0581" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0581" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0583" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Example</H5>

<P><PRE>PROCEDURE&nbsp;Foo(i:&nbsp;INTEGER):&nbsp;INTEGER;
BEGIN
&nbsp;&nbsp;i:=i*i;
&nbsp;&nbsp;i:=i+i;
&nbsp;&nbsp;RETURN&nbsp;i
END&nbsp;Foo;
</PRE>

<P>translate to: 
<P><PRE>#line&nbsp;2
static&nbsp;X2C_INT32&nbsp;X2C_PROCLASS&nbsp;Foo(X2C_INT32&nbsp;i)
{
&nbsp;&nbsp;#line&nbsp;4
&nbsp;&nbsp;i=i*i;
&nbsp;&nbsp;#line&nbsp;5
&nbsp;&nbsp;i=i+i;
&nbsp;&nbsp;#line&nbsp;6
&nbsp;&nbsp;return&nbsp;i;
}&nbsp;/*&nbsp;END&nbsp;Foo&nbsp;*/
</PRE>

<P><HR>
<A NAME="0583">
<A HREF="#0580" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0582" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0584" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Copy comments</H4>

<P>The <A HREF="xm005.html#0076" TARGET=body>COMMENT</A> option forces the compiler to copy the original file comments into the generated C code. 
<P>If the option is ON, the compiler copies comments to an appropriate place in the generated C code. Comments from an Oberon-2 module are only inserted into the C code file and not into the header file. 
<P><HR>
<A NAME="0584">
<A HREF="#0580" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0583" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0585" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Insert copyright message</H4>

<P>The <A HREF="xm005.html#0136" TARGET=body>COPYRIGHT</A> equation can be used for inserting a single line comment to the very beginning of the generated code or header file. E.g., including the line 
<P><PRE>-copyright&nbsp;=&nbsp;(c)&nbsp;1995&nbsp;Widget&nbsp;Databases&nbsp;Ltd
</PRE>

<P>to <B>xm.cfg</B> will cause the following line to appear at the head of the generated C text 
<P><PRE>/*&nbsp;(c)&nbsp;1995&nbsp;Widget&nbsp;Databases&nbsp;Ltd&nbsp;*/
</PRE>

<P>See also an example in <A HREF="#0534" TARGET=body>Layout of a generated code</A>. 
<P><HR>
<A NAME="0585">
<A HREF="#0580" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0584" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0586" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Convert header file names</H4>

<P>The <A HREF="xm005.html#0077" TARGET=body>CONVHDRNAME</A> option forces the compiler to use a file name in the <TT>#include</TT> directive, according to the given file system. Otherwise the compiler will generate a module name postfixed by the header file extension. E.g., the include directive for the module <TT>MyLibrary</TT> will be generated under OS/2 as 
<P><PRE>#include&nbsp;&quot;MYLIBRAR.H&quot;
</PRE>

<P>The option may be necessary if source text resides on a FAT partition. 
<P><HR>
<A NAME="0586">
<A HREF="#0580" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0585" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="xm012.html#0587" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Set line width</H4>

<P>The <A HREF="xm005.html#0148" TARGET=body>GENWIDTH</A> equation sets the length of a line in the generated code (by default it is equal to 78). <B>Note:</B> the compiler splits a line in an appropriate place, when its length exceedes the limit.  
</BODY>
</HTML>
