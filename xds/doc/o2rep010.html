<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Procedure declarations</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<P><HR>
<A NAME="0037">
<A HREF="o2rep000.html#root" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="o2rep009.html#0036" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0038" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H1>Procedure declarations</H1>

<P>A procedure declaration consists of a procedure heading and a procedure body. The heading specifies the procedure identifier and the formal parameters. For type-bound procedures it also specifies the receiver parameter. The body contains declarations and statements. The procedure identifier is repeated at the end of the procedure declaration. 
<P>There are two kinds of procedures: <I>proper procedures</I> and <I>function procedures.</I> The latter are activated by a function designator as a constituent of an expression and yield a result that is an operand of the expression. Proper procedures are activated by a procedure call. A procedure is a function procedure if its formal parameters specify a result type. The body of a function procedure must contain a return statement which defines its result. 
<P>All constants, variables, types, and procedures declared within a procedure body are local to the procedure. Since procedures may be declared as local objects too, procedure declarations may be nested. The call of a procedure within its declaration implies recursive activation. 
<P>Objects declared in the environment of the procedure are also visible in those parts of the procedure in which they are not concealed by a locally declared object with the same name. <FONT SIZE=2>
<P><PRE>&nbsp;&nbsp;ProcedureDeclaration&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcedureHeading&nbsp;&quot;;&quot;&nbsp;ProcedureBody&nbsp;ident
&nbsp;&nbsp;ProcedureHeading&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;[Receiver]&nbsp;IdentDef&nbsp;[FormalParameters].
&nbsp;&nbsp;ProcedureBody&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeclarationSequence&nbsp;[&nbsp;BEGIN&nbsp;StatementSequence&nbsp;]&nbsp;END.
&nbsp;&nbsp;DeclarationSequence&nbsp;&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;CONST&nbsp;{&nbsp;ConstantDeclaration&quot;;&quot;&nbsp;}&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE&nbsp;{&nbsp;TypeDeclaration&nbsp;&quot;;&quot;&nbsp;}&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;{&nbsp;VariableDeclaration&nbsp;&quot;;&quot;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;|
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;ProcedureDeclaration&nbsp;&quot;;&quot;&nbsp;|&nbsp;ForwardDeclaration&nbsp;&quot;;&quot;&nbsp;}.
&nbsp;&nbsp;ForwardDeclaration&nbsp;&nbsp;&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;&quot;^&quot;[Receiver]&nbsp;IdentDef&nbsp;[FormalParameters].
</PRE>
</FONT>
<P>If a procedure declaration specifies a receiver parameter, the procedure is considered to be bound to a type (see <A HREF="#0039" TARGET=body>Type-bound procedures</A>). A forward declaration serves to allow forward references to a procedure whose actual declaration appears later in the text. The formal parameter lists of the forward declaration and the actual declaration must <I>match</I> (see <A HREF="o2rep012.html#0044" TARGET=body>Definition of terms</A>). 
<P><UL>
<LI><A HREF="#0038" TARGET=body>Formal parameters</A>
<LI><A HREF="#0039" TARGET=body>Type-bound procedures</A>
<LI><A HREF="#0040" TARGET=body>Predeclared procedures</A>
<LI><A HREF="#0041" TARGET=body>Function procedures</A>
<LI><A HREF="#0042" TARGET=body>Proper procedures</A>
</UL>
<P><HR>
<A NAME="0038">
<A HREF="#0037" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0037" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0039" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Formal parameters</H2>

<P>Formal parameters are identifiers declared in the formal parameter list of a procedure. They correspond to actual parameters specified in the procedure call. The correspondence between formal and actual parameters is established when the procedure is called. There are two kinds of parameters, value and variable parameters, indicated in the formal parameter list by the absence or presence of the keyword VAR. Value parameters are local variables to which the value of the corresponding actual parameter is assigned as an initial value. Variable parameters correspond to actual parameters that are variables, and they stand for these variables. The scope of a formal parameter extends from its declaration to the end of the procedure block in which it is declared. A function procedure without parameters must have an empty parameter list. It must be called by a function designator whose actual parameter list is empty too. The result type of a procedure can be neither a record nor an array. <FONT SIZE=2>
<P><PRE>&nbsp;&nbsp;FormalParameters&nbsp;=&nbsp;&quot;(&quot;&nbsp;[FPSection&nbsp;{&quot;;&quot;FPSection}]&nbsp;&quot;)&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&quot;:&quot;&nbsp;Qualident&nbsp;].
&nbsp;&nbsp;FPSection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;[VAR]&nbsp;ident&nbsp;{&quot;,&quot;&nbsp;ident}&nbsp;&quot;:&quot;&nbsp;Type.
</PRE>
</FONT>
<P>Let Tf be the type of a formal parameter f (not an open array) and Ta the type of the corresponding actual parameter a. For variable parameters, Ta must be the <I>same</I> as Tf, or Tf must be a record type and Ta an extension of Tf. For value parameters, a must be <I>assignment compatible</I> with f (see <A HREF="o2rep012.html#0044" TARGET=body>Definition of terms</A>). If Tf is an open array, then a must be <I>array compatible</I> with f (see <A HREF="o2rep012.html#0044" TARGET=body>Definition of terms</A>). The lengths of f are taken from a. 
<P>Examples of procedure declarations: 
<P><PRE>&nbsp;&nbsp;PROCEDURE&nbsp;ReadInt(VAR&nbsp;x:&nbsp;INTEGER);
&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;i:&nbsp;INTEGER;&nbsp;ch:&nbsp;CHAR;
&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;Read(ch);
&nbsp;&nbsp;&nbsp;&nbsp;WHILE&nbsp;(&quot;0&quot;&nbsp;&lt;=&nbsp;ch)&nbsp;&amp;&nbsp;(ch&nbsp;&gt;=&nbsp;&quot;9&quot;)&nbsp;DO
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i:=&nbsp;10*i&nbsp;+&nbsp;(ORD(ch)-ORD(&quot;0&quot;));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read(ch)
&nbsp;&nbsp;&nbsp;&nbsp;END;
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;i;
&nbsp;&nbsp;END&nbsp;ReadInt

&nbsp;&nbsp;PROCEDURE&nbsp;WriteInt(x:&nbsp;INTEGER);
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;0&nbsp;&lt;=&nbsp;x&nbsp;&lt;=&nbsp;100000&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;i:&nbsp;INTEGER;&nbsp;buf:&nbsp;ARRAY&nbsp;5&nbsp;OF&nbsp;INTEGER;
&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;REPEAT
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf[i]&nbsp;:=&nbsp;x&nbsp;MOD&nbsp;10;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;x&nbsp;DIV&nbsp;10;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INC(i)
&nbsp;&nbsp;&nbsp;&nbsp;UNTIL&nbsp;x&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;REPEAT
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEC(i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write(CHR(buf[i]&nbsp;+&nbsp;ORD(&quot;0&quot;)))
&nbsp;&nbsp;&nbsp;&nbsp;UNTIL&nbsp;i&nbsp;=&nbsp;0;
&nbsp;&nbsp;END&nbsp;WriteInt

&nbsp;&nbsp;PROCEDURE&nbsp;WriteString(s:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;i:&nbsp;INTEGER;
&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;WHILE&nbsp;(i&nbsp;&lt;&nbsp;LEN(s))&nbsp;&amp;&nbsp;(s[i]&nbsp;#&nbsp;0X)&nbsp;DO
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write(s[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INC(i)
&nbsp;&nbsp;&nbsp;&nbsp;END
&nbsp;&nbsp;END&nbsp;WriteString

&nbsp;&nbsp;PROCEDURE&nbsp;log2(x:&nbsp;INTEGER):&nbsp;INTEGER;
&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;y:&nbsp;INTEGER;&nbsp;(*&nbsp;assume&nbsp;x&gt;0&nbsp;*)
&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;:=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;WHILE&nbsp;x&nbsp;&gt;&nbsp;1&nbsp;DO&nbsp;x&nbsp;:=&nbsp;x&nbsp;DIV&nbsp;2;&nbsp;INC(y)&nbsp;END;
&nbsp;&nbsp;&nbsp;&nbsp;RETURN&nbsp;y
&nbsp;&nbsp;END&nbsp;log2
</PRE>

<P><HR>
<A NAME="0039">
<A HREF="#0037" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0038" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0040" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Type-bound procedures</H2>

<P>Globally declared procedures may be associated with a record type declared in the same module. The procedures are said to be <I>bound</I> to the record type. The binding is expressed by the type of the <I>receiver</I> in the heading of a procedure declaration. The receiver may be either a variable parameter of record type T or a value parameter of type <TT>POINTER TO </TT>T (where T is a record type). The procedure is bound to the type T and is considered local to it. <FONT SIZE=2>
<P><PRE>&nbsp;&nbsp;ProcedureHeading&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;[Receiver]&nbsp;IdentDef&nbsp;[FormalParameters].
&nbsp;&nbsp;Receiver&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&quot;(&quot;&nbsp;[VAR]&nbsp;ident&nbsp;&quot;:&quot;&nbsp;ident&nbsp;&quot;)&quot;.
</PRE>
</FONT>
<P>If a procedure P is bound to a type T0, it is implicitly also bound to any type T1 which is an extension of T0. However, a procedure P&rsquo; (with the same name as P) may be explicitly bound to T1 in which case it overrides the binding of P. P&rsquo; is considered a <I>redefinition</I> of P for T1. The formal parameters of P and P&rsquo; must <I>match</I> (see <A HREF="o2rep012.html#0044" TARGET=body>Definition of terms</A>). If P and T1 are exported (see section <A HREF="o2rep004.html#0009" TARGET=body>Declarations and scope rules</A>) P&rsquo; must be exported too. 
<P>If v is a designator and P is a type-bound procedure, then v.P denotes that procedure P which is bound to the dynamic type of v (dynamic binding). Note, that this may be a different procedure than the one bound to the static type of v. v is passed to P&rsquo;s receiver according to the parameter passing rules specified in section <A HREF="#0038" TARGET=body>Formal parameters</A>. 
<P>If r is a receiver parameter declared with type T, r.P^denotes the (redefined) procedure P bound to the base type of T. 
<P>In a forward declaration of a type-bound procedure the receiver parameter must be of the <I>same</I> type as in the actual procedure declaration. The formal parameter lists of both declarations must <I>match</I> (<A HREF="o2rep012.html#0044" TARGET=body>Definition of terms</A>). 
<P>Examples: 
<P><PRE>&nbsp;&nbsp;PROCEDURE&nbsp;(t:&nbsp;Tree)&nbsp;Insert&nbsp;(node:&nbsp;Tree);
&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;p,&nbsp;father:&nbsp;Tree;
&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;:=&nbsp;t;
&nbsp;&nbsp;&nbsp;&nbsp;REPEAT&nbsp;father&nbsp;:=&nbsp;p;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF&nbsp;node.key&nbsp;=&nbsp;p.key&nbsp;THEN&nbsp;RETURN&nbsp;END;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF&nbsp;node.key&nbsp;&lt;&nbsp;p.key&nbsp;THEN&nbsp;p&nbsp;:=&nbsp;p.left
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE&nbsp;p&nbsp;:=&nbsp;p.right
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END
&nbsp;&nbsp;&nbsp;&nbsp;UNTIL&nbsp;p&nbsp;=&nbsp;NIL;
&nbsp;&nbsp;&nbsp;&nbsp;IF&nbsp;node.key&nbsp;&lt;&nbsp;father.key&nbsp;THEN&nbsp;father.left&nbsp;:=&nbsp;node
&nbsp;&nbsp;&nbsp;&nbsp;ELSE&nbsp;father.right&nbsp;:=&nbsp;node
&nbsp;&nbsp;&nbsp;&nbsp;END;
&nbsp;&nbsp;&nbsp;&nbsp;node.left&nbsp;:=&nbsp;NIL;
&nbsp;&nbsp;&nbsp;&nbsp;node.right&nbsp;:=&nbsp;NIL
&nbsp;&nbsp;END&nbsp;Insert;

&nbsp;&nbsp;PROCEDURE&nbsp;(t:&nbsp;CenterTree)&nbsp;Insert&nbsp;(node:&nbsp;Tree);
&nbsp;&nbsp;&nbsp;&nbsp;(*redefinition*)
&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;WriteInt(node(CenterTree).width);
&nbsp;&nbsp;&nbsp;&nbsp;t.Insert^(node)
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;calls&nbsp;the&nbsp;Insert&nbsp;procedure&nbsp;bound&nbsp;to&nbsp;Tree&nbsp;*)
&nbsp;&nbsp;END&nbsp;Insert;
</PRE>

<P><HR>
<A NAME="0040">
<A HREF="#0037" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0039" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0041" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Predeclared procedures</H2>

<P>The following table lists the predeclared procedures. Some are generic procedures, i.e. they apply to several types of operands. v stands for a variable, x and n for expressions, and T for a type. 
<P><HR>
<A NAME="0041">
<A HREF="#0037" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0040" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0042" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Function procedures</H2>

<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;">Name </TD>
<TD  STYLE="padding:0px 3px;">Argument type </TD>
<TD  STYLE="padding:0px 3px;">Result type </TD>
<TD  STYLE="padding:0px 3px;">Function </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">&nbsp;</TD>
<TD  STYLE="padding:0px 3px;">&nbsp;</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">ABS(x) </TD>
<TD  STYLE="padding:0px 3px;">numeric type </TD>
<TD  STYLE="padding:0px 3px;">type of x </TD>
<TD  STYLE="padding:0px 3px;">absolute value </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">ASH(x,n) </TD>
<TD  STYLE="padding:0px 3px;">x,n: integer type </TD>
<TD  STYLE="padding:0px 3px;">LONGINT </TD>
<TD  STYLE="padding:0px 3px;">arithmetic shift (x*2n) </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">CAP(x) </TD>
<TD  STYLE="padding:0px 3px;">CHAR </TD>
<TD  STYLE="padding:0px 3px;">CHAR </TD>
<TD  STYLE="padding:0px 3px;">x is letter: corresponding capital letter </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">CHR(x) </TD>
<TD  STYLE="padding:0px 3px;">integer type </TD>
<TD  STYLE="padding:0px 3px;">CHAR </TD>
<TD  STYLE="padding:0px 3px;">character with ordinal number x </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">ENTIER(x)</TD>
<TD  STYLE="padding:0px 3px;">real type </TD>
<TD  STYLE="padding:0px 3px;">LONGINT </TD>
<TD  STYLE="padding:0px 3px;">largest integer not greater than x </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">LEN(v,n) </TD>
<TD  STYLE="padding:0px 3px;">v: array; n: integer const. </TD>
<TD  STYLE="padding:0px 3px;">LONGINT </TD>
<TD  STYLE="padding:0px 3px;">length of v in dimension n (first dimension = 0) </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">LEN(v) </TD>
<TD  STYLE="padding:0px 3px;">v: array </TD>
<TD  STYLE="padding:0px 3px;">LONGINT </TD>
<TD  STYLE="padding:0px 3px;">the same as LEN(v,0) </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">LONG(x) </TD>
<TD  STYLE="padding:0px 3px;">SHORTINT </TD>
<TD  STYLE="padding:0px 3px;">INTEGER </TD>
<TD  STYLE="padding:0px 3px;">identity </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">&nbsp;</TD>
<TD  STYLE="padding:0px 3px;">INTEGER </TD>
<TD  STYLE="padding:0px 3px;">LONGINT </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">&nbsp;</TD>
<TD  STYLE="padding:0px 3px;">REAL </TD>
<TD  STYLE="padding:0px 3px;">LONGREAL </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">MAX(T) </TD>
<TD  STYLE="padding:0px 3px;">T = basic type </TD>
<TD  STYLE="padding:0px 3px;">T </TD>
<TD  STYLE="padding:0px 3px;">maximum value of type T </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">&nbsp;</TD>
<TD  STYLE="padding:0px 3px;">T = SET </TD>
<TD  STYLE="padding:0px 3px;">INTEGER </TD>
<TD  STYLE="padding:0px 3px;">maximum element of a set </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">MIN(T) </TD>
<TD  STYLE="padding:0px 3px;">T = basic type </TD>
<TD  STYLE="padding:0px 3px;">T </TD>
<TD  STYLE="padding:0px 3px;">minimum value of type T </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">&nbsp;</TD>
<TD  STYLE="padding:0px 3px;">T = SET </TD>
<TD  STYLE="padding:0px 3px;">INTEGER </TD>
<TD  STYLE="padding:0px 3px;">0 </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">ODD(x) </TD>
<TD  STYLE="padding:0px 3px;">integer type </TD>
<TD  STYLE="padding:0px 3px;">BOOLEAN </TD>
<TD  STYLE="padding:0px 3px;">x MOD 2 = 1 </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">ORD(x) </TD>
<TD  STYLE="padding:0px 3px;">CHAR </TD>
<TD  STYLE="padding:0px 3px;">INTEGER </TD>
<TD  STYLE="padding:0px 3px;">ordinal number of x </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">SHORT(x) </TD>
<TD  STYLE="padding:0px 3px;">LONGINT </TD>
<TD  STYLE="padding:0px 3px;">INTEGER </TD>
<TD  STYLE="padding:0px 3px;">identity </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">&nbsp;</TD>
<TD  STYLE="padding:0px 3px;">INTEGER </TD>
<TD  STYLE="padding:0px 3px;">SHORTINT </TD>
<TD  STYLE="padding:0px 3px;">identity </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">&nbsp;</TD>
<TD  STYLE="padding:0px 3px;">LONGREAL </TD>
<TD  STYLE="padding:0px 3px;">REAL </TD>
<TD  STYLE="padding:0px 3px;">identity (truncation possible) </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">SIZE(T) </TD>
<TD  STYLE="padding:0px 3px;">any type </TD>
<TD  STYLE="padding:0px 3px;">integer </TD>
<TD  STYLE="padding:0px 3px;">number of bytes required by T </TD>
</TR>
</TABLE>
<P><HR>
<A NAME="0042">
<A HREF="#0037" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0041" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="o2rep011.html#0043" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Proper procedures</H2>

<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;">Name </TD>
<TD  STYLE="padding:0px 3px;">Argument types </TD>
<TD  STYLE="padding:0px 3px;">Function </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">&nbsp;</TD>
<TD  STYLE="padding:0px 3px;">&nbsp;</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">ASSERT(x) </TD>
<TD  STYLE="padding:0px 3px;">x: Boolean expression </TD>
<TD  STYLE="padding:0px 3px;">terminate program execution if not x </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">ASSERT(x,n) </TD>
<TD  STYLE="padding:0px 3px;">x: Boolean expression; n: integer constant </TD>
<TD  STYLE="padding:0px 3px;">terminate program execution if not x </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">COPY(x,v) </TD>
<TD  STYLE="padding:0px 3px;">x: character array, string; v: character array </TD>
<TD  STYLE="padding:0px 3px;">v := x </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">DEC(v) </TD>
<TD  STYLE="padding:0px 3px;">integer type </TD>
<TD  STYLE="padding:0px 3px;">v := v - 1 </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">DEC(v,n) </TD>
<TD  STYLE="padding:0px 3px;">v, n: integer type </TD>
<TD  STYLE="padding:0px 3px;">v := v - n </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">EXCL(v,x) </TD>
<TD  STYLE="padding:0px 3px;">v: SET; x: integer type </TD>
<TD  STYLE="padding:0px 3px;">v := v - x </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">HALT(n) </TD>
<TD  STYLE="padding:0px 3px;">integer constant </TD>
<TD  STYLE="padding:0px 3px;">terminate program execution </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">INC(v) </TD>
<TD  STYLE="padding:0px 3px;">integer type </TD>
<TD  STYLE="padding:0px 3px;">v := v + 1 </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">INC(v,n) </TD>
<TD  STYLE="padding:0px 3px;">v, n: integer type </TD>
<TD  STYLE="padding:0px 3px;">v := v + n </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">INCL(v,x) </TD>
<TD  STYLE="padding:0px 3px;">v: SET; x: integer type </TD>
<TD  STYLE="padding:0px 3px;">v := v + x </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">NEW(v) </TD>
<TD  STYLE="padding:0px 3px;">pointer to record or fixed array </TD>
<TD  STYLE="padding:0px 3px;">allocate v^</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">NEW(v,x0,...,xn) </TD>
<TD  STYLE="padding:0px 3px;">v: pointer to open array; xi: integer type </TD>
<TD  STYLE="padding:0px 3px;">allocate v^with lengths x0...xn </TD>
</TR>
</TABLE>
<P>COPY allows the assignment of a string or a character array containing a terminating 0X to another character array. If necessary, the assigned value is truncated to the target length minus one. The target will always contain 0X as a terminator. In ASSERT(x,n) and HALT(n), the interpretation of n is left to the underlying system implementation. 
</BODY>
</HTML>
