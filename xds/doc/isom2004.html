<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>System Modules</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<P><HR>
<A NAME="0305">
<A HREF="isom2000.html#root" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="isom2003.html#0304" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0306" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H1>System Modules</H1>

<P>System modules are not compilation modules, in the sense that they do not have an actual definition or implementation provided in a library, or by the user. They encapsulate predefined types, constants and procedures, for which the predefined identifiers are not pervasive. 
<P>For information only, the interfaces to system modules are shown informally in this International Standard as definition modules. The required semantics cannot be obtained by interpreting these system definition modules according to the rules for separate modules as given in section 6. In particular, as predefined entities, the procedures and functions of a system module are not assignment-compatible with any procedure type. Also, types appearing as opaque types are system basic types and cannot be used to implement user-defined opaque types. 
<P>This International Standard defines five system modules, namely <TT>SYSTEM,&nbsp;COROUTINES,&nbsp;TERMINATION,&nbsp;EXCEPTIONS</TT>, and <TT>M2EXCEPTION</TT>. 
<P><B>Change:</B> In Programming in Modula-2 the only system module is SYSTEM and this is described as a pseudo-module. Coroutine facilities have been moved from SYSTEM to the system module COROUTINES in this International Standard. 
<P><UL>
<LI><A HREF="#0306" TARGET=body>The Module SYSTEM</A>
<LI><A HREF="#0327" TARGET=body>The Module COROUTINES</A>
<LI><A HREF="#0342" TARGET=body>The Module EXCEPTIONS</A>
<LI><A HREF="#0354" TARGET=body>The Module TERMINATION</A>
<LI><A HREF="#0359" TARGET=body>The Module M2EXCEPTION</A>
</UL>
<P><HR>
<A NAME="0306">
<A HREF="#0305" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0305" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0307" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>The Module SYSTEM</H2>

<P>The system module <TT>SYSTEM</TT> provides low-level facilities for gaining access to the addresses and the underlying storage of variables, for performing address arithmetic, and for manipulating the representation of values. Programs that use these facilities may be non-portable. 
<P><UL>
<LI><A HREF="#0307" TARGET=body>The Interface to SYSTEM</A>
<LI><A HREF="#0308" TARGET=body>The Constants of SYSTEM</A>
<LI><A HREF="#0309" TARGET=body>The Types of SYSTEM</A>
<LI><A HREF="#0312" TARGET=body>The Functions of SYSTEM</A>
<LI><A HREF="#0313" TARGET=body>Address Arithmetic Functions</A>
<LI><A HREF="#0318" TARGET=body>Address Construction and Enquiry Functions</A>
<LI><A HREF="#0321" TARGET=body>Packedset Functions</A>
<LI><A HREF="#0325" TARGET=body>The Function CAST</A>
<LI><A HREF="#0326" TARGET=body>The Function TSIZE</A>
</UL>
<P><HR>
<A NAME="0307">
<A HREF="#0306" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0306" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0308" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Interface to SYSTEM</H3>

<P>The interface to <TT>SYSTEM</TT> behaves as if the following were its definition module: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;DEFINITION&nbsp;MODULE&nbsp;SYSTEM;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Gives&nbsp;access&nbsp;to&nbsp;system&nbsp;programming&nbsp;facilities&nbsp;that&nbsp;are&nbsp;probably&nbsp;non&nbsp;portable.&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;The&nbsp;constants&nbsp;and&nbsp;types&nbsp;define&nbsp;underlying&nbsp;properties&nbsp;of&nbsp;storage&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;CONST
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BITSPERLOC&nbsp;=&nbsp;&lt;implementation-defined&nbsp;constant&gt;&nbsp;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOCSPERWORD&nbsp;=&nbsp;&lt;implementation-defined&nbsp;constant&gt;&nbsp;;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;TYPE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOC;&nbsp;(*&nbsp;A&nbsp;system&nbsp;basic&nbsp;type.&nbsp;Values&nbsp;are&nbsp;the&nbsp;uninterpreted&nbsp;contents&nbsp;of&nbsp;the&nbsp;smallest
&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addressable&nbsp;unit&nbsp;of&nbsp;storage&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ADDRESS&nbsp;=&nbsp;POINTER&nbsp;TO&nbsp;LOC;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WORD&nbsp;=&nbsp;ARRAY&nbsp;[0&nbsp;..&nbsp;LOCSPERWORD-1]&nbsp;OF&nbsp;LOC;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;BYTE&nbsp;and&nbsp;LOCSPERBYTE&nbsp;are&nbsp;provided&nbsp;if&nbsp;appropriate&nbsp;for&nbsp;machine&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;CONST
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOCSPERBYTE&nbsp;=&nbsp;&lt;implementation-defined&nbsp;constant&gt;&nbsp;;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;TYPE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;=&nbsp;ARRAY&nbsp;[0&nbsp;..&nbsp;LOCSPERBYTE-1]&nbsp;OF&nbsp;LOC;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;ADDADR&nbsp;(addr:&nbsp;ADDRESS;&nbsp;offset:&nbsp;CARDINAL):&nbsp;ADDRESS;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Returns&nbsp;address&nbsp;given&nbsp;by&nbsp;(addr&nbsp;+&nbsp;offset),&nbsp;or&nbsp;may&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if&nbsp;this
&nbsp;&nbsp;&nbsp;	&nbsp;address&nbsp;is&nbsp;not&nbsp;valid.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;SUBADR&nbsp;(addr:&nbsp;ADDRESS;&nbsp;offset:&nbsp;CARDINAL):&nbsp;ADDRESS;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Returns&nbsp;address&nbsp;given&nbsp;by&nbsp;(addr&nbsp;-&nbsp;offset),&nbsp;or&nbsp;may&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if&nbsp;this&nbsp;address
&nbsp;&nbsp;&nbsp;	&nbsp;is&nbsp;not&nbsp;valid.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;DIFADR&nbsp;(addr1,&nbsp;addr2:&nbsp;ADDRESS):&nbsp;INTEGER;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Returns&nbsp;the&nbsp;difference&nbsp;between&nbsp;addresses&nbsp;(addr1&nbsp;-&nbsp;addr2),&nbsp;or&nbsp;may&nbsp;raise&nbsp;an&nbsp;exception
&nbsp;&nbsp;&nbsp;	&nbsp;if&nbsp;the&nbsp;arguments&nbsp;are&nbsp;invalid&nbsp;or&nbsp;if&nbsp;the&nbsp;address&nbsp;space&nbsp;is&nbsp;non-contiguous.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;MAKEADR&nbsp;(val:&nbsp;&lt;some&nbsp;type&gt;;&nbsp;...&nbsp;):&nbsp;ADDRESS;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Returns&nbsp;an&nbsp;address&nbsp;constructed&nbsp;from&nbsp;a&nbsp;list&nbsp;of&nbsp;values&nbsp;whose&nbsp;types&nbsp;are
&nbsp;&nbsp;&nbsp;	&nbsp;implementation-defined,&nbsp;or&nbsp;may&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if&nbsp;this&nbsp;address&nbsp;is&nbsp;not&nbsp;valid.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;ADR&nbsp;(VAR&nbsp;v:&nbsp;&lt;anytype&gt;):&nbsp;ADDRESS;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Returns&nbsp;the&nbsp;address&nbsp;of&nbsp;variable&nbsp;v.&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;ROTATE&nbsp;(val:&nbsp;&lt;a&nbsp;packedset&nbsp;type&gt;;&nbsp;num:&nbsp;INTEGER):&nbsp;&lt;type&nbsp;of&nbsp;first&nbsp;parameter&gt;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Returns&nbsp;a&nbsp;bit&nbsp;sequence&nbsp;obtained&nbsp;from&nbsp;val&nbsp;by&nbsp;rotating&nbsp;up&nbsp;or&nbsp;down&nbsp;(left&nbsp;or&nbsp;right)&nbsp;by
&nbsp;&nbsp;&nbsp;	&nbsp;the&nbsp;absolute&nbsp;value&nbsp;of&nbsp;num.&nbsp;The&nbsp;direction&nbsp;is&nbsp;down&nbsp;if&nbsp;the&nbsp;sign&nbsp;of&nbsp;num&nbsp;is&nbsp;negative,
&nbsp;&nbsp;&nbsp;	&nbsp;otherwise&nbsp;the&nbsp;direction&nbsp;is&nbsp;up.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;SHIFT&nbsp;(val:&nbsp;&lt;a&nbsp;packedset&nbsp;type&gt;;&nbsp;num:&nbsp;INTEGER):&nbsp;&lt;type&nbsp;of&nbsp;first&nbsp;parameter&gt;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Returns&nbsp;a&nbsp;bit&nbsp;sequence&nbsp;obtained&nbsp;from&nbsp;val&nbsp;by&nbsp;shifting&nbsp;up&nbsp;or&nbsp;down&nbsp;(left&nbsp;or&nbsp;right)&nbsp;by
&nbsp;&nbsp;&nbsp;	&nbsp;the&nbsp;absolute&nbsp;value&nbsp;of&nbsp;num,&nbsp;introducing&nbsp;zeros&nbsp;as&nbsp;necessary.&nbsp;The&nbsp;direction&nbsp;is&nbsp;down
&nbsp;&nbsp;&nbsp;	&nbsp;if&nbsp;the&nbsp;sign&nbsp;of&nbsp;num&nbsp;is&nbsp;negative,&nbsp;otherwise&nbsp;the&nbsp;direction&nbsp;is&nbsp;up.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;CAST&nbsp;(&lt;targettype&gt;;&nbsp;val:&nbsp;&lt;anytype&gt;):&nbsp;&lt;targettype&gt;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;CAST&nbsp;is&nbsp;a&nbsp;type&nbsp;transfer&nbsp;function.&nbsp;Given&nbsp;the&nbsp;expression&nbsp;denoted&nbsp;by&nbsp;val,&nbsp;it&nbsp;returns
&nbsp;&nbsp;&nbsp;	&nbsp;a&nbsp;value&nbsp;of&nbsp;the&nbsp;type&nbsp;&lt;targettype&gt;.&nbsp;An&nbsp;invalid&nbsp;value&nbsp;for&nbsp;the&nbsp;target&nbsp;value&nbsp;or&nbsp;a
&nbsp;&nbsp;&nbsp;	&nbsp;physical&nbsp;address&nbsp;alignment&nbsp;problem&nbsp;may&nbsp;raise&nbsp;an&nbsp;exception.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;TSIZE&nbsp;(&lt;type&gt;;&nbsp;...&nbsp;):&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Returns&nbsp;the&nbsp;number&nbsp;of&nbsp;LOCS&nbsp;used&nbsp;to&nbsp;store&nbsp;a&nbsp;value&nbsp;of&nbsp;the&nbsp;specified&nbsp;&lt;type&gt;.&nbsp;The
&nbsp;&nbsp;&nbsp;	&nbsp;extra&nbsp;parameters,&nbsp;if&nbsp;present,&nbsp;are&nbsp;used&nbsp;to&nbsp;distinguish&nbsp;variants&nbsp;in&nbsp;a&nbsp;variant&nbsp;record.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;SYSTEM.
</PRE>

<P><B>Declaration Semantics</B> 
<P>The identifiers available for import from the module <TT>SYSTEM</TT> shall include the constant identifiers <TT>BITSPERLOC</TT>, and <TT>LOCSPERWORD</TT>, the type identifiers <TT>LOC,&nbsp;ADDRESS</TT>, and <TT>WORD</TT>, and the procedure identifiers <TT>ADDADR</TT>, <TT>SUBADR</TT>, <TT>DIFADR</TT>, <TT>MAKEADR</TT>, <TT>ADR</TT>, <TT>ROTATE</TT>, <TT>SHIFT</TT>, <TT>CAST</TT>, and <TT>TSIZE</TT>. 
<P>In addition, where appropriate for the target hardware architecture, the identifiers available for import from the module <TT>SYSTEM</TT> shall include the constant identifier <TT>LOCSPERBYTE</TT>, and the type identifier <TT>BYTE</TT>. 
<P><B>Note:</B> An implementation may extend the module <TT>SYSTEM</TT> by including additional types, procedures, variables and constants appropriate to the facilities of the target hardware. The identifiers <TT>BYTE</TT> and <TT>LOCSPERBYTE</TT> are, however, reserved for use with appropriate target hardware architectures, and may not be used in <TT>SYSTEM</TT> with other meanings &mdash; see ???. 
<P><B>Changes:</B> 
<OL>
 
<LI>The type <TT>LOC</TT> has been introduced as a mechanism to resolve the problem that, in many implementations of Modula-2, both <TT>BYTE</TT> and <TT>WORD</TT> occur in <TT>SYSTEM</TT>. Its introduction allows a consistent handling of both of these types, and also enables further <TT>WORD</TT>-like types to be introduced in an implementation, for example, where <TT>TSIZE(CARDINAL)6=TSIZE(INTEGER)</TT>. </LI>
<LI>The constants <TT>BITSPERLOC,&nbsp;LOCSPERWORD</TT> and <TT>LOCSPERBYTE</TT> have been introduced to denote the number of bits in a LOC, the number of <TT>LOC</TT>s in a word and the number of <TT>LOC</TT>s in a <TT>BYTE</TT> respectively. </LI>
<LI>Variables of type <TT>ADDRESS</TT> are no longer expression-compatible with <TT>CARDINAL</TT>, i.e. they cannot directly occur in expressions that include arithmetic operators. </LI>
<LI>The function <TT>MAKEADR</TT> has been introduced as a mechanism for constructing a value of type <TT>ADDRESS</TT>, and new functions <TT>ADDADR,&nbsp;SUBADR</TT>, and <TT>DIFADR</TT> have been introduced for address arithmetic, thereby obviating the necessity for assignment compatibility between <TT>ADDRESS</TT> and a whole number type. </LI>
<LI>New functions <TT>ROTATE</TT> and <TT>SHIFT</TT> have been introduced to extend the bit-level manipulation operations on packedset values. </LI>
<LI>The function <TT>CAST</TT> has been introduced for type transfer. </LI>
</OL>

<P><HR>
<A NAME="0308">
<A HREF="#0306" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0307" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0309" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Constants of SYSTEM</H3>

<P>The module <TT>SYSTEM</TT> provides the constants <TT>BITSPERLOC</TT> and <TT>LOCSPERWORD</TT>. Additionally, if appropriate for the target hardware architecture, the constant <TT>LOCSPERBYTE</TT> is provided. 
<P><B>Declaration Semantics</B> 
<P>The constant identifier <TT>BITSPERLOC</TT> shall denote the whole number literal value that is the number of bits used in the representation of values of the location type and other types occupying a single location. 
<P>The constant identifier <TT>LOCSPERWORD</TT> shall denote the whole number literal value that is the number of locations used in the representation of values of the type denoted by <TT>WORD</TT> and other types occupying a single word. 
<P>The constant identifier <TT>LOCSPERBYTE</TT>, if provided, shall denote the whole number literal value that is the number of locations used in the representation of values of the type denoted by <TT>BYTE</TT> and other types occupying a single byte. 
<P><HR>
<A NAME="0309">
<A HREF="#0306" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0308" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0310" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Types of SYSTEM</H3>

<P>The module <TT>SYSTEM</TT> provides system storage types to represent uninterpreted storage, and a type to represent logical addresses. 
<P><UL>
<LI><A HREF="#0310" TARGET=body>System Storage Types</A>
<LI><A HREF="#0311" TARGET=body>The Address Type</A>
</UL>
<P><HR>
<A NAME="0310">
<A HREF="#0309" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0309" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0311" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>System Storage Types</H4>

<P>System storage types include the location type, and types based on the location type. 
<P><B>Declaration Semantics</B> 
<P>The type identifier <TT>LOC</TT> shall denote the location type. A value of this type shall correspond to the uninterpreted contents of the smallest addressable unit of storage in an implementation; the value of the call <TT>TSIZE(LOC)</TT> shall therefore be one. 
<P><B>Notes:</B> 
<OL>
 
<LI>The only operation directly defined on the location type is assignment. </LI>
<LI>There are special rules affecting parameter compatibility for system storage types; where a formal parameter is expressed in terms of system storage types, the corresponding actual parameter may be of any type that is represented in a corresponding number of storage locations &mdash; see <A HREF="isom2003.html#0190" TARGET=body>System Storage Parameter Compatibility</A>. </LI>
</OL>

<P>The type denoted by <TT>WORD</TT> shall be defined in terms of <TT>LOC</TT> as follows: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;LOCSPERWORD&nbsp;=&nbsp;&lt;implementation-defined&nbsp;constant&gt;&nbsp;;
&nbsp;&nbsp;&nbsp;&nbsp;WORD&nbsp;=&nbsp;ARRAY&nbsp;[0&nbsp;..&nbsp;LOCSPERWORD-1]&nbsp;OF&nbsp;LOC;
</PRE>

<P>and the value of the call <TT>TSIZE(WORD)</TT> shall be <TT>LOCSPERWORD</TT>. 
<P>The type denoted by <TT>BYTE</TT>, if provided, shall be defined in terms of <TT>LOC</TT> as follows: if <TT>TSIZE(BYTE)&nbsp;=&nbsp;1</TT> then 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;LOCSPERBYTE&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;=&nbsp;LOC;
</PRE>

<P>and if <TT>TSIZE(BYTE)&nbsp;&gt;&nbsp;1</TT> then 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;LOCSPERBYTE&nbsp;=&nbsp;&lt;implementation-defined&nbsp;constant&gt;&nbsp;;
&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;=&nbsp;ARRAY&nbsp;[0&nbsp;..&nbsp;LOCSPERBYTE-1]&nbsp;OF&nbsp;LOC;
</PRE>

<P>and the value of the call <TT>TSIZE(BYTE)</TT> shall be <TT>LOCSPERBYTE</TT>. 
<P><HR>
<A NAME="0311">
<A HREF="#0309" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0310" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0312" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Address Type</H4>

<P><B>Declaration Semantics</B> 
<P>The declaration: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;TYPE&nbsp;ADDRESS&nbsp;=&nbsp;POINTER&nbsp;TO&nbsp;LOC;
</PRE>

<P>shall define the address type. Values of this type shall correspond to the logical addresses of storage locations. 
<P><B>Notes:</B> 
<OL>
 
<LI>The term &lsquo;logical addresses&rsquo; is used since it is required that the address type is assignment-compatible with all pointer types and vice-versa &mdash; see <A HREF="isom2003.html#0100" TARGET=body>Assignment Compatibility</A>. </LI>
<LI>A formal variable parameter of the address type is parameter-compatible with an actual variable parameter of any pointer type &mdash; see <A HREF="isom2003.html#0189" TARGET=body>Variable Parameter Compatibility</A>. </LI>
<LI>As well as the operations that are normally applicable to values of pointer types, the system function procedures <TT>ADDADR</TT>, <TT>SUBADR</TT>, and <TT>DIFADR</TT> allow address arithmetic to be applied to all pointer types. In the case of <TT>ADDADR</TT> and <TT>SUBADR</TT> the result type is the address type; in the case of <TT>DIFADR</TT> the result type is the signed type. </LI>
<LI>Values of the address type may be used in the optional expression that follows the identifier in a variable declaration to fix the storage location of that variable; they may be constructed with the function <TT>MAKEADR</TT> &mdash; see <A HREF="#0319" TARGET=body>The Function MAKEADR</A>. </LI>
</OL>

<P><HR>
<A NAME="0312">
<A HREF="#0306" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0311" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0313" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Functions of SYSTEM</H3>

<P>The module <TT>SYSTEM</TT> provides function procedures for address arithmetic (<TT>ADDADR,&nbsp;DIFADR</TT>, and <TT>SUBADDR</TT>), for address value generation (<TT>MAKEADR</TT> and <TT>ADR</TT>), for packedset operations (<TT>ROTATE</TT> and <TT>SHIFT</TT>), for type transfer (<TT>CAST</TT>), and for determining the storage size of values of a given type (<TT>TSIZE</TT>). 
<P><HR>
<A NAME="0313">
<A HREF="#0306" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0312" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0314" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Address Arithmetic Functions</H3>

<P>The function procedures <TT>ADDADR,&nbsp;SUBADDR</TT> and <TT>DIFADR</TT> are provided for address arithmetic operations on values of pointer types. 
<P><UL>
<LI><A HREF="#0314" TARGET=body>The Function ADDADR</A>
<LI><A HREF="#0315" TARGET=body>The Function SUBADR</A>
<LI><A HREF="#0316" TARGET=body>The Function DIFADR</A>
<LI><A HREF="#0317" TARGET=body>Properties of the address arithmetic functions</A>
</UL>
<P><HR>
<A NAME="0314">
<A HREF="#0313" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0313" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0315" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function ADDADR</H4>

<P>The function <TT>ADDADR</TT> can be used to construct a value of the address type by adding an offset to the value of a pointer type. 
<P><B>Static Semantics</B> 
<P>A call of <TT>ADDADR</TT> shall have two actual parameters. The first parameter shall be an expression that is of a pointer type, and the second parameter shall be an expression of a type with which the unsigned type is value parameter compatible. The type of a call of <TT>ADDADR</TT> shall be the address type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>ADDADR(addr,&nbsp;offset)</TT> shall be an address calculated by adding <TT>offset</TT> to <TT>addr</TT> in an implementation-defined manner that satisfies the properties given in <A HREF="#0317" TARGET=body>Properties of the address arithmetic functions</A>. 
<P>An exception shall be raised if <TT>addr</TT> is the nil value. 
<P>An exception may occur and may be raised if the <TT>ADDADR</TT> function increments an address out of address range. 
<P><B>Notes:</B> 
<OL>
 
<LI>An exception may occur, in particular, where the address space is non-contiguous. </LI>
<LI>The subsequent use of a calculated address may raise an exception. </LI>
<LI>Adding <TT>N</TT> to a pointer which points to a type whose size is greater than one <TT>LOC</TT> will not add <TT>N*TSIZE(typePointedTo)</TT>, but will add <TT>N</TT>. </LI>
</OL>

<P><HR>
<A NAME="0315">
<A HREF="#0313" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0314" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0316" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function SUBADR</H4>

<P>The function <TT>SUBADR</TT> can be used to construct a value of the address type by subtracting an offset from the value of a pointer type. 
<P><B>Static Semantics</B> 
<P>A call of <TT>SUBADR</TT> shall have two actual parameters. The first parameter shall be an expression that is of a pointer type, and the second parameter shall be an expression of a type with which the unsigned type is value parameter compatible. The type of a call of <TT>SUBADR</TT> shall be the address type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>SUBADR(addr,&nbsp;offset)</TT> shall be an address calculated by subtracting <TT>offset</TT> from <TT>addr</TT> in an implementation-defined manner that satisfies the properties given in <A HREF="#0317" TARGET=body>Properties of the address arithmetic functions</A>. 
<P>An exception shall be raised if <TT>addr</TT> is the nil value. 
<P>An exception may occur and may be raised if the <TT>SUBADR</TT> function decrements an address out of address range. 
<P><B>Notes:</B> 
<OL>
 
<LI>An exception may occur, in particular, where the address space is non-contiguous. </LI>
<LI>The subsequent use of a calculated address may raise an exception. </LI>
<LI>Subtracting <TT>N</TT> from a pointer which points to a type whose size is greater than one <TT>LOC</TT> will not subtract <TT>N*TSIZE(typePointedTo)</TT>, but will subtract <TT>N</TT>. </LI>
</OL>

<P><HR>
<A NAME="0316">
<A HREF="#0313" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0315" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0317" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function DIFADR</H4>

<P>The function <TT>DIFADR</TT> can be used to calculate the offset between two addresses, by subtracting the second address from the first. 
<P><B>Static Semantics</B> 
<P>A call of <TT>DIFADR</TT> shall have two actual parameters. Both parameters shall be expressions of a pointer type. The type of a call of <TT>DIFADR</TT> shall be the signed type. 
<P><B>Note:</B> The two parameters need not be expressions of the same pointer type, since the address type is compatible with all pointer types. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>DIFADR(addr1,&nbsp;addr2)</TT> shall be a signed number calculated by subtracting <TT>addr2</TT> from <TT>addr1</TT> in an implementation-defined manner that satisfies the properties given in <A HREF="#0317" TARGET=body>Properties of the address arithmetic functions</A>. 
<P>An exception shall occur if <TT>addr1</TT> is the nil value or if <TT>addr2</TT> is the nil value. 
<P>An exception may occur and may be raised if the result of the <TT>DIFADR</TT> function is out of the range of the signed type, or if the result is meaningless because the address space is non-contiguous. 
<P><HR>
<A NAME="0317">
<A HREF="#0313" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0316" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0318" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Properties of the address arithmetic functions</H4>

<P>Given the declarations <TT>VAR&nbsp;adr:&nbsp;ADDRESS;&nbsp;n:&nbsp;CARDINAL;</TT> the following shall be true of the address arithmetic func- tion procedures if an exception is not raised: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;SUBADR(ADDADR(adr,n),&nbsp;n)&nbsp;=&nbsp;adr
&nbsp;&nbsp;&nbsp;&nbsp;ADDADR(SUBADR(adr,n),&nbsp;n)&nbsp;=&nbsp;adr
&nbsp;&nbsp;&nbsp;&nbsp;DIFADR(ADDADR(adr,n),&nbsp;adr)&nbsp;=&nbsp;n
&nbsp;&nbsp;&nbsp;&nbsp;DIFADR(adr,&nbsp;SUBADR(adr,n))&nbsp;=&nbsp;n
&nbsp;&nbsp;&nbsp;&nbsp;ADDADR(adr,&nbsp;0)&nbsp;=&nbsp;adr
</PRE>

<P><HR>
<A NAME="0318">
<A HREF="#0306" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0317" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0319" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Address Construction and Enquiry Functions</H3>

<P>The function procedures <TT>MAKEADR</TT> and <TT>ADR</TT> are provided for the construction and determination of address values. 
<P><UL>
<LI><A HREF="#0319" TARGET=body>The Function MAKEADR</A>
<LI><A HREF="#0320" TARGET=body>The Function ADR</A>
</UL>
<P><HR>
<A NAME="0319">
<A HREF="#0318" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0318" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0320" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function MAKEADR</H4>

<P>The function <TT>MAKEADR</TT> can be used to construct a value of the address type from one or more values of implementation- defined types. The actual number and types of the parameters are not defined in this International Standard in order that implementations may offer one or more alternatives appropriate to the target architecture. On some implementations, one of the parameters might be used to distinguish between the generation of logical addresses and the generation of hardware addresses, such as apply to memory-mapped I/O. 
<P>A value constructed by <TT>MAKEADR</TT> from constant parameters can be used in the optional expression that follows the identifier in a variable declaration to fix the address of storage used for that variable &mdash; see <A HREF="isom2003.html#0055" TARGET=body>Variable Declarations</A>. 
<P><B>Static Semantics</B> 
<P>A call of <TT>MAKEADR</TT> shall have an implementation-defined number of actual parameters of implementation-defined types. The type of a call of <TT>MAKEADR</TT> shall be the address type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>MAKEADR(val1,&nbsp;...&nbsp;valN)</TT> shall be an implementation-defined conversion of <TT>val1,&nbsp;...&nbsp;valN</TT>. An exception may occur and may be raised if the result is not in address range. 
<P><B>Note:</B> The subsequent use of an address constructed in this way may raise an exception. 
<P><HR>
<A NAME="0320">
<A HREF="#0318" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0319" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0321" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function ADR</H4>

<P>The function <TT>ADR</TT> can be used to obtain the address of a variable. 
<P><B>Static Semantics</B> 
<P>A call of <TT>ADR</TT> shall have one actual parameter that shall be a variable designator. The type of a call of <TT>ADR</TT> shall be the address type. 
<P>Dynamic Semantics 
<P>The value of the call <TT>ADR(v)</TT> shall be the address of the variable <TT>v</TT> such that if 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;TYPE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Val&nbsp;=&nbsp;...&nbsp;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PtoVal&nbsp;=&nbsp;POINTER&nbsp;TO&nbsp;Val;
&nbsp;&nbsp;&nbsp;&nbsp;VAR
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;:&nbsp;Val;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;:&nbsp;PtoVal;
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;:=&nbsp;ADR(v)
</PRE>

<P>then <TT>p^</TT> and <TT>v</TT> shall designate the same variable. 
<P><HR>
<A NAME="0321">
<A HREF="#0306" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0320" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0322" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Packedset Functions</H3>

<P>The functions <TT>ROTATE</TT> and <TT>SHIFT</TT> augment the facilities provided by packedset infix operations and packedset relational operations for the bit-level manipulation of values of packedset types. 
<P><UL>
<LI><A HREF="#0322" TARGET=body>Packedset mapping</A>
<LI><A HREF="#0323" TARGET=body>The Function ROTATE</A>
<LI><A HREF="#0324" TARGET=body>The Function SHIFT</A>
</UL>
<P><HR>
<A NAME="0322">
<A HREF="#0321" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0321" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0323" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Packedset mapping</H4>

<P>Values of a packedset type shall be considered as sequences of bits, numbered according to the ordinal values of the members of the the host type of the base type of the packedset. Bit number <I>n</I> is set (i.e. has the value 1) if <I>n</I> is an element of the packedset, and bit number n is unset or clear (has the value 0) if <I>n</I> is not an element of the packedset. 
<P>The bit-numbering shall be such that bit number 0 is the least significant bit in a machine register. Bit number 1 is the next least significant bit <I>etc</I>. Adjacent bit numbers shall be adjacent bits in the machine register. 
<P>The ordinal values of the lower and upper bounds of the interval used to define a packedset define a bit field within which bit-level operations are to be applied. An implementation may restrict the lower and upper bounds of the interval used to define a packedset &mdash; see ???. 
<P>In shift and rotate operations on bit sequences, a move &lsquo;up&rsquo; by a number of bit positions will move the bit values within the bit field in the direction of increasing bit numbers; this is also described as a &lsquo;left&rsquo; move since bit positions of increasing significance are often shown as being laid out from right to left. Similarly, a move &lsquo;down&rsquo;, or &lsquo;right&rsquo;, will move the bit values within the bit field in the direction of decreasing bit numbers. In the case of shift operations, 0 bit values replace those moved away from a boundary of a bit field; in the case of rotate operations, bit values moved out of the bit field at one boundary are moved into the bit field at the other boundary. 
<P><B>Notes:</B> 
<OL>
 
<LI>For example, the lower bound may be restricted to 0 and the upper bound to a value that is a multiple of <TT>BITSPERLOC</TT>. </LI>
<LI>The restriction on the upper and lower bounds of the defining interval might apply to packedsets passed as parameters to <TT>SHIFT</TT> and <TT>ROTATE</TT> if such manipulation of only part of a machine word might be impossible. </LI>
<LI>Set operations applied to packedsets are equivalent to the following bit-level operations within bit fields: <TT>+</TT> 	union 			 bitwise inclusive-or operation on two bit sequences <TT>-</TT> 	set difference 		 the bits of the first sequence that are not in the second <TT>*</TT> 	intersection 		 bitwise and operation on two bit sequences <TT>/</TT> 	symmetric set difference bitwise exclusive-or operation on two bit sequences <TT>INCL(s,x)</TT> 			 set bit x (to 1) <TT>EXCL(s,x)</TT> 			 clear bit x (to 0) <TT>=</TT> 	equality 		 are the two bit sequences equal? <TT>&lt;&gt;</TT> 	inequality 		 are the two bit sequences different? <TT>&lt;=</TT> 	subset 			 is the first bit sequence included in the second? <TT>&gt;=</TT> 	superset 		 does the first bit sequence include the second? <TT>x&nbsp;IN&nbsp;s</TT>	membership 		 is bit number x set to 1? </LI>
<LI>It is intended that packed sets be mapped on to machine register bits in such a way that in an implementation having a binary representation for <TT>CARDINAL</TT> and where, in addition, <TT>TSIZE(CARDINAL)=TSIZE(BITSET)</TT>, then the following would be true. 
<P><TT>CAST(CARDINAL,BITSET{0})&nbsp;=&nbsp;VAL(CARDINAL,1)</TT> 
<P>and if <TT>v</TT> is a variable of type <TT>CARDINAL</TT>, then 
<P><TT>CAST(CARDINAL,SHIFT(CAST(BITSET,v),-1))&nbsp;=&nbsp;v&nbsp;DIV&nbsp;2</TT> 
<P>and provided <TT>v&nbsp;&lt;&nbsp;=&nbsp;MAX(CARDINAL)&nbsp;DIV&nbsp;2</TT>, then 
<P><TT>CAST(CARDINAL,SHIFT(CAST(BITSET,v),1))&nbsp;=&nbsp;v&nbsp;*&nbsp;2</TT> </LI>
</OL>

<P><HR>
<A NAME="0323">
<A HREF="#0321" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0322" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0324" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function ROTATE</H4>

<P>The function <TT>ROTATE</TT> can be used to rotate a bit sequence up or down (left or right) by a specified number of positions within a bit field. The bit sequence is defined by the value of a packedset type, and the direction of rotation is down (right) if the specified number is negative; otherwise the direction is up (left). 
<P><B>Static Semantics</B> 
<P>A call of <TT>ROTATE</TT> shall have two actual parameters. The first parameter shall be an expression that is of a packedset type. The second parameter shall be an expression of a type with which the signed type is value parameter compatible. 
<P>The type of a call of <TT>ROTATE</TT> shall be the type of the first parameter. 
<P>An implementation may impose restrictions on the types that are allowed as the first parameter, save that ROTATE will at least accept a value of the type <TT>BITSET</TT> &mdash; see ??? and <A HREF="isom2003.html#0206" TARGET=body>The Bitset Type</A>. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>ROTATE(val,&nbsp;num)</TT> shall be a packedset whose elements are such that the offset of their ordinal values from the ordinal value of the minimum value of the base type of the packedset, is given by the offset of the ordinal values of the elements of <TT>val</TT> increased by <TT>num</TT> if it is positive, or decreased by the absolute value of <TT>num</TT> if it is negative, and scaled by the number of values in the base type. 
<P><B>Note:</B> With the interpretation of a value of a packedset type as a sequence of bits, the rotate operation can be considered as a rotation of the bits upwards (leftwards), or a rotation of the bits downwards (rightwards), according to the value of the second operand, and within the bit field defined by the base type of the packedset. 
<P><HR>
<A NAME="0324">
<A HREF="#0321" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0323" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0325" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function SHIFT</H4>

<P>The function <TT>SHIFT</TT> can be used to shift a bit sequence up or down (left or right) by a specified number of positions within a bit field. The bit sequence is defined by the value of a packedset type, and the direction of shift is down (right) if the specified number is negative; otherwise the direction is up (left). 
<P><B>Static Semantics</B> 
<P>A call of <TT>SHIFT</TT> shall have two actual parameters. The first parameter shall be an expression that is of a packedset type. The second parameter shall be an expression of a type with which the signed type is value parameter compatible. 
<P>The type of a call of <TT>SHIFT</TT> shall be the type of the first parameter. 
<P>An implementation may impose restrictions on the types that are allowed as the first parameter, save that <TT>SHIFT</TT> will at least accept a value of the type <TT>BITSET</TT> &mdash; see ??? and <A HREF="isom2003.html#0206" TARGET=body>The Bitset Type</A>. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>SHIFT(val,&nbsp;num)</TT> shall be a packedset whose elements are such that the offset of their ordinal values from the ordinal value of the minimum value of the base type of the packedset, is given by the offset of the ordinal values of the elements of <TT>val</TT> increased by <TT>num</TT> if it is positive, or decreased by the absolute value of <TT>num</TT> if it is negative, provided that offset is not negative and is less than the number of values of the base type. 
<P><B>Note:</B> With the interpretation of a value of type packedset as a sequence of bits, the shift operation can be considered as a zero-propagating logical-shift-up (left) operation or a logical-shift-down (right) operation, according to the value of the second operand, and within the bit field defined by the base type of the packedset. 
<P><HR>
<A NAME="0325">
<A HREF="#0306" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0324" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0326" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Function CAST</H3>

<P>The function <TT>CAST</TT> can be used (as a type transfer function) to interpret a value of any type other than a numeric literal value as a value of another type. 
<P><B>Change:</B> In <I>Programming in Modula-2</I> , type transfer is effected by using a type identifier in the role of a function name, as exemplified by <TT>CARDINAL(IntExpr)</TT>. 
<P><B>Static Semantics</B> 
<P>A call of <TT>CAST</TT> shall have two actual parameters. The first parameter shall be a qualified identifier that denotes a type. The second shall be an expression whose type is not that of a numeric literal. 
<P><B>Note:</B> The type of the expression that is the second parameter cannot be a numeric literal type, since such types do not have a defined storage size. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>CAST(Type,&nbsp;val)</TT> shall be given by a possibly unchecked conversion of <TT>val</TT> to the type <TT>Type</TT> in an implementation-defined manner satisfying the properties given below. 
<P>If the number of storage units that <TT>val</TT> occupies is the same as the number of storage units used by a variable of the type <TT>Type</TT>, the bit pattern representation of the result shall be the same as the bit pattern representation of <TT>val</TT>; otherwise the result and the value of <TT>val</TT> shall have the same bit pattern representation for a size that is equal to the smaller of the number of storage units. 
<P>An exception may occur and may be raised if a call of <TT>CAST</TT> causes an implementation-dependent alignment problem to occur, or if the resulting bit pattern is not a valid representation for a value of the target type. 
<P>properties 
<P>Let <TT>ARRAY&nbsp;[0&nbsp;..&nbsp;t]&nbsp;OF&nbsp;LOC</TT> correspond to <TT>Type</TT> where <TT>t&nbsp;=&nbsp;TSIZE(Type)&nbsp;-&nbsp;1</TT> 
<P>Let <TT>ARRAY&nbsp;[0&nbsp;..&nbsp;v]&nbsp;OF&nbsp;LOC</TT> correspond to <TT>val</TT> where <TT>v&nbsp;=&nbsp;TSIZE(type&nbsp;of&nbsp;SourceExpression)&nbsp;-&nbsp;1</TT> 
<P>The value of the call <TT>CAST(Type,&nbsp;val)</TT> shall be a value of type <TT>Type</TT> that when interpreted as an <TT>ARRAY&nbsp;[0&nbsp;..&nbsp;t]&nbsp;OF&nbsp;LOC</TT> has, for its first <TT>min</TT> elements, values that are the same as the first <TT>min</TT> elements of the value of <TT>val</TT> when interpreted as an <TT>ARRAY&nbsp;[0&nbsp;..&nbsp;v]&nbsp;OF&nbsp;LOC</TT>, where <TT>min</TT> is the minimum of <TT>t</TT> and <TT>v</TT>. 
<P><B>Note:</B> If <TT>t&nbsp;&gt;&nbsp;v</TT>, the values of remaining elements of the array from <TT>v+1</TT> to <TT>t</TT> are not defined. 
<P>If a call of <TT>CAST</TT> causes an implementation-dependent alignment problem to occur, the following may result: <I>non-mandatory-detection</I> (invalid-alignment) <I>handler</I> 
<P>If the resulting bit pattern is not a valid representation for a value of the target type, the following may result: <I>non-mandatory-detection</I> (invalid-value) <I>handler</I> 
<P><HR>
<A NAME="0326">
<A HREF="#0306" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0325" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0327" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Function TSIZE</H3>

<P>The function <TT>TSIZE</TT> can be used to ascertain the amount of storage that is used for a variable of a particular type. There are two versions of this function. The first has a type identifier as a parameter. It returns the size occupied by values of the type in terms of the smallest addressable unit of storage. This version is closely equivalent to the standard function <TT>SIZE</TT> &mdash; see <A HREF="isom2003.html#0234" TARGET=body>The Function SIZE</A>. The second version has a record type identifier as the first parameter and one or more constant expressions as the remaining parameters; the values of these constant expressions must be associated with tags of variant components of that record type. It returns the size of the variant record in terms of the smallest addressable unit of storage that would be needed to store a value of the record type, with the tag fields having the values supplied in the call. 
<P><B>Static Semantics</B> 
<P>The first, and possibly only parameter, shall be a qualified identifier denoting a type. 
<P>If the second and subsequent parameters are present, they shall be constant expressions, and the first parameter shall denote a record type with variant fields. The types of the constant expressions shall correspond to the types of the tag fields contained in the record type. 
<P><B>Note:</B> Values may not be given for the tag fields of any record type embedded within the record type specified as the first parameter. 
<P>The type of a call of <TT>TSIZE</TT> shall be the Z-type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>TSIZE(Type)</TT> shall be the size occupied by values of the type <TT>Type</TT> in terms of the smallest addressable unit of storage. 
<P>The value of the call <TT>TSIZE(Type,&nbsp;val&nbsp;...&nbsp;)</TT> shall be the size of the variant record in terms of the smallest addressable unit of storage that would be needed to store values of the record with the tag fields having the values <TT>val&nbsp;...</TT>. 
<P><B>Auxiliaries</B> 
<P>annotations Check that the tag fields contained in a fields-list match the values given by an expression sequence. 
<P>annotations Check that the tag fields contained in a fields match the values given by an expression sequence. 
<P>annotations Check that the type of the expression in the sequence of tag values is assignment-compatible with the type of the corresponding tag component and the expression that corresponds to any tag field is a constant expression. 
<P>annotations Check the tag values in a sequence of values correspond to any tag fields in a variant component. 
<P>annotations Calculate the number of tags in a fields-list. 
<P>annotations Calculate the number of tags in a fields. 
<P>annotations Calculate the number of tags in a variant component of a record structure, selected by the value of the tag field. 
<P>annotations Calculates the number of tags in a variant component of a record structure. 
<P>
<P><HR>
<A NAME="0327">
<A HREF="#0305" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0326" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0328" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>The Module COROUTINES</H2>

<P>The system module <TT>COROUTINES</TT> provides facilities for creating coroutines, for the explicit transfer of control between coroutines, and for the handling of interrupts by coroutine transfer. Programs that use the interrupt handling facilities may be non-portable since the type used to identify sources of interrupts is implementation-defined. 
<P><UL>
<LI><A HREF="#0328" TARGET=body>The Interface to COROUTINES</A>
<LI><A HREF="#0329" TARGET=body>The Types of COROUTINES</A>
<LI><A HREF="#0330" TARGET=body>The Procedures of COROUTINES</A>
<LI><A HREF="#0337" TARGET=body>The Functions of COROUTINES</A>
</UL>
<P><HR>
<A NAME="0328">
<A HREF="#0327" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0327" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0329" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Interface to COROUTINES</H3>

<P>The interface to <TT>COROUTINES</TT> behaves as if the following were its definition module. 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;DEFINITION&nbsp;MODULE&nbsp;COROUTINES;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Facilities&nbsp;for&nbsp;coroutines&nbsp;and&nbsp;the&nbsp;handling&nbsp;of&nbsp;interrupts&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;IMPORT&nbsp;SYSTEM;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;TYPE
&nbsp;&nbsp;&nbsp;&nbsp;COROUTINE;&nbsp;(*&nbsp;Values&nbsp;of&nbsp;this&nbsp;type&nbsp;are&nbsp;created&nbsp;dynamically&nbsp;by&nbsp;NEWCOROUTINE
&nbsp;&nbsp;&nbsp;		&nbsp;&nbsp;and&nbsp;identify&nbsp;the&nbsp;coroutine&nbsp;in&nbsp;subsequent&nbsp;operations&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;INTERRUPTSOURCE&nbsp;=&nbsp;&lt;implementation-defined&gt;;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;NEWCOROUTINE&nbsp;(procBody:&nbsp;PROC;&nbsp;workspace:&nbsp;SYSTEM.ADDRESS;&nbsp;size:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;			&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;cr:&nbsp;COROUTINE[;&nbsp;initProtection:&nbsp;PROTECTION]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Creates&nbsp;a&nbsp;new&nbsp;coroutine&nbsp;whose&nbsp;body&nbsp;is&nbsp;given&nbsp;by&nbsp;procBody,&nbsp;and&nbsp;returns&nbsp;the&nbsp;identity
&nbsp;&nbsp;&nbsp;	&nbsp;of&nbsp;the&nbsp;coroutine&nbsp;in&nbsp;cr.&nbsp;workspace&nbsp;is&nbsp;a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;work&nbsp;space&nbsp;allocated&nbsp;to
&nbsp;&nbsp;&nbsp;	&nbsp;the&nbsp;coroutine;&nbsp;size&nbsp;specifies&nbsp;the&nbsp;size&nbsp;of&nbsp;this&nbsp;workspace&nbsp;in&nbsp;terms&nbsp;of&nbsp;SYSTEM.LOC.
&nbsp;&nbsp;&nbsp;	&nbsp;initProtection&nbsp;is&nbsp;an&nbsp;optional&nbsp;parameter&nbsp;that&nbsp;specifies&nbsp;the&nbsp;initial&nbsp;protection
&nbsp;&nbsp;&nbsp;	&nbsp;level&nbsp;of&nbsp;the&nbsp;coroutine.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;TRANSFER&nbsp;(VAR&nbsp;from:&nbsp;COROUTINE;&nbsp;to:&nbsp;COROUTINE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Returns&nbsp;the&nbsp;identity&nbsp;of&nbsp;the&nbsp;calling&nbsp;coroutine&nbsp;in&nbsp;from,&nbsp;and&nbsp;transfers&nbsp;control&nbsp;to
&nbsp;&nbsp;&nbsp;	&nbsp;the&nbsp;coroutine&nbsp;specified&nbsp;by&nbsp;to.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;IOTRANSFER&nbsp;(VAR&nbsp;from:&nbsp;COROUTINE;&nbsp;to:&nbsp;COROUTINE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Returns&nbsp;the&nbsp;identity&nbsp;of&nbsp;the&nbsp;calling&nbsp;coroutine&nbsp;in&nbsp;from&nbsp;and&nbsp;transfers&nbsp;control&nbsp;to
&nbsp;&nbsp;&nbsp;	&nbsp;the&nbsp;coroutine&nbsp;specified&nbsp;by&nbsp;to.&nbsp;On&nbsp;occurrence&nbsp;of&nbsp;an&nbsp;interrupt,&nbsp;associated&nbsp;with&nbsp;the
&nbsp;&nbsp;&nbsp;	&nbsp;caller,&nbsp;control&nbsp;is&nbsp;transferred&nbsp;back&nbsp;to&nbsp;the&nbsp;caller,&nbsp;and&nbsp;the&nbsp;identity&nbsp;of&nbsp;the
&nbsp;&nbsp;&nbsp;	&nbsp;interrupted&nbsp;coroutine&nbsp;is&nbsp;returned&nbsp;in&nbsp;from.&nbsp;The&nbsp;calling&nbsp;coroutine&nbsp;must&nbsp;be
&nbsp;&nbsp;&nbsp;	&nbsp;associated&nbsp;with&nbsp;a&nbsp;source&nbsp;of&nbsp;interrupts.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;ATTACH&nbsp;(source:&nbsp;INTERRUPTSOURCE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Associates&nbsp;the&nbsp;specified&nbsp;source&nbsp;of&nbsp;interrupts&nbsp;with&nbsp;the&nbsp;calling&nbsp;coroutine.&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;DETACH&nbsp;(source:&nbsp;INTERRUPTSOURCE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Dissociates&nbsp;the&nbsp;specified&nbsp;source&nbsp;of&nbsp;interrupts&nbsp;from&nbsp;the&nbsp;calling&nbsp;coroutine.&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;IsATTACHED&nbsp;(source:&nbsp;INTERRUPTSOURCE):&nbsp;BOOLEAN;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Returns&nbsp;TRUE&nbsp;if&nbsp;and&nbsp;only&nbsp;if&nbsp;the&nbsp;specified&nbsp;source&nbsp;of&nbsp;interrupts&nbsp;is&nbsp;currently
&nbsp;&nbsp;&nbsp;	&nbsp;associated&nbsp;with&nbsp;a&nbsp;coroutine;&nbsp;otherwise&nbsp;returns&nbsp;FALSE.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;HANDLER&nbsp;(source:&nbsp;INTERRUPTSOURCE):&nbsp;COROUTINE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Returns&nbsp;the&nbsp;coroutine,&nbsp;if&nbsp;any,&nbsp;that&nbsp;is&nbsp;associated&nbsp;with&nbsp;the&nbsp;source&nbsp;of&nbsp;interrupts.
&nbsp;&nbsp;&nbsp;	&nbsp;The&nbsp;result&nbsp;is&nbsp;undefined&nbsp;if&nbsp;IsATTACHED(source)&nbsp;=&nbsp;FALSE.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;CURRENT&nbsp;():&nbsp;COROUTINE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Returns&nbsp;the&nbsp;identity&nbsp;of&nbsp;the&nbsp;calling&nbsp;coroutine.&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;LISTEN&nbsp;(p:&nbsp;PROTECTION);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Momentarily&nbsp;changes&nbsp;the&nbsp;protection&nbsp;of&nbsp;the&nbsp;calling&nbsp;coroutine&nbsp;to&nbsp;p.&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;PROT&nbsp;():&nbsp;PROTECTION;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Returns&nbsp;the&nbsp;protection&nbsp;of&nbsp;the&nbsp;calling&nbsp;coroutine.&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;COROUTINES.
</PRE>

<P><B>Declaration Semantics</B> 
<P>The identifiers available for import from the module <TT>COROUTINES</TT> shall be the type identifiers <TT>COROUTINE</TT> and <TT>INTERRUPTSOURCE</TT>, and the procedure identifiers <TT>NEWCOROUTINE</TT>, <TT>TRANSFER</TT>, <TT>IOTRANSFER</TT>, <TT>ATTACH</TT>, <TT>DETACH</TT>, <TT>IsATTACHED</TT>, <TT>HANDLER</TT>, <TT>CURRENT</TT>, <TT>LISTEN</TT>, and <TT>PROT</TT>. 
<P><HR>
<A NAME="0329">
<A HREF="#0327" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0328" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0330" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Types of COROUTINES</H3>

<P>The module <TT>COROUTINES</TT> provides the coroutine type (denoted by <TT>COROUTINE</TT>) in terms of which coroutines are identi- fied, and the implementation-defined interrupt source type (denoted by <TT>INTERRUPTSOURCE</TT>) in terms of which sources of interrupts are identified. 
<P><B>Changes:</B> 
<OL>
 
<LI>The type <TT>PROCESS</TT> is called <TT>COROUTINE</TT> in this International Standard. The change from <TT>PROCESS</TT> to <TT>ADDRESS</TT> which occurred in the third edition of <I>Programming in Modula-2</I> has not been adopted. </LI>
<LI>A particular coroutine is identified by the same value of the coroutine type throughout the lifetime of that coroutine. </LI>
<LI>The interrupt source type denoted by <TT>INTERRUPTSOURCE</TT> is not described in <I>Programming in Modula-2</I>. </LI>
</OL>

<P><B>Declaration Semantics</B> 
<P>The type identifier <TT>COROUTINE</TT> shall denote the coroutine type, and the type identifier <TT>INTERRUPTSOURCE</TT> shall denote the implementation-defined interrupt source type. 
<P>The coroutine type shall be a system basic type, distinct from any other type, whose values identify a coroutine throughout the lifetime of that coroutine. The interrupt source type may be identical to a basic type or may be a predefined constructed type. 
<P><B>Note:</B> In addition to use with the <TT>COROUTINES</TT> procedures <TT>NEWCOROUTINE,&nbsp;TRANSFER,&nbsp;IOTRANSFER</TT>, and <TT>CURRENT</TT>, as a system basic type, the operations of assignment and equality testing are applicable to the coroutine type &mdash; see <A HREF="isom2003.html#0158" TARGET=body>System Basic Types Relational Operations</A>. 
<P>annotations Values of the coroutine type are represented by values of the type <I>Coroutine</I> in the formal model &mdash; see ???. The INTERRUPTSOURCE-type is an implementation-defined type &mdash; see <A HREF="isom2003.html#0287" TARGET=body>Interrupt Handlers</A>. Values of the interrupt source type are represented by values of the type <I>Interrupt-source</I> in the formal model &mdash; see <A HREF="isom2003.html#0287" TARGET=body>Interrupt Handlers</A>. 
<P><HR>
<A NAME="0330">
<A HREF="#0327" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0329" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0331" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Procedures of COROUTINES</H3>

<P>The module <TT>COROUTINES</TT> provides procedures for creating coroutines (<TT>NEWCOROUTINE</TT>), transferring between coroutines (<TT>TRANSFER</TT> and <TT>IOTRANSFER</TT>), for associating and dissociating interrupt sources and coroutines (<TT>ATTACH</TT> and <TT>DETACH</TT>), and for unmasking interrupts momentarily (<TT>LISTEN</TT>). 
<P><UL>
<LI><A HREF="#0331" TARGET=body>The Procedure ATTACH</A>
<LI><A HREF="#0332" TARGET=body>The Procedure DETACH</A>
<LI><A HREF="#0333" TARGET=body>The Procedure IOTRANSFER</A>
<LI><A HREF="#0334" TARGET=body>The Procedure LISTEN</A>
<LI><A HREF="#0335" TARGET=body>The Procedure NEWCOROUTINE</A>
<LI><A HREF="#0336" TARGET=body>The Procedure TRANSFER</A>
</UL>
<P><HR>
<A NAME="0331">
<A HREF="#0330" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0330" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0332" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Procedure ATTACH</H4>

<P>The procedure <TT>ATTACH</TT> can be used to associate a coroutine with an interrupt source. 
<P><B>Static Semantics</B> 
<P>A call of <TT>ATTACH</TT> shall have one actual parameter that shall be an expression that is of the interrupt source type. 
<P><B>Dynamic Semantics</B> 
<P>The call <TT>ATTACH(source)</TT> shall associate the implementation-defined source of interrupts identified by <TT>source</TT> with the calling coroutine. If the source of interrupts is already associated with a coroutine, then that association shall first be broken. 
<P><B>Notes:</B> 
<OL>
 
<LI>More than one source of interrupts may be associated with a single coroutine. </LI>
<LI>If interrupt requests are possible from the attached source, execution of the calling coroutine must first be protected from interrupts &mdash; see <A HREF="isom2003.html#0039" TARGET=body>Protected Modules</A>. The protection of the calling coroutine must continue as long as interrupt requests are possible. </LI>
</OL>

<P><HR>
<A NAME="0332">
<A HREF="#0330" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0331" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0333" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Procedure DETACH</H4>

<P>The procedure <TT>DETACH</TT> can be used to dissociate a coroutine from an interrupt source. 
<P><B>Static Semantics</B> 
<P>A call of <TT>DETACH</TT> shall have one actual parameter that shall be an expression that is of the interrupt source type. 
<P><B>Dynamic Semantics</B> 
<P>If the calling coroutine is associated with the source of interrupts identified by <TT>source</TT>, the call <TT>DETACH(source)</TT> shall dissociate that coroutine from that source. 
<P><B>Note:</B> The call has no effect if the coroutine is not associated with source. 
<P><HR>
<A NAME="0333">
<A HREF="#0330" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0332" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0334" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Procedure IOTRANSFER</H4>

<P>The procedure IOTRANSFER can be used to transfer control from one coroutine to another, pending an interrupt. 
<P>Static Semantics 
<P>A call of <TT>IOTRANSFER</TT> shall have two actual parameters. The first actual parameter shall designate a variable that is of the coroutine type. The second actual parameter shall be an expression that is of the coroutine type. 
<P><B>Change:</B> In <I>Programming in Modula-2</I>, the association with the source of interrupts is made on each call of <TT>IOTRANSFER</TT>. In this International Standard, the association is made beforehand by a call or calls to <TT>ATTACH</TT>. 
<P><B>Dynamic Semantics</B> 
<P>Provided that the calling coroutine is associated with a source of interrupts, the call <TT>IOTRANSFER(from,to)</TT> shall assign the identity of that coroutine to the variable <TT>from</TT>, and shall transfer control to the coroutine identified by <TT>to</TT>. An exception shall be raised if the calling coroutine is not associated with a source of interrupts. 
<P>On the granting of a subsequent interrupt, following a request from one of the sources associated with the calling coroutine, the coroutine that is then executing shall be suspended, the identity of that interrupted coroutine shall be assigned to <TT>from</TT>, and the calling coroutine shall be resumed. 
<P><B>Note:</B> The coroutine that is transferred to by a call of <TT>IOTRANSFER</TT>, or one that is subsequently transferred to, must execute without protection from interrupts in order for an interrupt request to be granted. 
<P>annotations This operation models the interruption of a coroutine following an interrupt request from <I>source</I>. The source will be associated with a coroutine that has called <TT>IOTRANSFER</TT>. The operation is called by the coroutine that is executing when the interrupt request is granted. 
<P><HR>
<A NAME="0334">
<A HREF="#0330" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0333" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0335" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Procedure LISTEN</H4>

<P>The procedure <TT>LISTEN</TT> can be used to alter the protection momentarily (usually lowering it so as to allow interrupt requests to be granted). 
<P><B>Static Semantics</B> 
<P>A call of <TT>LISTEN</TT> shall have one parameter that is an expression that is of the protection type. 
<P><B>Dynamic Semantics</B> 
<P>The call <TT>LISTEN(p)</TT> shall momentarily change the protection of the currently executing coroutine to <TT>p</TT>. 
<P>annotations If an interrupt request is granted, the effect is for a call of <I>interrupt-occurs</I> to be made. 
<P><HR>
<A NAME="0335">
<A HREF="#0330" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0334" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0336" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Procedure NEWCOROUTINE</H4>

<P>The procedure <TT>NEWCOROUTINE</TT> can be used to create a new coroutine. Control can later be passed to this coroutine by calling the procedures <TT>TRANSFER</TT> or <TT>IOTRANSFER</TT>. 
<P><B>Static Semantics</B> 
<P>A call of <TT>NEWCOROUTINE</TT> shall have four or five actual parameters. 
<P>The first actual parameter shall be an expression of a type with which the proc type is value-parameter-compatible. 
<P><B>Note:</B> The value of the expression that is the first actual parameter in a call of <TT>NEWCOROUTINE</TT> must therefore be a parameterless procedure declared at declaration level 0. 
<P>The second actual parameter shall be an expression that is of a pointer type. 
<P>The third actual parameter shall be an expression of a type with which the unsigned type is value parameter compatible. 
<P>The fourth actual parameter shall designate a variable that is of the coroutine type. 
<P>The fifth actual parameter, if present, shall be an expression that is of the protection type. 
<P>CHANGE 1 &mdash; In <I>Programming in Modula-2</I> , no provision is made for the initial protection of a coroutine to be specified in a call of <TT>NEWCOROUTINE</TT>. 
<P><B>Dynamic Semantics</B> 
<P>Provided that the value of <TT>size</TT> is not less than the minimum workspace size, the call 
<P><TT>NEWCOROUTINE(procBody,workspace,size,cr,initProtection)</TT> 
<P>shall create a new coroutine and shall assign a value identifying the created coroutine to the variable <TT>cr</TT>. The initial protection of the coroutine shall be given by <TT>initProtection</TT>. 
<P>Provided that the value of <TT>size</TT> is not less than the minimum workspace size, the alternative call 
<P><TT>NEWCOROUTINE(procBody,workspace,size,cr)</TT> 
<P>shall create a new coroutine and shall assign a value identifying the created coroutine to the variable <TT>cr</TT>. The initial protection of the coroutine shall be given by the current protection of the caller of <TT>NEWCOROUTINE</TT>. 
<P>The created coroutine shall be initialized in such a way that when control is first transferred to that coroutine, the procedure given by the value of <TT>procBody</TT> will be called as the body of that coroutine. The effect shall be for the caller of <TT>procBody</TT> to be in the state of normal execution with no block body as an exception handler. The effect shall also be for the caller of <TT>procBody</TT> to have a protection from interrupts given by the initial protection for the coroutine. 
<P><B>Change:</B> <I>Programming in Modula-2</I> does not deal with the initial protection of a new coroutine. This International Standard defines rules for determining that initial protection. 
<P>If a procedure called as the body of a coroutine attempts to return, an exception shall be raised. 
<P><B>Notes:</B> 
<OL>
 
<LI>If the procedure has local dynamic modules, these are finalized before the exception is raised. </LI>
<LI>Since the effective caller has no exception handler, the raising of this exception is a termination event. </LI>
</OL>

<P><B>Clarification:</B> <I>Programming in Modula-2</I> states that a program terminates when control reaches the end of a proce- dure which is the body of a coroutine. This International Standard requires that an unhandled exception is raised on any attempt to return to the effective caller of the body of a dynamically created coroutine. 
<P>The storage for a variable occupying a number of locations given by the value of <TT>size</TT> and having an address given by the value of <TT>workspace</TT> shall be given to the coroutine as its workspace. The use made of this workspace shall be implementation-dependent. 
<P>The minimum workspace size shall be implementation-defined. An exception shall be raised if the value of <TT>size</TT> is smaller than the minimum workspace size. 
<P><B>Notes:</B> 
<OL>
 
<LI>In addition to coroutines created by <TT>NEWCOROUTINE</TT>, there is an original coroutine, or main coroutine, by which the static modules of the program are initialized. The initial protection of the main coroutine is implementation-defined and the workspace is supplied by the implementation. </LI>
<LI>The creation of a coroutine does not cause a transfer of control. </LI>
<LI>To ensure that no interrupts are allowed on the initial transfer to a coroutine, it is not sufficient for the procedure given as the value of the procBody parameter in a call of <TT>NEWCOROUTINE</TT> to be a protected procedure with a protection of <TT>UNINTERRUPTIBLE</TT>. That protection will only be established when the procedure is called (automatically) in the new coroutine. </LI>
<LI>A call of <TT>NEWCOROUTINE</TT> does not check if the given workspace overlaps with that of other coroutines; provided that a variable remains in existence until the end of program execution, the storage for that variable may be given to a coroutine for use as its workspace. </LI>
<LI>The giving of coroutine workspace allows the possibility of aliasing. By accessing the workspace through the variable whose storage is given in the call of <TT>NEWCOROUTINE</TT> it may be possible for a program to alter the values of coroutine variables or to affect control information such as procedure return addresses. Two consequences that follow are: a) Since the use of coroutine workspace is implementation-dependent, no meaning is given to such a program by this International Standard. b) Depending on the implementation, it may not be possible to perform a static check that a for loop control variable in a coroutine is not threatened in this way. </LI>
<LI>Workspace overflow is checked during coroutine execution. The check may be carried out when a procedure is activated when storage is allocated for its local variables (see <A HREF="isom2003.html#0292" TARGET=body>Operations to Allocate and Deallocate Storage</A>) </LI>
</OL>

<P><HR>
<A NAME="0336">
<A HREF="#0330" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0335" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0337" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Procedure TRANSFER</H4>

<P>The procedure <TT>TRANSFER</TT> can be used to transfer control from one coroutine to another. 
<P><B>Static Semantics</B> 
<P>A call of <TT>TRANSFER</TT> shall have two actual parameters. The first actual parameter shall designate a variable that is of the coroutine type. The second actual parameter shall be an expression that is of the coroutine type. 
<P><B>Dynamic Semantics</B> 
<P>The call <TT>TRANSFER(from,to)</TT> shall assign the identity of the calling coroutine to the variable <TT>from</TT>, and shall transfer control to the coroutine identified by <TT>to</TT>. 
<P><B>Note:</B> If at the end of its previous execution (if any) the coroutine identified by to had transferred control to another by a call of <TT>IOTRANSFER</TT>, it will appear as if an interrupt has occurred. 
<P><HR>
<A NAME="0337">
<A HREF="#0327" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0336" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0338" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Functions of COROUTINES</H3>

<P>The module <TT>COROUTINES</TT> provides functions for determining the identity of the current coroutine (<TT>CURRENT</TT>), the protection of the current coroutine (<TT>PROT</TT>), and for determining whether and which interrupt sources are associated with coroutines (<TT>HANDLER</TT> and <TT>IsATTACHED</TT>). 
<P><UL>
<LI><A HREF="#0338" TARGET=body>The Function HANDLER</A>
<LI><A HREF="#0339" TARGET=body>The Function IsATTACHED</A>
<LI><A HREF="#0340" TARGET=body>The Function CURRENT</A>
<LI><A HREF="#0341" TARGET=body>The Function PROT</A>
</UL>
<P><HR>
<A NAME="0338">
<A HREF="#0337" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0337" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0339" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function HANDLER</H4>

<P>The function <TT>HANDLER</TT> can be used to identify which coroutine is attached to a specified interrupt source. 
<P><B>Static Semantics</B> 
<P>A call of <TT>HANDLER</TT> shall have one actual parameter that is an expression that is of the interrupt source type. The type of a call of <TT>HANDLER</TT> shall be the coroutine type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>HANDLER(source)</TT> shall be the identity of the coroutine, if any, that is associated with the source of interrupts given by <TT>source</TT>. An exception shall occur and may be raised if that source is not currently associated with any coroutine. 
<P><HR>
<A NAME="0339">
<A HREF="#0337" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0338" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0340" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function IsATTACHED</H4>

<P>The function <TT>IsATTACHED</TT> can be used to determine whether a coroutine is attached to a specified interrupt source. 
<P><B>Static Semantics</B> 
<P>A call of <TT>IsATTACHED</TT> shall have one actual parameter that is an expression that is of the interrupt source type. The type of a call of <TT>IsATTACHED</TT> shall be the coroutine type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>IsATTACHED(source)</TT> shall be <I>true</I> if any coroutine is associated with the source of interrupts denoted by <TT>source</TT>, and <I>false</I> otherwise. 
<P><HR>
<A NAME="0340">
<A HREF="#0337" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0339" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0341" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function CURRENT</H4>

<P>The function <TT>CURRENT</TT> can be used to determine the identity of the currently executing coroutine. 
<P><B>Static Semantics</B> 
<P>A call of <TT>CURRENT</TT> shall have no actual parameters. The type of a call of <TT>CURRENT</TT> shall be the coroutine type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>CURRENT()</TT> shall be the identity of the calling coroutine. 
<P><HR>
<A NAME="0341">
<A HREF="#0337" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0340" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0342" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function PROT</H4>

<P>The function <TT>PROT</TT> can be used to obtain the protection of the currently executing coroutine, that is, the extent to which interrupts are currently masked. 
<P><B>Static Semantics</B> 
<P>A call of <TT>PROT</TT> shall have no actual parameters. The type of a call of <TT>PROT</TT> shall be the protection type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>PROT()</TT> shall be the value of the current protection against interrupts. 
<P>
<P><HR>
<A NAME="0342">
<A HREF="#0305" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0341" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0343" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>The Module EXCEPTIONS</H2>

<P>The system module <TT>EXCEPTIONS</TT> provides low-level facilities for identifying the source of user-defined exceptions, for reporting their occurrence, and for making enquiries concerning the execution state of the current coroutine. 
<P>User-defined exceptions are identified uniquely by an exception source/number pair. When the source of a user-defined exception is a separate module, that module may encapsulate the exception source value, thus preventing the defined exceptions of the module from being raised directly by other sources. The exception number may also be mapped to values of an enumeration type defined by the module. An example of the use of these facilities is given in <A HREF="#0353" TARGET=body>The Use of EXCEPTIONS</A>. 
<P><UL>
<LI><A HREF="#0343" TARGET=body>The Interface to EXCEPTIONS</A>
<LI><A HREF="#0344" TARGET=body>The Types of EXCEPTIONS</A>
<LI><A HREF="#0345" TARGET=body>The Procedures of EXCEPTIONS</A>
<LI><A HREF="#0349" TARGET=body>The Functions of EXCEPTIONS</A>
</UL>
<P><HR>
<A NAME="0343">
<A HREF="#0342" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0342" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0344" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Interface to EXCEPTIONS</H3>

<P>The interface to <TT>EXCEPTIONS</TT> behaves as if the following were its definition module. 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;DEFINITION&nbsp;MODULE&nbsp;EXCEPTIONS;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Provides&nbsp;facilities&nbsp;for&nbsp;raising&nbsp;user&nbsp;exceptions
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;for&nbsp;making&nbsp;enquiries&nbsp;concerning&nbsp;the&nbsp;current&nbsp;execution&nbsp;state.
&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;TYPE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExceptionSource;		&nbsp;(*&nbsp;values&nbsp;of&nbsp;this&nbsp;type&nbsp;are&nbsp;used&nbsp;within&nbsp;library&nbsp;modules&nbsp;to
&nbsp;&nbsp;				&nbsp;&nbsp;&nbsp;&nbsp;identify&nbsp;the&nbsp;source&nbsp;of&nbsp;raised&nbsp;exceptions&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExceptionNumber&nbsp;=&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;AllocateSource&nbsp;(VAR&nbsp;newSource:&nbsp;ExceptionSource);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Allocates&nbsp;a&nbsp;unique&nbsp;value&nbsp;of&nbsp;type&nbsp;ExceptionSource&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;RAISE&nbsp;(source:&nbsp;ExceptionSource;&nbsp;number:&nbsp;ExceptionNumber;&nbsp;message:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Associates&nbsp;the&nbsp;given&nbsp;values&nbsp;of&nbsp;source,&nbsp;number&nbsp;and&nbsp;message&nbsp;with&nbsp;the&nbsp;current&nbsp;context
&nbsp;&nbsp;&nbsp;	&nbsp;and&nbsp;raises&nbsp;an&nbsp;exception.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;CurrentNumber&nbsp;(source:&nbsp;ExceptionSource):&nbsp;ExceptionNumber;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;If&nbsp;the&nbsp;current&nbsp;coroutine&nbsp;is&nbsp;in&nbsp;the&nbsp;exceptional&nbsp;execution&nbsp;state&nbsp;because&nbsp;of&nbsp;the&nbsp;raising
&nbsp;&nbsp;&nbsp;	&nbsp;of&nbsp;an&nbsp;exception&nbsp;from&nbsp;source,&nbsp;returns&nbsp;the&nbsp;corresponding&nbsp;number,&nbsp;and&nbsp;otherwise
&nbsp;&nbsp;&nbsp;	&nbsp;raises&nbsp;an&nbsp;exception.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;GetMessage&nbsp;(VAR&nbsp;text:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;If&nbsp;the&nbsp;current&nbsp;coroutine&nbsp;is&nbsp;in&nbsp;the&nbsp;exceptional&nbsp;execution&nbsp;state,&nbsp;returns&nbsp;the&nbsp;possibly
&nbsp;&nbsp;	&nbsp;&nbsp;truncated&nbsp;string&nbsp;associated&nbsp;with&nbsp;the&nbsp;current&nbsp;context.
&nbsp;&nbsp;&nbsp;	&nbsp;Otherwise,&nbsp;in&nbsp;normal&nbsp;execution&nbsp;state,&nbsp;returns&nbsp;the&nbsp;empty&nbsp;string.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;IsCurrentSource&nbsp;(source:&nbsp;ExceptionSource):&nbsp;BOOLEAN;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;If&nbsp;the&nbsp;current&nbsp;coroutine&nbsp;is&nbsp;in&nbsp;the&nbsp;exceptional&nbsp;execution&nbsp;state&nbsp;because&nbsp;of&nbsp;the&nbsp;raising
&nbsp;&nbsp;&nbsp;	&nbsp;of&nbsp;an&nbsp;exception&nbsp;from&nbsp;source,&nbsp;returns&nbsp;TRUE,&nbsp;and&nbsp;otherwise&nbsp;returns&nbsp;FALSE.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;IsExceptionalExecution&nbsp;():&nbsp;BOOLEAN;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;If&nbsp;the&nbsp;current&nbsp;coroutine&nbsp;is&nbsp;in&nbsp;the&nbsp;exceptional&nbsp;execution&nbsp;state&nbsp;because&nbsp;of&nbsp;the&nbsp;raising
&nbsp;&nbsp;&nbsp;	&nbsp;of&nbsp;an&nbsp;exception,&nbsp;returns&nbsp;TRUE,&nbsp;and&nbsp;otherwise&nbsp;returns&nbsp;FALSE.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;EXCEPTIONS.
</PRE>

<P><B>Declaration Semantics</B> 
<P>The identifiers available for import from the module <TT>EXCEPTIONS</TT> shall be the type identifiers <TT>ExceptionSource</TT> and <TT>ExceptionNumber</TT>, and the procedure identifiers <TT>AllocateSource</TT>, <TT>RAISE</TT>, <TT>CurrentNumber</TT>, <TT>GetMessage</TT>, <TT>IsCurrentSource</TT>, and <TT>IsExceptionalExecution</TT>. 
<P><HR>
<A NAME="0344">
<A HREF="#0342" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0343" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0345" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Types of EXCEPTIONS</H3>

<P>The module <TT>EXCEPTIONS</TT> provides the exception source type (denoted by <TT>ExceptionSource</TT>) in terms of which the sources of user-defined exceptions are identified, and the exception number type (denoted by <TT>ExceptionNumber</TT>) in terms of which exceptions from a particular source are identified. 
<P><B>Declaration Semantics</B> 
<P>The type identifier <TT>ExceptionSource</TT> shall denote the exception source type, and the type identifier <TT>ExceptionNumber</TT> shall denote the whole number type. 
<P><B>Note:</B> In addition to use with the <TT>EXCEPTIONS</TT> procedures <TT>AllocateSource,&nbsp;RAISE,&nbsp;CurrentNumber</TT>, and <TT>IsCurrentSource</TT>, as a system basic type, the operations of assignment and equality testing are applicable to the ex- ception source type &mdash; see <A HREF="isom2003.html#0158" TARGET=body>System Basic Types Relational Operations</A>. 
<P>annotations Values of the exception source type are represented by values of the type <I>Exception-source</I> in the formal model &mdash; see <A HREF="isom2003.html#0286" TARGET=body>Exceptions</A>. 
<P><HR>
<A NAME="0345">
<A HREF="#0342" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0344" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0346" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Procedures of EXCEPTIONS</H3>

<P>The module <TT>EXCEPTIONS</TT> provides procedures for allocating a unique value of the exception source type (<TT>AllocateSource</TT>), raising a user-defined exception (<TT>RAISE</TT>), and obtaining the message associated with the current exception context (<TT>GetMessage</TT>). 
<P><UL>
<LI><A HREF="#0346" TARGET=body>The Procedure AllocateSource</A>
<LI><A HREF="#0347" TARGET=body>The Procedure RAISE</A>
<LI><A HREF="#0348" TARGET=body>The Procedure GetMessage</A>
</UL>
<P><HR>
<A NAME="0346">
<A HREF="#0345" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0345" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0347" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Procedure AllocateSource</H4>

<P>The procedure <TT>AllocateSource</TT> can be used as a server for previously unallocated values of the type <TT>ExceptionSource</TT>. Values of this type are used to identify a source of exceptions, such as a library module, when an exception is raised with the procedure <TT>RAISE</TT>. The procedure is normally called once during initialization of a separate module, and the resulting value is then used in all calls of <TT>RAISE</TT> for exceptions that may be handled by clients of the module. 
<P><B>Static Semantics</B> 
<P>A call of <TT>AllocateSource</TT> shall have one actual parameter which shall be a variable that is of the exception source type. 
<P><B>Dynamic Semantics</B> 
<P>The call <TT>AllocateSource(newSource)</TT> shall allocate a value of the exception source type that is unique within the program and shall assign this value to the variable <TT>newSource</TT>. If a unique value cannot be allocated, an exception shall be raised. 
<P><HR>
<A NAME="0347">
<A HREF="#0345" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0346" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0348" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Procedure RAISE</H4>

<P>The procedure <TT>RAISE</TT> can be used by a specified source to raise a user-defined exception. 
<P>The effect of raising an exception is the same for exceptions raised by the language implementation as for exceptions raised by explicit use of the procedure <TT>RAISE</TT> &mdash; see <A HREF="#0365" TARGET=body>Language Exceptions</A>. Thus the raising of a user-defined exception is a termination event (see <A HREF="isom2003.html#0028" TARGET=body>Program Termination</A>) unless the exception is handled by an exception body (see <A HREF="isom2003.html#0109" TARGET=body>Block Bodies and Exception Handling</A>). 
<P><B>Static Semantics</B> 
<P>A call of <TT>RAISE</TT> shall have three actual parameters. The first actual parameter shall be an expression that is of the exception source type, the second actual parameter shall be an expression of a type with which the unsigned type is value parameter compatible, and the third actual parameter shall be an expression of a type with which an open array of <TT>CHAR</TT> is value parameter compatible. 
<P><B>Dynamic Semantics</B> 
<P>The call of <TT>RAISE(source,&nbsp;number,&nbsp;message)</TT> shall set the current exception source to the value of <TT>source</TT>, the current exception number to the value of <TT>number</TT>, and the current exception message to the value of <TT>message</TT> interpreted as a character string and limited to an implementation-defined length. 
<P><HR>
<A NAME="0348">
<A HREF="#0345" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0347" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0349" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Procedure GetMessage</H4>

<P>The procedure <TT>GetMessage</TT> can be used to obtain the message passed when an exception is raised. This may give further information about the nature of the exception for use by the program, or in the construction of other messages. 
<P><B>Static Semantics</B> 
<P>A call of <TT>GetMessage</TT> shall have one actual parameter which shall be an array variable having components of the character type. 
<P><B>Dynamic Semantics</B> 
<P>The call <TT>GetMessage(text)</TT> shall assign a string value to the variable <TT>text</TT>. If the calling coroutine is in the state of exceptional execution, the string value shall be formed from the message stored when the corresponding exception was raised, but with a length limited by the capacity of <TT>text</TT>. 
<P><HR>
<A NAME="0349">
<A HREF="#0342" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0348" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0350" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Functions of EXCEPTIONS</H3>

<P>The module <TT>EXCEPTIONS</TT> provides functions for determining the exception number for the current user-defined excep- tion (CurrentNumber), whether a user-defined exception has been raised by a given source (<TT>IsCurrentSource</TT>), and whether the execution state is that of exceptional execution (<TT>IsExceptionalExecution</TT>). 
<P><UL>
<LI><A HREF="#0350" TARGET=body>The Function CurrentNumber</A>
<LI><A HREF="#0351" TARGET=body>The Function IsCurrentSource</A>
<LI><A HREF="#0352" TARGET=body>The Function IsExceptionalExecution</A>
<LI><A HREF="#0353" TARGET=body>The Use of EXCEPTIONS</A>
</UL>
<P><HR>
<A NAME="0350">
<A HREF="#0349" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0349" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0351" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function CurrentNumber</H4>

<P>The function <TT>CurrentNumber</TT> can be used to obtain the exception number for the current user-defined exception that has been raised. 
<P><B>Static Semantics</B> 
<P>A call of <TT>CurrentNumber</TT> shall have one actual parameter which shall be an expression of the exception source type. The type of a call of <TT>CurrentNumber</TT> shall be the unsigned type. 
<P><B>Dynamic Semantics</B> 
<P>If the calling coroutine is in the state of exceptional execution because of the raising of a user-defined exception from source, the value of the call <TT>CurrentNumber(source)</TT> shall be the number that is associated with the raised exception; otherwise an exception shall be raised. 
<P><HR>
<A NAME="0351">
<A HREF="#0349" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0350" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0352" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function IsCurrentSource</H4>

<P>The function <TT>IsCurrentSource</TT> can be used to test whether the calling coroutine is in the state of exceptional execution because of the raising of a user-defined exception from a specified source. 
<P><B>Static Semantics</B> 
<P>A call of <TT>IsCurrentSource</TT> shall have one actual parameter which shall be an expression of the exception source type. The type of a call of <TT>IsCurrentSource</TT> shall be the Boolean type. 
<P><B>Dynamic Semantics</B> 
<P>If the calling coroutine is in the state of exceptional execution because of the raising of a user-defined exception from <TT>source</TT>, the value of the call <TT>IsCurrentSource(source)</TT> shall be <I>true</I> ; otherwise the value shall be <I>false</I> . 
<P><HR>
<A NAME="0352">
<A HREF="#0349" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0351" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0353" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function IsExceptionalExecution</H4>

<P>The function <TT>IsExceptionalExecution</TT> can be used to test whether the calling coroutine is in the state of exceptional execution. 
<P><B>Static Semantics</B> 
<P>A call of <TT>IsExceptionalExecution</TT> shall have no actual parameters. The type of a call of <TT>IsExceptionalExecution</TT> shall be the Boolean type. 
<P><B>Dynamic Semantics</B> 
<P>If the calling coroutine is in the state of exceptional execution, the value of the call <TT>IsExceptionalExecution()</TT> shall be <I>true</I> ; otherwise the value shall be <I>false</I> . 
<P><HR>
<A NAME="0353">
<A HREF="#0349" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0352" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0354" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Use of EXCEPTIONS</H4>

<P>The example given below shows the use of <TT>EXCEPTIONS</TT> in the implementation of a separate module that provides facilities to allow a general user-defined exception to be raised and identified. 
<P><B>Example:</B> A general user exception separate module. 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;DEFINITION&nbsp;MODULE&nbsp;GeneralUserExceptions;

&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Provides&nbsp;facilities&nbsp;for&nbsp;general&nbsp;user-defined&nbsp;exceptions&nbsp;*)

&nbsp;&nbsp;&nbsp;&nbsp;TYPE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GeneralExceptions&nbsp;=&nbsp;(problem,&nbsp;disaster);

&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;RaiseGeneralException&nbsp;(exception:&nbsp;GeneralExceptions;&nbsp;text:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Raises&nbsp;exception&nbsp;using&nbsp;text&nbsp;as&nbsp;the&nbsp;associated&nbsp;message&nbsp;*)

&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;IsGeneralException&nbsp;():&nbsp;BOOLEAN;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Returns&nbsp;TRUE&nbsp;if&nbsp;the&nbsp;current&nbsp;coroutine&nbsp;is&nbsp;in&nbsp;the&nbsp;exceptional&nbsp;execution&nbsp;state
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;because&nbsp;of&nbsp;the&nbsp;raising&nbsp;of&nbsp;an&nbsp;exception&nbsp;from&nbsp;GeneralExceptions;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;otherwise&nbsp;returns&nbsp;FALSE.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)

&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;GeneralException():&nbsp;GeneralExceptions;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;If&nbsp;the&nbsp;current&nbsp;coroutine&nbsp;is&nbsp;in&nbsp;the&nbsp;exceptional&nbsp;execution&nbsp;state&nbsp;because&nbsp;of&nbsp;the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raising&nbsp;of&nbsp;an&nbsp;exception&nbsp;from&nbsp;GeneralExceptions,&nbsp;returns&nbsp;the&nbsp;corresponding
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enumeration&nbsp;value,&nbsp;and&nbsp;otherwise&nbsp;raises&nbsp;an&nbsp;exception.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;GeneralUserExceptions.

&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;IMPLEMENTATION&nbsp;MODULE&nbsp;GeneralUserExceptions;

&nbsp;&nbsp;&nbsp;&nbsp;IMPORT&nbsp;EXCEPTIONS;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;VAR
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generalSource:&nbsp;EXCEPTIONS.ExceptionSource;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;RaiseGeneralException&nbsp;(exception:&nbsp;GeneralExceptions;&nbsp;text:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EXCEPTIONS.RAISE(generalSource,&nbsp;ORD(exception),&nbsp;text)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;RaiseGeneralException;

&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;IsGeneralException&nbsp;():&nbsp;BOOLEAN;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RETURN&nbsp;EXCEPTIONS.IsCurrentSource(generalSource)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;IsGeneralException;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;GeneralException():&nbsp;GeneralExceptions;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RETURN&nbsp;VAL(GeneralExceptions,&nbsp;EXCEPTIONS.CurrentNumber(generalSource))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;GeneralException;

&nbsp;&nbsp;&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EXCEPTIONS.AllocateSource(generalSource)
&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;GeneralUserExceptions.
</PRE>

<P>
<P><HR>
<A NAME="0354">
<A HREF="#0305" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0353" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0355" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>The Module TERMINATION</H2>

<P>The system module <TT>TERMINATION</TT> provides facilities for a program to enquire whether a termination event has occurred &mdash; see <A HREF="isom2003.html#0028" TARGET=body>Program Termination</A>. 
<P><UL>
<LI><A HREF="#0355" TARGET=body>The Interface to TERMINATION</A>
<LI><A HREF="#0356" TARGET=body>The Functions of TERMINATION</A>
</UL>
<P><HR>
<A NAME="0355">
<A HREF="#0354" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0354" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0356" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Interface to TERMINATION</H3>

<P>The interface to <TT>TERMINATION</TT> behaves as if the following were its definition module. 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;DEFINITION&nbsp;MODULE&nbsp;TERMINATION;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Provides&nbsp;facilities&nbsp;for&nbsp;enquiries&nbsp;concerning&nbsp;the&nbsp;occurrence&nbsp;of&nbsp;termination&nbsp;events.&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;IsTerminating&nbsp;():&nbsp;BOOLEAN&nbsp;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Returns&nbsp;TRUE&nbsp;if&nbsp;any&nbsp;coroutine&nbsp;has&nbsp;started&nbsp;program&nbsp;termination&nbsp;and&nbsp;FALSE&nbsp;otherwise.&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;HasHalted&nbsp;():&nbsp;BOOLEAN&nbsp;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Returns&nbsp;TRUE&nbsp;if&nbsp;a&nbsp;call&nbsp;to&nbsp;HALT&nbsp;has&nbsp;been&nbsp;made&nbsp;and&nbsp;FALSE&nbsp;otherwise.&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;TERMINATION.
</PRE>

<P><B>Declaration Semantics</B> 
<P>The identifiers available for import from the module <TT>TERMINATION</TT> shall be the procedure identifiers <TT>IsTerminating</TT>, and <TT>HasHalted</TT>. 
<P><HR>
<A NAME="0356">
<A HREF="#0354" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0355" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0357" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Functions of TERMINATION</H3>

<P>The module <TT>TERMINATION</TT> provides the function procedures <TT>IsTerminating</TT> and <TT>HasHalted</TT> for enquiries concerning the occurrence of termination events. 
<P><UL>
<LI><A HREF="#0357" TARGET=body>The Function IsTerminating</A>
<LI><A HREF="#0358" TARGET=body>The Function HasHalted</A>
</UL>
<P><HR>
<A NAME="0357">
<A HREF="#0356" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0356" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0358" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function IsTerminating</H4>

<P>The function <TT>IsTerminating</TT> can be used to determine whether any coroutine has started program termination. 
<P><B>Static Semantics</B> 
<P>A call of <TT>IsTerminating</TT> shall have no parameters. The type of a call of <TT>IsTerminating</TT> shall be the Boolean type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>IsTerminating()</TT> shall be <I>true</I> if any coroutine has started program termination and shall be <I>false</I> otherwise. 
<P><HR>
<A NAME="0358">
<A HREF="#0356" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0357" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0359" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function HasHalted</H4>

<P>The function <TT>HasHalted</TT> can be used to determine whether a call has been made to <TT>HALT</TT>. 
<P><B>Static Semantics</B> 
<P>A call of <TT>HasHalted</TT> shall have no parameters. The type of a call of <TT>HasHalted</TT> shall be the Boolean type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>HasHalted()</TT> shall be true if a call to <TT>HALT</TT> has been made and shall be <I>false</I> otherwise. 
<P>
<P><HR>
<A NAME="0359">
<A HREF="#0305" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0358" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0360" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>The Module M2EXCEPTION</H2>

<P>The system module <TT>M2EXCEPTION</TT> provides facilities for identifying language exceptions that have been raised. 
<P>The language (which includes the system modules) is regarded as one source of exceptions. Similar facilities are defined by library modules that are sources of user-defined exceptions &mdash; see, for example, ???. 
<P><UL>
<LI><A HREF="#0360" TARGET=body>The Interface to M2EXCEPTION</A>
<LI><A HREF="#0361" TARGET=body>The Types of M2EXCEPTION</A>
<LI><A HREF="#0362" TARGET=body>The Functions of M2EXCEPTION</A>
<LI><A HREF="#0365" TARGET=body>Language Exceptions</A>
<LI><A HREF="#0368" TARGET=body>Messages Associated with Language Exceptions</A>
<LI><A HREF="#0369" TARGET=body>Aggregation and Raising of Language Exceptions</A>
</UL>
<P><HR>
<A NAME="0360">
<A HREF="#0359" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0359" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0361" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Interface to M2EXCEPTION</H3>

<P>The interface to <TT>M2EXCEPTION</TT> behaves as if the following were its definition module. 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;DEFINITION&nbsp;MODULE&nbsp;M2EXCEPTION;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Provides&nbsp;facilities&nbsp;for&nbsp;identifying&nbsp;language&nbsp;exceptions&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;TYPE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M2Exceptions&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(indexException,&nbsp;rangeException,&nbsp;caseSelectException,&nbsp;invalidLocation,
&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;functionException,&nbsp;wholeValueException,&nbsp;wholeDivException,&nbsp;realValueException,
&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;realDivException,&nbsp;complexValueException,&nbsp;complexDivException,&nbsp;protException,
&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;sysException,&nbsp;coException,&nbsp;exException
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;M2Exception&nbsp;():&nbsp;M2Exceptions;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;If&nbsp;the&nbsp;current&nbsp;coroutine&nbsp;is&nbsp;in&nbsp;the&nbsp;exceptional&nbsp;execution&nbsp;state&nbsp;because&nbsp;of&nbsp;the&nbsp;raising
&nbsp;&nbsp;&nbsp;	&nbsp;of&nbsp;a&nbsp;language&nbsp;exception,&nbsp;returns&nbsp;the&nbsp;corresponding&nbsp;enumeration&nbsp;value,&nbsp;and&nbsp;otherwise
&nbsp;&nbsp;&nbsp;	&nbsp;raises&nbsp;an&nbsp;exception.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;IsM2Exception&nbsp;():&nbsp;BOOLEAN;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;If&nbsp;the&nbsp;current&nbsp;coroutine&nbsp;is&nbsp;in&nbsp;the&nbsp;exceptional&nbsp;execution&nbsp;state&nbsp;because&nbsp;of&nbsp;the&nbsp;raising
&nbsp;&nbsp;&nbsp;	&nbsp;of&nbsp;a&nbsp;language&nbsp;exception,&nbsp;returns&nbsp;TRUE,&nbsp;and&nbsp;otherwise&nbsp;returns&nbsp;FALSE.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;M2EXCEPTION.
</PRE>

<P><B>Declaration Semantics</B> 
<P>The identifiers available for import from the module <TT>M2EXCEPTION</TT> shall be the enumeration type identifier <TT>M2Exceptions</TT>, the corresponding enumeration value identifiers, and the procedure identifiers <TT>M2Exception</TT> and <TT>IsM2Exception</TT>. 
<P><HR>
<A NAME="0361">
<A HREF="#0359" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0360" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0362" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Types of M2EXCEPTION</H3>

<P>The module <TT>M2EXCEPTION</TT> provides the m2exceptions enumeration type (denoted by <TT>M2Exceptions</TT>) in terms of which the language exceptions are raised. The enumeration values represent aggregations of the exceptions detected by the formal model &mdash; see <A HREF="#0369" TARGET=body>Aggregation and Raising of Language Exceptions</A>. 
<P><B>Declaration Semantics</B> 
<P>The type identifier <TT>M2Exceptions</TT> shall denote the m2exceptions type which shall be an enumeration type correspond- ing to the following enumeration: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;(indexException,	&nbsp;rangeException,	&nbsp;caseSelectException,	&nbsp;invalidLocation,
&nbsp;&nbsp;&nbsp;&nbsp;functionException,	&nbsp;wholeValueException,	&nbsp;wholeDivException,	&nbsp;realValueException,
&nbsp;&nbsp;&nbsp;&nbsp;realDivException,	&nbsp;complexValueException,	&nbsp;complexDivException,	&nbsp;protException,
&nbsp;&nbsp;&nbsp;&nbsp;sysException,	&nbsp;coException,		&nbsp;exException
&nbsp;&nbsp;&nbsp;&nbsp;);
</PRE>

<P>annotations Values of the m2exceptions type are represented by values of the type <I>Exception-value</I> in the formal model &mdash; see <A HREF="isom2003.html#0286" TARGET=body>Exceptions</A>. 
<P><HR>
<A NAME="0362">
<A HREF="#0359" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0361" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0363" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Functions of M2EXCEPTION</H3>

<P>The module <TT>M2EXCEPTION</TT> provides the function procedures <TT>M2Exception</TT> and <TT>IsM2Exception</TT> for enquiries concerning language exceptions. 
<P><UL>
<LI><A HREF="#0363" TARGET=body>The Function M2Exception</A>
<LI><A HREF="#0364" TARGET=body>The Function IsM2Exception</A>
</UL>
<P><HR>
<A NAME="0363">
<A HREF="#0362" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0362" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0364" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function M2Exception</H4>

<P>The function <TT>M2Exception</TT> can be used to determine the language exception that has been raised. 
<P><B>Static Semantics</B> 
<P>A call of <TT>M2Exception</TT> shall have no actual parameters. The type of a call of <TT>M2Exception</TT> shall be the m2exceptions type. 
<P><B>Dynamic Semantics</B> 
<P>If the calling coroutine is in state of exceptional execution because of the raising of a language exeption, the value of the call <TT>M2Exception()</TT> shall be the value of type <TT>M2Exceptions</TT> that is associated with the raised exception; otherwise an exception shall be raised. 
<P><HR>
<A NAME="0364">
<A HREF="#0362" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0363" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0365" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function IsM2Exception</H4>

<P>The function <TT>IsM2Exception</TT> can be used to test whether the calling coroutine is in the state of exceptional execution because of the raising of a language exception. 
<P><B>Static Semantics</B> 
<P>A call of <TT>IsM2Exception</TT> shall have no parameters. The type of a call of <TT>IsM2Exception</TT> shall be the Boolean type. 
<P><B>Dynamic Semantics</B> 
<P>If the calling coroutine is in the state of exceptional execution because of the raising of a language exception, the value of the call <TT>IsM2Exception()</TT> shall be <I>true</I> ; otherwise the value shall be <I>false</I> . 
<P><HR>
<A NAME="0365">
<A HREF="#0359" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0364" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0366" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Language Exceptions</H3>

<P>The exceptions defined by the dynamic semantics of the language, which includes the system modules, are categorized into those which an implementation is required to detect and those which an implementation is not required to detect. Detected exceptions are raised by the implementation and constitute a termination event (see <A HREF="isom2003.html#0028" TARGET=body>Program Termination</A>) unless the exception is handled by an exception body (see <A HREF="isom2003.html#0109" TARGET=body>Block Bodies and Exception Handling</A>). Exceptions that are distinguished in the dynamic semantics are aggregated into a smaller number of identified exceptions for the purposes of exception handling. 
<P>An implementation must define which of the exceptions whose detection is not required are in fact detected in some or all circumstances. It need not define the circumstances in which such exceptions are detected. If such an exception occurs, but is not detected, this International Standard gives no meaning to the program &mdash; see ???. 
<P><UL>
<LI><A HREF="#0366" TARGET=body>Exceptions whose detection is required</A>
<LI><A HREF="#0367" TARGET=body>Exceptions whose detection is not required</A>
</UL>
<P><HR>
<A NAME="0366">
<A HREF="#0365" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0365" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0367" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Exceptions whose detection is required</H4>

<P><B>Dynamic Semantics</B> 
<P>annotations Construct an appropriate message based on the exception and the current state, and construct an exception context in which to raise the exception. 
<P><HR>
<A NAME="0367">
<A HREF="#0365" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0366" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0368" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Exceptions whose detection is not required</H4>

<P><B>Dynamic Semantics</B> 
<P>annotations If the exception is detected by the implementation, construct an appropriate message based on the exception, the environment and the current state, and construct an exception context in which to raise the exception. Otherwise, the behaviour is implementation-dependent. 
<P>annotations The result is <I>true</I> if the exception is actually detected and otherwise <I>false</I> . 
<P><HR>
<A NAME="0368">
<A HREF="#0359" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0367" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0369" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Messages Associated with Language Exceptions</H3>

<P><B>Dynamic Semantics</B> 
<P>The character string associated with each of the exceptions that may be raised as specified in Chapters <A HREF="isom2003.html#0015" TARGET=body>The Language</A> and <A HREF="#0305" TARGET=body>System Modules</A> shall be implementation-defined. 
<P><B>Note:</B> The character string associated with a raised exception may be accessed using the <TT>GetMessage</TT> procedure &mdash; see <A HREF="#0348" TARGET=body>The Procedure GetMessage</A>. 
<P>annotations Using the exception and the current state, construct an appropriate message for a language exception context. 
<P><HR>
<A NAME="0369">
<A HREF="#0359" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0368" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="isom2005.html#0370" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Aggregation and Raising of Language Exceptions</H3>

<P>annotations Build a language exception context from: an enumeration value defined by the mapping <I>exception-value</I> ; and the message. Raise an exception that has the exception context. 
<P>
</BODY>
</HTML>
