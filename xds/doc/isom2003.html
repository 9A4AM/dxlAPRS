<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>The Language</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<P><HR>
<A NAME="0015">
<A HREF="isom2000.html#root" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="isom2002.html#0014" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0016" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H1>The Language</H1>

<P>This section describes the structure and meaning of a Modula-2 program by specifying its components and stating the rules governing their combination. The major components are the compilation modules: program modules, definition modules, and implementation modules. The components of these modules include import and export lists, definitions and declarations of constants, types, variables, procedures and local modules, and statements and expressions which use these entities. 
<P>There are some constants, types, and procedures that are predefined. Those with pervasive identifiers are described in this section. Those that must be accessed using import lists (from system modules) are described in section 7. 
<P>The meaning of an identifier at the point of its use is specified by the environment that applies at that point &mdash; see <A HREF="#0239" TARGET=body>Environments</A>. An environment associates an identifier with an entity and with the properties of that entity. An envi- ronment that applies at a point of use of an identifier is constructed from the environment that applies in a textually enclosing module or procedure, from import lists, and from defining occurrences in definitions and declarations. En- vironments that are constructed to express the well-formedness conditions refer only to properties that are relevant to those conditions, such as the types of variables and parameters. Environments that are constructed to express the meaning of a program refer to properties required for execution, including the storage for variables and the blocks of procedures. If an identifier is not visible in a constructed environment, an environment applies in which only the pervasive identifiers are visible. 
<P>The meaning of a program is described by the effect that its execution has on the external state (which may include the state of data files). The effect of the executable components of a program is described by the changes to an internal program state which includes the values of variables &mdash; see ???. 
<P><UL>
<LI><A HREF="#0016" TARGET=body>Programs, Program Modules, and Separate Modules</A>
<LI><A HREF="#0040" TARGET=body>Definitions and Declarations</A>
<LI><A HREF="#0069" TARGET=body>Data Types</A>
<LI><A HREF="#0098" TARGET=body>Expression and Assignment Compatibility</A>
<LI><A HREF="#0101" TARGET=body>Blocks</A>
<LI><A HREF="#0112" TARGET=body>Statements</A>
<LI><A HREF="#0137" TARGET=body>Variable Designators</A>
<LI><A HREF="#0142" TARGET=body>Expressions</A>
<LI><A HREF="#0181" TARGET=body>Parameter Compatibility and Argument Binding</A>
<LI><A HREF="#0194" TARGET=body>Predefined Types, Standard Procedures and Standard Functions</A>
<LI><A HREF="#0238" TARGET=body>The Environment and Auxiliary Formal Definitions</A>
<LI><A HREF="#0280" TARGET=body>The Storage Model and Auxiliary Formal Definitions</A>
</UL>
<P><HR>
<A NAME="0016">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0015" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0017" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Programs, Program Modules, and Separate Modules</H2>

<P><UL>
<LI><A HREF="#0017" TARGET=body>Programs and Compilation Modules</A>
<LI><A HREF="#0018" TARGET=body>Program Modules</A>
<LI><A HREF="#0019" TARGET=body>Definition Modules</A>
<LI><A HREF="#0020" TARGET=body>Implementation Modules</A>
<LI><A HREF="#0023" TARGET=body>Program Module and Separate Module Consistency</A>
<LI><A HREF="#0027" TARGET=body>Module Initialization Order</A>
<LI><A HREF="#0028" TARGET=body>Program Termination</A>
<LI><A HREF="#0029" TARGET=body>Import Lists</A>
<LI><A HREF="#0035" TARGET=body>Export Lists</A>
<LI><A HREF="#0038" TARGET=body>Implicit Import and Export</A>
<LI><A HREF="#0039" TARGET=body>Protected Modules</A>
</UL>
<P><HR>
<A NAME="0017">
<A HREF="#0016" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0016" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0018" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Programs and Compilation Modules</H3>

<P>The major components of a Modula-2 program are the compilation modules, so-called because they can be treated separately, although not independently, by an implementation. There is, however, no requirement that the treatment of compilation modules involves actual compilation. 
<P>A program module is a compilation module that may use entities exported by separate modules, but does not itself export entities for use by other modules. Separate modules may in turn use entities from other separate modules. The entities that are available for use by clients of a separate module are defined in a compilation module called a definition module. The definition module must exist before the well-formedness of client modules can be checked. This also imposes a constraint on the compilation order | the order in which compilation modules may be elaborated. A corresponding compilation module called an implementation module is needed to complete each separate module before the program can be executed. The actions that are taken on program execution are given in initialization and finalization bodies within the program module and within the implementation modules. 
<P>A Modula-2 program consists of a program module together with the separate modules it uses (and the separate modules they in turn use). 
<P><B>Concrete Syntax</B> 
<P><B>compilation module</B>= <BR>
<A HREF="isom2005.html#0373" TARGET=body>program module</A> | <A HREF="isom2005.html#0374" TARGET=body>definition module</A> | <A HREF="isom2005.html#0376" TARGET=body>implementation module</A> ; 
<P><B>Note:</B> There is no production for a Modula-2 program, or for a separate module, because of the separate treatment of compilation modules. 
<P><B>Static Semantics</B> 
<P>For a particular program there shall be a single program module. For each separate module directly or indirectly imported by the program module, there shall be a single definition module and a single consistent corresponding implementation module &mdash; see <A HREF="#0024" TARGET=body>Definition Module and Implementation Module Consistency</A>. 
<P><B>Note:</B> This International Standard defines the meaning of a program given the implementation modules supplied for the corresponding definition modules. This does not preclude an implementation from allowing prior selection from alternative implementation modules for a given definition module. 
<P>The identifier of the program module shall not be the same as the identifier of any separate module that forms part of the program. 
<P><B>Note:</B> The identifier of a separate module is the module identifier of its definition module and its corresponding imple- mentation module. 
<P>The identifiers of the program module, and the identifiers of the separate modules, shall not be the same as the identifier of one of the system modules. 
<P>The use of separate modules by compilation modules shall be such that there exists at least one complete and valid order for the separate treatment of the compilation modules of the program &mdash; see <A HREF="#0025" TARGET=body>Module Compilation Order</A>. 
<P><B>Note:</B> If there are many possible orders that satisfy the constraints given in <A HREF="#0025" TARGET=body>Module Compilation Order</A>, this International Standard does not define which order is chosen, since the choice has no effect on the meaning of the program. 
<P>The outermost environment for checking well-formedness shall be constructed from the environments defined by the definition modules that form part of the program, together with the environment defined by the system modules. 
<P><B>Notes:</B> 
<OL>
 
<LI>The outermost environment for checking well-formedness may be understood in terms of a procedure within which all declarations are made by export from local modules which correspond to the separate modules and the system modules. The definition modules correspond to qualified export lists in those local modules. </LI>
<LI>The environment defined by the system modules contains the identifiers associated with the constants, types, and procedures available by import from the system modules &mdash; see Chapter <A HREF="isom2004.html#0305" TARGET=body>System Modules</A>. </LI>
</OL>

<P>annotations The correspondence of definition and implementation modules and the correctness of each of the compilation modules are checked with respect to the definitions of the definition modules and the system modules. 
<P><B>Dynamic Semantics</B> 
<P>The program state shall be initialized from the external state as it exists before execution of the program. The initial protection from interrupts shall be implementation-defined. 
<P><B>Notes:</B> 
<OL>
 
<LI>No variables are defined in this initial program state, and none exist upon completion of the program. </LI>
<LI>The external state includes the storage locations that a Modula-2 program can have access to via an address that is calculated from the machine address component of a variable declaration &mdash; see <A HREF="#0291" TARGET=body>Aliasing Machine Addresses</A>. </LI>
</OL>

<P>The outermost environment for program execution shall be constructed from the environments defined by the separate modules that form part of the program, together with the environment defined by the system modules. 
<P><B>Notes:</B> 
<OL>
 
<LI>The outermost environment for program execution may be understood in terms of a procedure within which the program module, separate modules, and system modules are local modules. The definition modules correspond to qualified export lists in those local modules. </LI>
<LI>The environment defined by the system modules contains the identifiers associated with the constants, types, and procedures available by import from the system modules &mdash; see Chapter <A HREF="isom2004.html#0305" TARGET=body>System Modules</A>. </LI>
</OL>

<P>The program shall be executed by first initializing the separate modules, in the order defined by their occurrence in the import lists, and then initializing the program module &mdash; see <A HREF="#0027" TARGET=body>Module Initialization Order</A>, <A HREF="#0020" TARGET=body>Implementation Modules</A>, and <A HREF="#0018" TARGET=body>Program Modules</A>. 
<P><B>Note:</B> In a program with coroutines, this execution is performed by the main coroutine. 
<P>If an exception is raised during initialization, and this exception is not handled, the program shall be terminated exceptionally. 
<P>On program termination, the program module and the implementation modules shall be finalized in the reverse order of their initialization &mdash; see <A HREF="#0028" TARGET=body>Program Termination</A>. 
<P>annotations stop, cenv , and initial-state are supplied as explicit arguments in the application of execute-program as a function. Corresponding arguments to these are implied in calls of operations. 
<P><B>Auxiliaries</B> 
<P>annotations The definition modules of the program are taken to construct an environment corresponding to the definitions of the definition modules and the system modules. 
<P>annotations The set of valid orders of compilation is produced and one of these orders is chosen arbitrarily. The operation is modelling the link-edit process in constructing the outer environment for execution and allocating storage. 
<P>annotations The declarations of each module are elaborated in order. The order is such that all the definitions of all modules used by a client module have been added to the environment before that client module is processed. Elaboration of the declarations allocates storage and builds an environment, and the resulting outer environment for the execution of the program is constructed. 
<P>annotations The implementation modules are initialized in the execution order defined by the imports. 
<P><HR>
<A NAME="0018">
<A HREF="#0016" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0017" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0019" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Program Modules</H3>

<P>A program module consists of a sequence of import lists followed by a module block, which comprises a sequence of declarations and an optional module body. Both of these sequences may be empty. The declarations may include the declaration of local modules. 
<P>The program module block is executed after the initialization of all implementation modules of the program. 
<P>A program module may have an interrupt protection specified in its heading. The statements and procedures of the module are executed under a protection from interrupts as specified by the protection expression &mdash; see <A HREF="#0039" TARGET=body>Protected Modules</A>. 
<P><B>Concrete Syntax</B> 
<P><B>program module</B>= <BR>
&quot;MODULE&quot;, <A HREF="isom2005.html#0373" TARGET=body>module identifier</A>, [ <A HREF="isom2005.html#0379" TARGET=body>interrupt protection</A> ], &quot;;&quot;, <BR>
<A HREF="isom2005.html#0377" TARGET=body>import lists</A>, <BR>
<A HREF="isom2005.html#0413" TARGET=body>module block</A>, <A HREF="isom2005.html#0373" TARGET=body>module identifier</A>, &quot;.&quot; ; 
<P><B>module identifier</B>= identifier ; 
<P>The two module identifier components of a program module shall be identical. 
<P><B>Static Semantics</B> 
<P>The program module shall not import itself. If present, the import lists of the program module shall be valid given the outermost environment &mdash; see <A HREF="#0029" TARGET=body>Import Lists</A>. If present, the import lists and the declarations of the program module block shall be consistent with one another &mdash; see <A HREF="#0034" TARGET=body>Import Consistency in Module Blocks</A>. 
<P>Given the identifiers of the system modules and the separate modules that are imported into the program module, and given the identifiers that are imported from those modules: 
<UL>
 
<LI>the declarations of the module block of the program module shall be well-formed &mdash; see <A HREF="#0051" TARGET=body>Declarations</A>, </LI>
<LI>the bodies of module and procedure declarations of the module block shall be well-formed &mdash; see <A HREF="#0052" TARGET=body>Ordering of Procedure and Module Declarations</A>, </LI>
<LI>if present, the body of the module block shall be a well-formed module body &mdash; see <A HREF="#0104" TARGET=body>Module Blocks</A>. </LI>
</UL>

<P>If present in the program module heading, the interrupt protection shall be a valid interrupt protection in the context of the pervasive identifier environment only &mdash; see <A HREF="#0039" TARGET=body>Protected Modules</A>. 
<P><B>Dynamic Semantics</B> 
<P>The elaboration of the program module shall elaborate the declarations of the module block, given the meaning of the imported identifiers. 
<P>If the program module is a protected module, the protection specified for the module shall be used to protect the protection domain of the program module. The protection shall be evaluated in the context of the pervasive identifier environment only. 
<P>annotations The compilation order is such that, when this operation is called, the result of elaboration of all definition modules used by the definition module have been merged in the given environment. The protection expression (if present) is evaluated in an environment consisting of the pervasive identifiers only, and is added to the returned environment for use by the protection mechanism. 
<P>The program module shall be initialized by initializing the program module block given the environment resulting from the elaboration of the program module &mdash; see <A HREF="#0105" TARGET=body>Static Module Initialization</A>. 
<P>annotations The environment for initializing the module block of the program module is retrieved from the given environment. 
<P><HR>
<A NAME="0019">
<A HREF="#0016" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0018" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0020" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Definition Modules</H3>

<P>A definition module consists of a sequence of import import lists and a sequence of definitions only. Both of these sequences may be empty. The identifiers introduced by the definitions denote entities that are to be available for use in other modules by import from the corresponding separate module &mdash; see <A HREF="#0043" TARGET=body>Definitions</A>. 
<P>In the case of procedure definitions, only the procedure headings are shown. This is sufficient to allow calls of these procedures in other modules to be checked for consistency, and for those modules to be prepared for execution. 
<P>In the case of type definitions, a complete declaration may be given, or the definition may specify only the type identifier, resulting in what is called an opaque type. If the type identifier is defined as the identifier of an enumeration type, the enumeration constant identifiers are also available for import from the corresponding separate module. 
<P><B>Clarification:</B> This International Standard adopts the position taken in later editions of <I>Programming in Modula-2</I> of not allowing export lists in definition modules. 
<P><B>Concrete Syntax</B> 
<P><B>definition module</B>= <BR>
&quot;DEFINITION&quot;, &quot;MODULE&quot;, <A HREF="isom2005.html#0373" TARGET=body>module identifier</A>, &quot;;&quot;, <BR>
<A HREF="isom2005.html#0377" TARGET=body>import lists</A>, <BR>
<A HREF="isom2005.html#0382" TARGET=body>definitions</A>, <BR>
&quot;END&quot;, <A HREF="isom2005.html#0373" TARGET=body>module identifier</A>, &quot;.&quot; ; 
<P>The two module identifier components of a definition module shall be identical. 
<P><B>Declaration Semantics</B> 
<P>The export closure of the identifiers introduced by the definitions of a definition module, and the entities they denote, shall be associated with the identifier of the definition module in the outermost environment. 
<P><B>Note:</B> The export closure includes the identifiers implicitly exported when an identifier is explicitly exported &mdash; see <A HREF="#0038" TARGET=body>Implicit Import and Export</A>. 
<P>annotations The given environment is restricted by the import lists, and then used in the construction of the environment from the definitions of the definition module. The constructed module environment associates the name of the module with the export closure of the identifiers and entities defined in the module and is used for import from the module. The constructed local environment associates the name of the module with the identifiers and entities defined in the module, and is used within the corresponding implementation module. 
<P><B>Static Semantics</B> 
<P>A definition module shall not import from its own separate module. If present, the import lists of a definition module shall be valid given the outermost environment &mdash; see <A HREF="#0029" TARGET=body>Import Lists</A>. If present, the import lists and the definitions of a definition module shall be consistent with one another &mdash; see <A HREF="#0033" TARGET=body>Import Consistency in Definition Modules</A>. 
<P>The definitions of the definition module shall be well-formed given the identifiers of the system modules and the separate modules that are imported into the definition module, and given the identifiers that are imported from those modules. 
<P><B>Dynamic Semantics</B> 
<P>The elaboration of a definition module shall elaborate the definitions of the definition module, given the meaning of the imported identifiers. 
<P>annotations The compilation order is such that, when this operation is called, the result of elaboration of all definition modules used by the definition module have been merged in the given environment. 
<P><HR>
<A NAME="0020">
<A HREF="#0016" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0019" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0021" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Implementation Modules</H3>

<P>The formal model in this International Standard provides two ways by which the dynamic semantics of an implemen- tation of a separate module may be determined: 
<UL>
 
<LI>from the source text of a Modula-2 implementation module for the separate module, </LI>
<LI>from a formal specification of the separate module, as given for the standard library modules in sections 8 and 9. </LI>
</UL>

<P>The meaning of a program that uses a standard library module is obtained by producing an abstract implementation module directly from the specification. The formal model of an implementation module for which Modula-2 source is submitted is called a sourced implementation module in this International Standard. 
<P><UL>
<LI><A HREF="#0021" TARGET=body>Sourced Implementation Modules</A>
<LI><A HREF="#0022" TARGET=body>Abstract Implementation Modules</A>
</UL>
<P><HR>
<A NAME="0021">
<A HREF="#0020" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0020" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0022" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Sourced Implementation Modules</H4>

<P>An implementation module in source form consists of a sequence of import lists followed by a module block, which comprises a sequence of declarations and an optional module body. Both of these sequences may be empty. The source code for an implementation module is only distinguishable from the source code for a program module by the appearance of the keyword <TT>IMPLEMENTATION</TT> as the first token. 
<P>The meaning of procedures and opaque types defined in the definition module is expressed by full declarations in the implementation module. The declarations may include the declaration of local modules and other entities hidden from clients of the separate module. 
<P>After the initialization of the implementation modules of imported separate modules, any local modules declared in the implementation module are initialized and the initialization body of the implementation module (if any) is executed. This order of initialization allows actions to be taken before exported procedures are called from client modules and is guaranteed, provided that no separate module indirectly imports itself &mdash; see <A HREF="#0027" TARGET=body>Module Initialization Order</A>. 
<P>An implementation module may have an interrupt protection specified in its heading. The statements and procedures of the module are executed under a protection from interrupts as specified by the protection expression &mdash; see <A HREF="#0039" TARGET=body>Protected Modules</A>. 
<P><B>Concrete Syntax</B> 
<P><B>implementation module</B>= <BR>
&quot;IMPLEMENTATION&quot;, &quot;MODULE&quot;, <A HREF="isom2005.html#0373" TARGET=body>module identifier</A>, [ <A HREF="isom2005.html#0379" TARGET=body>interrupt protection</A> ], &quot;;&quot;, <BR>
<A HREF="isom2005.html#0377" TARGET=body>import lists</A>, <BR>
<A HREF="isom2005.html#0413" TARGET=body>module block</A>, <A HREF="isom2005.html#0373" TARGET=body>module identifier</A>, &quot;.&quot; ; 
<P>The two module identifier components of an implementation module shall be identical. 
<P><B>Static Semantics</B> 
<P>An implementation module shall not import from its own separate module. If present, the import lists of an imple- mentation module shall be valid given the outermost environment &mdash; see <A HREF="#0029" TARGET=body>Import Lists</A>. If present, the import lists and the declarations of an implementation module block shall be consistent with one another &mdash; see <A HREF="#0034" TARGET=body>Import Consistency in Module Blocks</A>. 
<P><B>Note:</B> An implementation module and it corresponding definition module must also be consistent (for example the exported procedures must be declared) &mdash; see <A HREF="#0017" TARGET=body>Programs and Compilation Modules</A> and <A HREF="#0024" TARGET=body>Definition Module and Implementation Module Consistency</A>. 
<P>Given the identifiers of the system modules and the separate modules that are imported into an implementation module, given the identifiers that are imported from those modules, and given the identifiers introduced by the definitions of the corresponding definition module: 
<UL>
 
<LI>the declarations of the module block of the implementation module shall be well-formed &mdash; see <A HREF="#0051" TARGET=body>Declarations</A>, </LI>
<LI>the bodies of module and procedure declarations of the module block shall be well-formed &mdash; see <A HREF="#0052" TARGET=body>Ordering of Procedure and Module Declarations</A>, </LI>
<LI>if present, the body of the module block shall be a well-formed module body &mdash; see <A HREF="#0104" TARGET=body>Module Blocks</A>. </LI>
</UL>

<P>If present in an implementation module heading, the interrupt protection shall be a valid interrupt protection in the context of the pervasive identifier environment only &mdash; see <A HREF="#0039" TARGET=body>Protected Modules</A>. 
<P><B>Dynamic Semantics</B> 
<P>The elaboration of an implementation module shall elaborate the declarations of the module block, given the meaning of the imported identifiers and the meaning of the identifiers that are introduced by the definitions of the definition module. 
<P>If an implmentation module is a protected module, the protection specified for the module shall be used to protect the protection domain of the implementation module. The protection shall be evaluated in the context of the pervasive identifier environment only. 
<P>annotations The compilation order is such that, when this operation is called, the result of elaboration of all definition modules used by the implementation module have been merged in the given environment. The protection expression (if present) is evaluated in an environment consisting of the pervasive identifiers only, and is added to the returned environment for use by the protection procedures. 
<P>The implementation module shall be initialized by initializing the implementation module block given the environment resulting from the elaboration of the implementation module &mdash; see <A HREF="#0105" TARGET=body>Static Module Initialization</A>. 
<P>annotations The environment for initializing the module block of the implementation module is retrieved from the given envi- ronment. 
<P><HR>
<A NAME="0022">
<A HREF="#0020" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0021" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0023" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Abstract Implementation Modules</H4>

<P>Abstract implementation modules are derived from the formal specification of a separate module and not from Modula-2 source text. The method of producing an abstract implementation module is given in normative annex B. 
<P><HR>
<A NAME="0023">
<A HREF="#0016" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0022" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0024" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Program Module and Separate Module Consistency</H3>

<P>Consistency between the compilation modules of a program is achieved if there is consistency between the correspond- ingly named definition and implementation modules, and if there is at least one valid compilation order. 
<P><UL>
<LI><A HREF="#0024" TARGET=body>Definition Module and Implementation Module Consistency</A>
<LI><A HREF="#0025" TARGET=body>Module Compilation Order</A>
<LI><A HREF="#0026" TARGET=body>Module Dependencies</A>
</UL>
<P><HR>
<A NAME="0024">
<A HREF="#0023" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0023" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0025" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Definition Module and Implementation Module Consistency</H4>

<P>The definition module and implementation module of a separate module are consistent if their definitions and decla- rations are consistent. 
<P><B>Static Semantics</B> 
<P>The identifiers imported into the implementation module by the import lists of the implementation module shall be distinct from the the identifiers defined in the definitions of the corresponding definition module. 
<P>Except for opaque types and procedures, no identifier defined in the definition module of a separate module shall be declared in the corresponding implementation module. 
<P>Each opaque type defined in the definition module of a separate module shall be declared in its corresponding imple- mentation module as a pointer type or as identical to another opaque type. 
<P><B>Notes:</B> 
<OL>
 
<LI>The defining instance of the type corresponding to an opaque type identifier defined in a definition module need not be within the declarations of the corresponding implementation module &mdash; the opaque type identifier may be exported from a local module of the implementation module or the opaque type may be declared as identical to that denoted by an imported identifier. </LI>
<LI>An opaque type may be redeclared as the address type, since the address type is also a pointer type. </LI>
</OL>

<P><B>Change:</B> In the third edition of <I>Programming in Modula-2</I> , opaque types must be declared as pointer types. This International Standard allows an opaque type to be declared as another opaque type, since that other opaque type must directly or indirectly be implemented as a pointer type. 
<P><B>Clarification:</B> An opaque type cannot be declared as a scalar type. 
<P>Each procedure heading in the definition module of a separate module shall have a matching procedure declaration in the corresponding implementation module. 
<P><B>Note:</B> A procedure declaration matching a procedure heading need not be within the declarations of the corresponding implementation module &mdash; the procedure identifier may be exported from a local module of the implementation module. 
<P>The formal parameter list of the procedure heading in the definition module shall match the formal parameter list of the procedure heading of the procedure declaration in the implementation module. The formal parameter lists of procedure headings shall match if the formal types of each of the value parameter specifications or variable parameter specifications of corresponding formal parameters are identical. 
<P><B>Clarification:</B> The definition of a procedure in a definition module and the corresponding declaration of that proce- dure in the implementation module must match in the sense that corresponding parameters must have the identical type. The identifiers used to denote the parameters need not be the same, and the identifiers used to denote the types of these parameters need not be the same. 
<P><B>Note:</B> Even if a definition module does not contain any procedure definitions or opaque type definitions there must still be a corresponding implementation module. Likewise, even if there are no exports from a module and the implementation module is used solely for initialization, there must still be a corresponding definition module. 
<P>annotations Retrieve an environment for a definition module. 
<P>annotations Remove any components of given environment that are derived from declaration of procedure headings or opaque types. 
<P>annotations Construct an environment for any imported entities. 
<P>annotations Construct an environment for an implementation module. 
<P>annotations Construct a set of identifiers that contains the identifiers defined in the definitions component of a definition module and construct a set containing the identifiers contained in the import lists component of an implementation module. The result is true if and only if the intersection of these two sets is empty. 
<P>annotations Check that each of the opaque types defined in a definition module is declared as a pointer type (which may be the address type) or as an opaque type in the corresponding implementation module. 
<P>annotations Extract the procedure headings from the two environments and check that they are identical. This function is used to check definition modules against implementation modules and forward procedure declarations against full procedure declarations. 
<P>annotations An abstract implementation module is consistent with its corresponding definition module by virtue of the method of its construction from the specification of an abstract implementation module. 
<P><HR>
<A NAME="0025">
<A HREF="#0023" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0024" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0026" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Module Compilation Order</H4>

<P>A compilation module may only be elaborated if the definition modules that define the entities imported by that compilation module have been elaborated. This restriction may always be satisfied provided no definition module indirectly imports itself. (A module S directly imports a module T if T occurs in the import list of S. A module S indirectly imports another module U if module S directly imports U, or if module S directly imports a module T and T indirectly imports module U.) 
<P><B>Static Semantics</B> 
<P>A valid compilation order shall be such that 
<UL>
 
<LI>all compilation modules of the program are included exactly once, </LI>
<LI>a definition module is included before the corresponding implementation module, </LI>
<LI>a definition module is included before any other compilation module that imports from the corresponding separate module. </LI>
</UL>

<P><B>Auxiliaries</B> 
<P>annotations Construct the set of the identifiers of the definition modules that appear in a sequence of program, definition, and implementation modules. 
<P><HR>
<A NAME="0026">
<A HREF="#0023" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0025" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0027" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Module Dependencies</H4>

<P>The compilation modules that depend upon a definition module of a program are those compilation modules that must be elaborated after the definition module is itself elaborated in a valid compilation order &mdash; see <A HREF="#0025" TARGET=body>Module Compilation Order</A>. 
<P>If a definition module of a program is modified, any record of a previous elaboration (or partial elaboration) of that definition module, and of a previous elaboration (or partial elaboration) of a dependent module, is potentially inconsistent with the modification. In this case, all affected modules must be elaborated again, in the same order as their elaboration in a valid compilation order. 
<P>annotations The result of this operation is a set of compilation orders for the compilation modules that must be recompiled if the compilation module that is the first parameter is recompiled. 
<P><HR>
<A NAME="0027">
<A HREF="#0016" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0026" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0028" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Module Initialization Order</H3>

<P>The order in which the implementation modules of the program are initialized is determined by the order in which the corresponding separate module identifiers appear in the import lists of the program module and the import lists of the other compilation modules &mdash; see <A HREF="#0029" TARGET=body>Import Lists</A>. 
<P>The order is such that, unless a separate module indirectly imports itself, an implementation module is initialized before the initialization of any client modules. 
<P>A separate module C is a &lsquo;client&rsquo; of a separate module M if the definition module of C, or the implementation module of C, imports from the separate module M and thus is a compilation module that depends upon the definition module of M. 
<P>A program module is a client of a separate module M if it imports from the separate module M and thus is a compilation module that depends upon the definition module of M. 
<P>A separate module indirectly imports from itself if it is part of a circle of references in the import lists. For example, if an implementation module A imports from a separate module B whose definition or implementation module imports from separate module A, then modules A and B both indirectly import from themselves. The relative order of initialization of such modules is related to the order of their occurrence in the import lists of the program. 
<P><B>Dynamic Semantics</B> 
<P>The initialization order shall be determined by first processing the import lists of the program module. The import lists of the program module shall be processed by processing the import lists of each separate module whose identifier appears in the import lists of the program module, in order of occurrence in those import lists. 
<P>If an import list is an unqualified import, the import list shall be processed by processing the import lists of the separate module whose module identifier appears in the import list. If an import list is a simple import, the import list shall be processed by processing in turn the import lists of each separate module whose identifier appears in the import list identifiers. 
<P>If the import lists of a separate module have finished being processed, or have started to be processed, the import lists of that module shall not be processed again. Otherwise, the import lists of the definition module shall be processed, and then the import lists of the implementation module shall be processed. 
<P>The initialization order shall be the order in which the corresponding separate modules finish the processing of their import lists. 
<P><B>Change:</B> The second edition of <I>Programming in Modula-2</I> does not deal with the effects of import lists on the order of the initialization of modules. The third edition states how import lists appearing in the implementation modules are used in the definition of the initialization order. The rule for import lists in implementation modules has been extended to cover the program module and definition modules. This International Standard defines an order for the initialization of modules when there is a circular reference in the import lists. The third edition of <I>Programming in Modula-2</I> states that the order of initialization is undefined in such a case. 
<P><B>Auxiliaries</B> 
<P>annotations Construct a sequence that contains the identifiers of those modules that are directly imported by the definition module. 
<P>annotations Construct a sequence of identifiers that contains the identifiers of those modules that are directly imported by the implementation module. 
<P><HR>
<A NAME="0028">
<A HREF="#0016" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0027" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0029" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Program Termination</H3>

<P>During program termination, the finalization bodies of those static modules that have started initialization are executed in the reverse order of their initialization. The static modules are the program module, the implementation modules, and any local modules declared in the module blocks of these compilation modules. 
<P>Program termination starts on the first occurrence of one of the following termination events: 
<P>a) the end of the normal part of the program module initialization body is reached, 
<P>b) a <TT>RETURN</TT> statement is executed in the program module initialization body, 
<P>c) the standard procedure <TT>HALT</TT> is called, 
<P>d) an exception is raised and this exception is not handled. 
<P>Cases a) and b) constitute normal termination. Case c) does not change the execution state, but no exit is made from protection domains &mdash; see <A HREF="#0039" TARGET=body>Protected Modules</A> and <A HREF="#0017" TARGET=body>Programs and Compilation Modules</A>. Case d) constitutes exceptional termination. (During exceptional termi- nation an implementation, where appropriate, is required to propagate a report of the exception to the environment from which the program was invoked &mdash; see ???.) 
<P>In a program with coroutines, cases a) and b) can only occur during execution of the main coroutine. It is possible for cases c) and d) to occur during the execution of any coroutine. 
<P>Further termination events might occur during finalization of the static modules. Firstly, the finalization body of a static module block may itself call <TT>HALT</TT> or may raise an exception that is not handled. Secondly, since coroutine activity continues during the finalization of the static modules, there might be a further termination event during execution of a coroutine. 
<P>In order to guarantee that the finalization bodies of static modules are always executed in the reverse order of their initialization, and that all static modules that have started their initialization are finalized, the first occurrence of a termination event in a coroutine causes static module finalization to be executed by that coroutine. This is true whether or not a termination event has already occurred during execution of another coroutine. 
<P>On the second and subsequent occurrences of a termination event in a coroutine, during static module finalization by that coroutine, the execution of the finalization body ceases and execution in that coroutine continues with the next finalization body that is to be executed by that coroutine. 
<P>As soon as the execution of the last static module to be finalized is completed, or is ceased, execution of the entire program is completed. 
<P>Since a coroutine may be started during the initialization of static modules, a coroutine may start finalizing before further static modules have started their initialization. In that case, no further static modules are initialized &mdash; see <A HREF="#0105" TARGET=body>Static Module Initialization</A>. 
<P>The system module <TT>TERMINATION</TT> exports enquiry procedures that allow the program to determine if program termi- nation is in progress and if there has been a call of <TT>HALT</TT> &mdash; see <A HREF="isom2004.html#0354" TARGET=body>The Module TERMINATION</A>. 
<P><B>Dynamic Semantics</B> 
<P>On the first occurrence of a termination event during the execution of a coroutine, if there is at least one static module of the program that has a finalization body and that has completed or started its initialization, static module finalization shall be started by that coroutine. The finalization bodies shall be executed for all static modules that have finalization bodies, and that have completed or started initialization. The finalization order shall be the reverse of the order in which these modules were initialized. 
<P>If there is a subsequent occurrence of a termination event, while the coroutine is executing the finalization body of a static module, the coroutine shall execute the next finalization body in the finalization order. 
<P>If there are no static modules to be finalized, or no further static modules to be finalized, the execution of the program shall be complete. 
<P><B>Notes:</B> 
<OL>
 
<LI>In a program with coroutines other than the main coroutine, the finalization body of a static module should be written so that it will behave correctly if called more than once or if reentered. </LI>
<LI>Modules that are dynamically initialized (on calls to procedures in which they are declared as local modules) are not finalized on program termination. </LI>
</OL>

<P><B>Change:</B> <I>Programming in Modula-2</I> makes no provision for the finalization of static modules on program termination. 
<P>annotations The formal model keeps a stack of static modules to be finalized in the global state. This stack is built during static module initialization. The operations <I>is-terminating</I> and <I>set-terminating</I> are per-coroutine operations. <I>set-terminating</I> makes a copy of the stack in the per-coroutine state. 
<P>annotations The operation <I>next-module</I> is a per-coroutine operation. It pops the next module off the per-coroutine copy of the termination stack. 
<P><HR>
<A NAME="0029">
<A HREF="#0016" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0028" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0030" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Import Lists</H3>

<P>Following the module heading, a module may have a sequence of import lists. An import list includes a list of the identifiers that are to be explicitly imported into the module. Explicit import of an enumeration type identifier implicitly imports the enumeration constant identifiers of the enumeration type. 
<P>Imported identifiers are introduced into the module, thus extending their scope, but they have a defining occurrence that appears elsewhere. 
<P>Every kind of module may include a sequence of import lists, whether it is a program module, a definition module, an implementation module, or a local module. In the case of a definition module, the imported identifiers may be used in the definitions of that module. In the case of any other kind of module, the imported identifiers may be used in the block of the module. 
<P><B>Concrete Syntax</B> 
<P><B>import lists</B>= { <A HREF="isom2005.html#0377" TARGET=body>import list</A> } ; 
<P><B>Declaration Semantics</B> 
<P>The identifiers imported by a sequence of import lists of a module shall be all of the identifiers imported separately by the individual import lists. The import of an identifier shall also import the entity denoted by that identifier. 
<P><B>Static Semantics</B> 
<P>Each import list in a sequence of import lists shall be valid in the given environment. 
<P><B>Note:</B> In the case of an import list appearing in a local module, the given environment is the environment that applies at the point of the local module declaration &mdash; see <A HREF="#0059" TARGET=body>Local Module Declarations</A>. In the case of an import list appearing in a program module, definition module, or implementation module, the given environment is the outermost environment which includes the identifiers of the system modules and the separate modules of the program &mdash; see <A HREF="#0017" TARGET=body>Programs and Compilation Modules</A>. 
<P>An identifier shall not be imported (explicitly or implicitly) by more than one import list in the import lists of a module. 
<P><B>Auxiliaries</B> 
<P>annotations Construct a sequence of identifiers containing the identifiers of all the modules whose identifiers occur in the import lists of a module. 
<P>annotations Construct a sequence of identifiers containing the identifiers of all the modules that occur in an import list of a module. 
<P>annotations Construct a set of identifiers from the import lists of a module. 
<P>annotations Construct a set of identifiers from the import list of a module. The identifiers in the set represent entities that are imported into a module. Note that the identifier in the <TT>FROM</TT> component (i.e. the name of the module) of an unqualified import is not in the set. 
<P><UL>
<LI><A HREF="#0030" TARGET=body>Import List</A>
<LI><A HREF="#0031" TARGET=body>Simple Imports</A>
<LI><A HREF="#0032" TARGET=body>Unqualified Import</A>
<LI><A HREF="#0033" TARGET=body>Import Consistency in Definition Modules</A>
<LI><A HREF="#0034" TARGET=body>Import Consistency in Module Blocks</A>
</UL>
<P><HR>
<A NAME="0030">
<A HREF="#0029" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0029" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0031" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Import List</H4>

<P>An import list may either be a simple import or an unqualified import. 
<P><B>Concrete Syntax</B> 
<P><B>import list</B>= <A HREF="isom2005.html#0377" TARGET=body>simple import</A> | <A HREF="isom2005.html#0377" TARGET=body>unqualified import</A> ; 
<P><HR>
<A NAME="0031">
<A HREF="#0029" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0030" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0032" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Simple Imports</H4>

<P>A simple import includes a list of the identifiers that are to be explicitly imported. Explicit import of an enumeration type identifier implicitly imports the enumeration constant identifiers of the enumeration type. 
<P>The identifiers imported by a simple import are introduced into the module in which the simple import appears. In the case of a simple import appearing in a local module, the scope of the imported identifiers is extended from the block in which the local module is declared. In the case of a simple import in a program module, definition module, or implementation module, the scope is extended from the outermost environment which includes the identifiers of the system modules and the separate modules of the program. 
<P><B>Concrete Syntax</B> 
<P><B>simple import</B>= &quot;IMPORT&quot;, <A HREF="isom2005.html#0398" TARGET=body>identifier list</A>, &quot;;&quot; ; 
<P><B>Declaration Semantics</B> 
<P>The identifiers that are imported by a simple import shall be the identifiers in the identifier list of the simple import, together with any identifiers that are implicitly imported with those identifiers &mdash; see <A HREF="#0038" TARGET=body>Implicit Import and Export</A>. 
<P><B>Static Semantics</B> 
<P>The identifiers imported (explicitly or implicitly) by a simple import shall be distinct from each other. Each of the identifiers in the identifier list shall be visible in the given environment. 
<P><B>Note:</B> The given environment does not include the pervasive identifiers, and so the pervasive identifiers may not be included in a simple import. 
<P><HR>
<A NAME="0032">
<A HREF="#0029" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0031" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0033" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Unqualified Import</H4>

<P>An unqualified import specifies a module identifier and a list of the identifiers that are to be explicitly imported from that module. Explicit import of an enumeration type identifier implicitly imports the enumeration constant identifiers of the enumeration type. 
<P>The identifiers imported by an unqualified import are introduced into the module in which the unqualified import appears. The scope of the imported identifiers is extended from the module specified by the unqualified import. 
<P>In the case of an unqualified import appearing in a local module, the module identifier refers to the module it denotes in the block in which the local module is declared. In the case of an unqualified import in a program module, definition module, or implementation module, the module identifier refers to one of the system modules or one of the separate modules of the program. 
<P><B>Concrete Syntax</B> 
<P><B>unqualified import</B>= &quot;FROM&quot;, <A HREF="isom2005.html#0373" TARGET=body>module identifier</A>, &quot;IMPORT&quot;, <A HREF="isom2005.html#0398" TARGET=body>identifier list</A>, &quot;;&quot; ; 
<P><B>Note:</B> The identifier list of the unqualified import contains identifiers that are distinct from each other. 
<P><B>Abstract Syntax</B> 
<P>annotations The number of elements in the set of identifiers of the abstract syntax of an unqualified import is equal to the number of identifiers in the identifier list of the concrete syntax. 
<P><B>Declaration Semantics</B> 
<P>The identifiers that are imported by an unqualified import shall be the identifiers in the identifier list of the unqualified import that are exported by the module denoted by the module identifier, together with any identifiers that are implicitly imported with those identifiers &mdash; see <A HREF="#0038" TARGET=body>Implicit Import and Export</A>. 
<P><B>Static Semantics</B> 
<P>The identifiers imported by an unqualified import shall be distinct from each other. The module identifier shall be the identifier of a module that is visible in the given environment, and each of the identifiers in the identifier list shall be exported from the identified module. 
<P><B>Auxiliaries</B> 
<P>annotations The identifiers that are imported from a module must be exported by that module; thus they must be in the domain of the environment associated with the module from which they were exported. 
<P><HR>
<A NAME="0033">
<A HREF="#0029" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0032" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0034" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Import Consistency in Definition Modules</H4>

<P><B>Static Semantics</B> 
<P>In the case of a definition module containing an import list, none of the implicitly or explicitly imported identifiers may be the same as an identifier defined in the definition module. 
<P><HR>
<A NAME="0034">
<A HREF="#0029" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0033" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0035" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Import Consistency in Module Blocks</H4>

<P><B>Static Semantics</B> 
<P>In the case of a module other than a definition module containing an import list, none of the explicitly or implicitly imported identifiers may be the same as an identifier declared in the module block of the importing module. 
<P><HR>
<A NAME="0035">
<A HREF="#0016" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0034" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0036" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Export Lists</H3>

<P>Following the import lists, if any, a local module may have a single export list &mdash; see <A HREF="#0059" TARGET=body>Local Module Declarations</A>. An export list includes a list of the identifiers that are explicitly exported from a local module. Explicit export of an enumeration type identifier implicitly exports the enumeration constant identifiers of the enumeration type. 
<P>An export list may either be an unqualified export or a qualified export. 
<P><B>Concrete Syntax</B> 
<P><B>export list</B>= <A HREF="isom2005.html#0378" TARGET=body>unqualified export</A> | <A HREF="isom2005.html#0378" TARGET=body>qualified export</A> ; 
<P><B>Declaration Semantics</B> 
<P>The export of an identifier shall also export the entity denoted by that identifier. 
<P><UL>
<LI><A HREF="#0036" TARGET=body>Unqualified Exports</A>
<LI><A HREF="#0037" TARGET=body>Qualified Exports</A>
</UL>
<P><HR>
<A NAME="0036">
<A HREF="#0035" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0035" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0037" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Unqualified Exports</H4>

<P>The identifiers exported by an unqualified export of a local module are introduced into the procedure or module in which the local module declaration appears. In the block of that procedure or module, the exported identifiers can be used with or without being qualified by the identifier of the local module. 
<P><B>Concrete Syntax</B> 
<P><B>unqualified export</B>= &quot;EXPORT&quot;, <A HREF="isom2005.html#0398" TARGET=body>identifier list</A>, &quot;;&quot; ; 
<P><B>Note:</B> The identifier list of the unqualified export contains identifiers that are distinct from each other. 
<P><B>Abstract Syntax</B> 
<P>annotations The number of elements in the set of identifiers of the abstract syntax of an unqualified export is equal to the number of identifiers in the identifier list of the concrete syntax. 
<P><B>Declaration Semantics</B> 
<P>The identifiers that are exported by an unqualified export shall be the identifiers in the identifier list of that unqualified export, together with any identifiers that are implicitly exported with those identifiers &mdash; see <A HREF="#0038" TARGET=body>Implicit Import and Export</A>. 
<P><B>Static Semantics</B> 
<P>The identifiers in the identifier list of an unqualified export shall be distinct from each other. 
<P>The identifiers in the identifier list of an unqualified export shall be declared in the declarations of the local module that contains the unqualified export. 
<P><B>Notes:</B> 
<OL>
 
<LI>The identifiers in the identifier list of an unqualified export are explicitly exported. Identifiers implicitly exported from a local module need not be declared in declarations of the local module since export of an enumeration type identifier implicitly exports the enumeration constant identifiers of the enumeration type whether or not the type identifier and the enumeration constant identifiers are introduced by the same declaration &mdash; see <A HREF="#0038" TARGET=body>Implicit Import and Export</A>. </LI>
<LI>The identifiers in the identifier list of an unqualified export may not be otherwise introduced into the procedure block or module block in which the local module is declared. This follows from the rules that declarations of a block may include only one defining occurrence of a particular identifier and, in the case of a module block, that none of the imported identifiers may be the same as an identifier declared in that block &mdash; see <A HREF="#0051" TARGET=body>Declarations</A> and <A HREF="#0034" TARGET=body>Import Consistency in Module Blocks</A>. </LI>
</OL>

<P><HR>
<A NAME="0037">
<A HREF="#0035" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0036" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0038" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Qualified Exports</H4>

<P>The identifiers exported by a qualified export of a local module are introduced for use in the procedure or module in which the local module declaration appears. In the block of that procedure or module, the exported identifiers can be used only if qualified by the identifier of the local module. 
<P><B>Concrete Syntax</B> 
<P><B>qualified export</B>= &quot;EXPORT&quot;, &quot;QUALIFIED&quot;, <A HREF="isom2005.html#0398" TARGET=body>identifier list</A>, &quot;;&quot; ; 
<P><B>Note:</B> The identifier list of the qualified export contains identifiers that are distinct from each other. 
<P><B>Abstract Syntax</B> 
<P>annotations The number of elements in the set of identifiers of the abstract syntax of a qualified export is equal to the number of identifiers in the identifier list of the concrete syntax. 
<P><B>Declaration Semantics</B> 
<P>The identifiers that are exported by a qualified export shall be the identifiers in the identifier list of that qualified export, together with any identifiers that are implicitly exported with those identifiers &mdash; see <A HREF="#0038" TARGET=body>Implicit Import and Export</A>. 
<P><B>Static Semantics</B> 
<P>The identifiers in the identifier list of a qualified export shall be distinct from each other. 
<P>The identifiers in the identifier list of a qualified export shall be declared in the declarations of the local module that contains the qualified export. 
<P><B>Note:</B> The identifiers in the identifier list of a qualified export are explicitly exported. Identifiers implicitly exported from a local module need not be declared in declarations of the local module since export of an enumeration type identifier implicitly exports the enumeration constant identifiers of the enumeration type whether or not the type identifier and the enumeration constant identifiers are introduced by the same declaration &mdash; see <A HREF="#0038" TARGET=body>Implicit Import and Export</A>. 
<P><HR>
<A NAME="0038">
<A HREF="#0016" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0037" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0039" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Implicit Import and Export</H3>

<P>The set of identifiers that is imported or exported if an identifier is explicitly imported or exported is called the (import and export) closure of that identifier. Normally, the closure includes only the explicitly imported or exported identifier. However, in the case of the explicit import or export of an identifier of an enumeration type, the closure also includes the identifiers of the values of that type. 
<P>Implicit export applies to the identifiers that are exported (qualified) from separate modules, by virtue of their being the subject of a definition in a definition module, as well as to export from a local module that uses an export list. 
<P><B>Declaration Semantics</B> 
<P>The closure of an identifier shall be a set consisting of that identifier, together with the closure of the type if the identifier is a type identifier. 
<P>The closure of a type shall be the empty set, except in the case that the type is an enumeration type, when the closure shall be the set of identifiers associated with the values of the enumeration type. 
<P><B>Note:</B> Thus if an identifier denoting an enumeration type is imported (exported), then the occurrence of that identifier in the import list (export list) is an abbreviation for the occurrence of that identifier, together with all of the identifiers associated with the constant values of the enumeration type. 
<P><B>Clarifications:</B> 
<OL>
 
<LI>If an identifier associated with a module that contains an unqualified export list is imported (exported), then the identifiers occurring in the export list of the module shall not be automatically imported (exported). </LI>
<LI>If an entity of a record type is imported or exported, the field identifiers of that record type are automatically available to be used as selectors. This does not constitute implicit import or export since, unlike the identifiers of enumeration values, field identifiers cannot be the subject of explicit import or export. </LI>
</OL>

<P>annotations The closure of a type is the empty set, except in the case that the type is an enumeration type, when it is the set of identifiers associated with the values of the enumeration type. 
<P><B>Note:</B> Identifiers implicitly exported from a module need not be declared in definitions or declarations of the module since export of an enumeration type identifier implicitly exports the enumeration constant identifiers of the enumeration type. This is true whether or not the type identifier and the enumeration constant identifiers are introduced by the same definition or declaration &mdash; see <A HREF="#0035" TARGET=body>Export Lists</A> and <A HREF="#0019" TARGET=body>Definition Modules</A>. This situation is illustrated by the following example which uses unqualified export from a local module although similar comments apply to export from a separate module (through definitions), and to qualified export from a local module. There is only a single defining occurrence of the enumeration constant identifiers in the declarations of M, as is required for well-formed declarations &mdash; see <A HREF="#0051" TARGET=body>Declarations</A>. 
<P><B>Example:</B> Implicit export of enumeration constant identifiers. 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;MODULE&nbsp;M;

&nbsp;&nbsp;&nbsp;&nbsp;MODULE&nbsp;M1;
&nbsp;&nbsp;&nbsp;&nbsp;EXPORT&nbsp;T1;&nbsp;(*&nbsp;implicitly&nbsp;exports&nbsp;red,&nbsp;green,&nbsp;and&nbsp;blue&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;TYPE&nbsp;T1&nbsp;=&nbsp;(red,&nbsp;green,&nbsp;blue);
&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;M1;

&nbsp;&nbsp;&nbsp;&nbsp;MODULE&nbsp;M2;
&nbsp;&nbsp;&nbsp;&nbsp;IMPORT&nbsp;T1;
&nbsp;&nbsp;&nbsp;&nbsp;EXPORT&nbsp;T2;&nbsp;(*&nbsp;implicitly&nbsp;exports&nbsp;red,&nbsp;green,&nbsp;and&nbsp;blue&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;TYPE&nbsp;T2&nbsp;=&nbsp;T1;
&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;M2;

&nbsp;&nbsp;&nbsp;&nbsp;CONST&nbsp;shade&nbsp;=&nbsp;M2.red;

&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;M;
</PRE>

<P><HR>
<A NAME="0039">
<A HREF="#0016" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0038" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0040" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Protected Modules</H3>

<P>An interrupt request may be generated by the system underlying a Modula-2 implementation to indicate that an external condition has arisen that requires the attention of the program. Depending on the run-time environment of an implementation, interrupt requests may originate from hardware device controllers, or may be generated by an underlying operating system. 
<P>The acceptance of such a request involves the interruption of the normal sequence of execution (see <A HREF="isom2004.html#0327" TARGET=body>The Module COROUTINES</A>) and may need to be postponed if the program is not prepared to handle the request, if it is a condition of relatively low priority, or if acceptance would lead to interference with the section of program that is under execution. 
<P>A program module, implementation module, or local module may specify, by including an interrupt protection in its heading, the extent to which the execution of enclosed statement sequences is to be protected from interrupts. 
<P>Protection from interrupts is provided by setting the current protection to the value specified in the module heading during initialization and finalization of the module and on activation of procedures exported from the module. 
<P>The pervasive identifiers <TT>UNINTERRUPTIBLE</TT> and <TT>INTERRUPTIBLE</TT> are provided to denote protection values. All mask- able interrupts are disabled if the current protection is specified as <TT>UNINTERRUPTIBLE</TT>. All interrupts are enabled if the current protection is specified as <TT>INTERRUPTIBLE</TT> &mdash; see <A HREF="#0208" TARGET=body>The Protection Type</A>. The current protection is initialized to an implementation-defined value &mdash; see <A HREF="#0282" TARGET=body>Operations to Initialize and Terminate the Program State</A>. 
<P>A module with a protection in its heading is called a protected module. Procedures exported from a protected module are called protected procedures. 
<P>Procedures that are not exported, and therefore not directly protected, are indirectly protected if called from a protected block body. However, such procedures may be made available, unprotected, for use outside a protected module if their values are returned as a result of a procedure call. 
<P>The declaration of a protected local module might occur within the declarations of another protected module. In all cases, the protection that is applied to the protection domain of a protected module is the protection specified for that module. Only a single protection is applied on entry to a protection domain. 
<P><B>Concrete Syntax</B> 
<P><B>interrupt protection</B>= &quot;[&quot;, <A HREF="isom2005.html#0379" TARGET=body>protection expression</A>, &quot;]&quot; ; 
<P><B>protection expression</B>= <A HREF="isom2005.html#0450" TARGET=body>constant expression</A> ; 
<P><B>Static Semantics</B> 
<P>The protection expression of a program module or implementation module shall be a constant expression of the protection type in the context of the pervasive identifier environment &mdash; see <A HREF="#0208" TARGET=body>The Protection Type</A>. 
<P>The protection expression of a local module that is protected from interrupts shall be a constant expression of the protection type given the environment that applies at the point of the local module declaration. 
<P><B>Change:</B> In <I>Programming in Modula-2</I> , the identifiers that have meaning in a protection expression of a separate module or a local module are not explicitly discussed, and the only examples given of protection expressions are single literal values. It is necessary to liberalize this, at least to the pervasive identifiers, in order to handle the definition of protection (for which, in general, literal values may vary between implementations) &mdash; see <A HREF="#0039" TARGET=body>Protected Modules</A>. 
<P><B>Dynamic Semantics</B> 
<P>For a module with interrupt protection, the value of the protection expression shall be used as the protection value during execution within the protection domain of the module. 
<P>Provided the protection of the new protection domain does not allow interrupts from any source that is not allowed by the current protection, entering an interrupt protection domain shall cause the current interrupt protection to be saved and then set to the value specified by the protection expression of the protected module; otherwise an exception shall be raised. 
<P><B>Note:</B> In cases where a local static module with interrupt protection is declared within the declarations of another static module with interrupt protection, the raising of this exception is inevitable if the protection of the inner module allows interrupts from a source not allowed by the protection of the outer module. Implementations are free to detect such situations prior to execution &mdash; see ???. 
<P>Leaving an interrupt protection domain shall cause the current interrupt protection to be restored to the value saved on the corresponding entry to the protection domain. 
<P>
<P><HR>
<A NAME="0040">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0039" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0041" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Definitions and Declarations</H2>

<P>Definitions and declarations serve to introduce the identifiers of a module or procedure into their scope. Definitions appear in definition modules; declarations appear in program modules, implementation modules, local modules and procedures. 
<P>With the exception of the predefined pervasive identifiers, each identifier that is used in a module must either be introduced by a definition or a declaration in that module or must be introduced by import from another module. 
<P>With the exception of the predefined pervasive identifiers, each identifier that is used in a procedure must either be introduced by a declaration in that procedure or must have a scope that includes the block in which the procedure is declared. 
<P>The scope of an identifier comprises the entirety of the definitions, blocks, or statement sequences within which the identifier may be used. Within its scope, an identifier has a unique meaning. However, it is not always the case that the meaning of an identifier is known throughout its scope. For example, the meaning of an identifier that is used in a declaration is not known if that identifier is introduced into its scope by a subsequent declaration in the same sequence of declarations. The static semantics require that, where the meaning of an identifier needs to be known for a declaration to be elaborated, uses of that identifier in a declaration must not precede any declaration of that identifier. 
<P>If a point where identifiers may be used is included in the scope of a particular identifier, that identifier is said to be visible at that point of use, whether or not its meaning is known. In this International Standard, the visibility and meaning of an identifier at the point of its use is determined by the environment that applies at that point &mdash; see <A HREF="#0239" TARGET=body>Environments</A>. 
<P>The declarations of procedures and of local modules may include statements within the blocks of those procedures and local modules. This International Standard defines a meaning for programs in which the statements of such declarations use identifiers whose scope includes those statements but whose introduction to that scope is given in a subsequent declaration in the same sequence of declarations. However, a conforming implementation may reject programs that use identifiers in statements that precede the declaration of those identifiers &mdash; see ???. The alternative static semantic rules that may be applied are given in <A HREF="#0052" TARGET=body>Ordering of Procedure and Module Declarations</A>. 
<P><UL>
<LI><A HREF="#0041" TARGET=body>Identifiers</A>
<LI><A HREF="#0042" TARGET=body>Qualified Identifiers</A>
<LI><A HREF="#0043" TARGET=body>Definitions</A>
<LI><A HREF="#0044" TARGET=body>Type Definitions</A>
<LI><A HREF="#0045" TARGET=body>Procedure Headings</A>
<LI><A HREF="#0051" TARGET=body>Declarations</A>
<LI><A HREF="#0052" TARGET=body>Ordering of Procedure and Module Declarations</A>
<LI><A HREF="#0053" TARGET=body>Constant Declarations</A>
<LI><A HREF="#0054" TARGET=body>Type Declarations</A>
<LI><A HREF="#0055" TARGET=body>Variable Declarations</A>
<LI><A HREF="#0056" TARGET=body>Procedure Declarations</A>
<LI><A HREF="#0059" TARGET=body>Local Module Declarations</A>
<LI><A HREF="#0060" TARGET=body>Auxiliary Formal Model Definitions</A>
</UL>
<P><HR>
<A NAME="0041">
<A HREF="#0040" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0040" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0042" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Identifiers</H3>

<P>An identifier denotes a constant, type, variable, procedure, or module. 
<P><B>Note:</B> The syntactic class identifier is an element of the lexis &mdash; see Chapter ???.
<P><B>Abstract Syntax</B> 
<P>annotations A set of tokens that are in a 1-1 
<P>The elements of <I>Identifier</I> are denoted by identifiers in the type style used for Modula-2 source text in this International Standard. 
<P><HR>
<A NAME="0042">
<A HREF="#0040" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0041" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0043" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Qualified Identifiers</H3>

<P>The term qualified identifier is used in situations where the Modula-2 concrete syntax permits a single identifier to be qualified by the identifier of the module that exports it. Since module identifiers may be exported from local modules, identifiers may be qualified by more than one module identifier. 
<P><B>Concrete Syntax</B> 
<P><B>qualified identifier</B>= { <A HREF="isom2005.html#0381" TARGET=body>qualifying identifier</A>, &quot;.&quot; }, identifier ; 
<P><B>qualifying identifier</B>= <A HREF="isom2005.html#0373" TARGET=body>module identifier</A> ; 
<P><B>Abstract Syntax</B> 
<P>annotations It is the responsibility of the translation process from concrete to abstract syntax to distinguish between the use of the period for module qualification and the use of the period for field selection. 
<P><B>Static Semantics</B> 
<P>An identifier that is not qualified by a module identifier shall be visible in the environment that applies at the point of use of that identifier or else shall be a pervasive identifier &mdash; see <A HREF="#0194" TARGET=body>Predefined Types, Standard Procedures and Standard Functions</A>. 
<P>Each qualifying identifier of a qualified identifier shall be the name of a module from which the succeeding identifier is exported. 
<P><B>Auxiliaries</B> 
<P>annotations The result is the environment of the module containing the declaration of the identifier component of the qualified identifier, together with that identifier. 
<P><HR>
<A NAME="0043">
<A HREF="#0040" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0042" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0044" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Definitions</H3>

<P>Definitions declare the identifiers that are to be exported from a separate module and introduce those identifiers into their scope. Definitions also specify certain permanent properties of the associated entities denoted by the identifiers, such as: 
<UL>
 
<LI>whether the entity is a constant and, if so, its associated type and value; </LI>
<LI>whether the entity is a type and, if so, possibly its structure and in the case of a new ordinal type, its set of permitted values; </LI>
<LI>whether the entity is a variable and, if so, its type and possibly its address; </LI>
<LI>whether the entity is a procedure and, if so, the structure of its heading. </LI>
</UL>

<P>The identifier is used to denote the associated entity, but only in those parts of the program that are within the scope of the identifier. 
<P><B>Note:</B> The scope of an identifier introduced in a definition includes the definition module in which the definition appears, the module block of the corresponding implementation module, the definitions of definition modules that import the identifier, and the module blocks of other modules that import the identifier. 
<P><B>Concrete Syntax</B> 
<P><B>definitions</B>= { <A HREF="isom2005.html#0382" TARGET=body>definition</A> } ; 
<P><B>definition</B>= <BR>
&quot;CONST&quot;, { <A HREF="isom2005.html#0389" TARGET=body>constant declaration</A>, &quot;;&quot; } | <BR>
&quot;TYPE&quot;, { <A HREF="isom2005.html#0383" TARGET=body>type definition</A>, &quot;;&quot; } | <BR>
&quot;VAR&quot;, { <A HREF="isom2005.html#0391" TARGET=body>variable declaration</A>, &quot;;&quot; } | <BR>
<A HREF="isom2005.html#0384" TARGET=body>procedure heading</A>, &quot;;&quot; ; 
<P><B>Declaration Semantics</B> 
<P>The identifiers and entities defined by the definitions of a definition module shall be the identifiers and entities defined by each definition in the context of any preceding definition of the definition module. 
<P>annotations The environment constructed from each definition is used in the construction of the environment from any following definitions 
<P><B>Static Semantics</B> 
<P>The identifiers that are used in the definitions of a definition module shall be identifiers whose scope includes those definitions. 
<P>An identifier that is used in a definition may not be one whose defining occurrence is given in a following definition, unless its use is within a new pointer type or a new procedure type and it is subsequently defined as a type identifier. 
<P><B>Note:</B> The use of an identifier within a new pointer type or a new procedure type follows the keywords <TT>POINTER&nbsp;TO</TT> or <TT>PROCEDURE</TT> and is &lsquo;shielded&rsquo; from the declare-before-use-in-declarations rule that otherwise applies. 
<P>The definitions of a definition module may include only one defining occurrence of a particular identifier. 
<P>annotations p defonly once, that shielded identifiers are visible, and that the define before use in definitions rule is satisfied. 
<P>annotations Check that no identifier is defined twice in a sequence of definitions. 
<P>annotations Check that all identifiers shielded by POINTER TO or PROCEDURE in new types in a sequence of definitions are visible to those definitions as type identifiers. 
<P><B>Dynamic Semantics</B> 
<P>The elaboration of the definitions of a definition module shall associate, in the resulting execution environment, the identifiers and entities defined by each definition. 
<P>annotations Resolve all definitions and then allocate storage. 
<P><HR>
<A NAME="0044">
<A HREF="#0040" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0043" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0045" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Type Definitions</H3>

<P>Type definitions serve to introduce an identifier that denotes a type and to specify that type and possibly its structure and set of permitted values. If the structure is omitted, the type definition defines an opaque type. 
<P><B>Concrete Syntax</B> 
<P><B>type definition</B>= <A HREF="isom2005.html#0390" TARGET=body>type declaration</A> | <A HREF="isom2005.html#0383" TARGET=body>opaque type definition</A> ; 
<P><B>opaque type definition</B>= identifier ; 
<P><B>Declaration Semantics</B> 
<P>The identifier of an opaque type definition shall be defined as the identifier of a unique opaque type; otherwise the identifiers and entities defined by a type definition shall be the identifiers and entities defined by a type declaration &mdash; see <A HREF="#0054" TARGET=body>Type Declarations</A>. 
<P>annotations A unique type name is generated for the opaque type, and the type identifier is associated with that type name; the environment contains a record of the new type and the structure of the type as being opaque. 
<P><B>Static Semantics</B> 
<P>If a type definition is a type declaration it shall have the static semantics of a type declaration | see 6.2.9. 
<P><B>Dynamic Semantics</B> 
<P>The elaboration of a type definition that is a type declaration shall associate the identifiers and entities of the type declaration in the resulting execution environment. 
<P><B>Note:</B> No dynamic semantics need to be given for the elaboration of opaque type definitions since, during program execution, a corresponding pointer type declaration is elaborated. 
<P>annotations Opaque type definitions have no dynamic semantics. 
<P><HR>
<A NAME="0045">
<A HREF="#0040" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0044" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0046" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Procedure Headings</H3>

<P>There are two kinds of procedure heading, namely proper procedure headings and function procedure headings. A proper procedure heading is the heading of a proper procedure. A proper procedure is activated by a procedure call statement. A function procedure heading is the heading of a function procedure. A function procedure is activated by a function call as a factor of an expression, and yields a result that is used as an operand in the expression. A function procedure heading is distinguished from a proper procedure heading by the specification of the function result type. 
<P>Procedure headings occur in definitions, within a definition module, and also occur in declarations, within a module or procedure block. Within declarations, a procedure heading has its own associated procedure block &mdash; see <A HREF="#0056" TARGET=body>Procedure Declarations</A>. One of the properties of a procedure heading, and its associated procedure block, is its &lsquo;declaration level&rsquo;. This is taken from the declaration level of the definitions or declarations in which the procedure heading occurs. Definitions, and the blocks of static modules, have a declaration level of 0. The declaration level of a procedure block is one more than the declaration level of the block in which the procedure is declared. The declaration level is required for static semantic rules governing the assignment of procedure values to procedure variables &mdash; see <A HREF="#0100" TARGET=body>Assignment Compatibility</A>. 
<P><B>Concrete Syntax</B> 
<P><B>procedure heading</B>= <A HREF="isom2005.html#0385" TARGET=body>proper procedure heading</A> | <A HREF="isom2005.html#0386" TARGET=body>function procedure heading</A> ; 
<P><UL>
<LI><A HREF="#0046" TARGET=body>Proper Procedure Headings</A>
<LI><A HREF="#0047" TARGET=body>Function Procedure Headings</A>
<LI><A HREF="#0048" TARGET=body>Formal Parameters</A>
</UL>
<P><HR>
<A NAME="0046">
<A HREF="#0045" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0045" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0047" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Proper Procedure Headings</H4>

<P>A proper procedure heading declares the name (and, if present, the formal parameters) of a proper procedure. 
<P><B>Concrete Syntax</B> 
<P><B>proper procedure heading</B>= <BR>
&quot;PROCEDURE&quot;, <A HREF="isom2005.html#0392" TARGET=body>procedure identifier</A>, [ <A HREF="isom2005.html#0385" TARGET=body>formal parameters</A> ] ; 
<P><B>formal parameters</B>= &quot;(&quot;, [ <A HREF="isom2005.html#0385" TARGET=body>formal parameter list</A> ], &quot;)&quot; ; 
<P><B>formal parameter list</B>= <A HREF="isom2005.html#0387" TARGET=body>formal parameter</A>, { &quot;;&quot;, <A HREF="isom2005.html#0387" TARGET=body>formal parameter</A> } ; 
<P><B>Declaration Semantics</B> 
<P>A proper procedure heading shall define the procedure identifier as a procedure identifier of a proper procedure, with a structure given by the declared number, positions, and formal types of parameters, and with the declaration level of the definitions or declarations in which it appears. 
<P><B>Static Semantics</B> 
<P>The identifiers declared as formal parameters in the formal parameter list of a proper procedure heading shall be distinct from each other, and distinct from the formal type identifiers. 
<P><B>Auxiliaries</B> 
<P>annotations Convert a proper procedure heading into a proper procedure structure. 
<P>annotations Convert a formal parameter list into a formal parameter type list. 
<P>annotations Convert a value or variable parameter specification into a value or variable formal type. 
<P>annotations Check that the identifiers declared in a formal parameter list are all distinct. 
<P><HR>
<A NAME="0047">
<A HREF="#0045" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0046" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0048" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Function Procedure Headings</H4>

<P>A function procedure heading declares the name (and, if present, the formal parameters) of a function procedure and declares the type of the result to be associated with the procedure identifier. 
<P><B>Concrete Syntax</B> 
<P><B>function procedure heading</B>= <BR>
&quot;PROCEDURE&quot;, <A HREF="isom2005.html#0392" TARGET=body>procedure identifier</A>, <A HREF="isom2005.html#0385" TARGET=body>formal parameters</A>, &quot;:&quot;, <A HREF="isom2005.html#0386" TARGET=body>function result type</A> ; 
<P><B>function result type</B>= <A HREF="isom2005.html#0396" TARGET=body>type identifier</A> ; 
<P><B>Declaration Semantics</B> 
<P>A function procedure heading shall define the procedure identifier as a procedure identifier of a function procedure, with a structure given by the declared number, positions, formal types of parameters, and result type, and with the declaration level of the definitions or declarations in which it appears. 
<P><B>Static Semantics</B> 
<P>The identifiers declared as formal parameters in the formal parameter list of a function procedure heading shall be distinct from each other and distinct from the formal type identifiers. The qualified identifier that defines the return type of the function procedure shall denote a type. 
<P><B>Auxiliaries</B> 
<P>annotations Convert a function procedure heading into a function procedure structure. 
<P><HR>
<A NAME="0048">
<A HREF="#0045" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0047" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0049" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Formal Parameters</H4>

<P>As an optional part of a procedure heading, a formal parameter provides an explicit interface between a block body that calls the procedure and the block body of the procedure. Calls of a procedure that has formal parameters must supply corresponding actual parameters. These are evaluated, and the resulting arguments are accessed in the procedure through the identifiers of the formal parameters. 
<P><B>Note:</B> There may also be an implicit interface between the block bodies through variable identifiers whose scope includes both block bodies. 
<P>There are two kinds of formal parameter: value parameters and variable parameters. In each case, the type of a formal parameter is specified by a formal type &mdash; see <A HREF="#0084" TARGET=body>Formal Types</A>. 
<P>The declaration semantics and static semantics of formal parameters are given in this clause. The dynamic semantics of formal parameters are given by procedure activation &mdash; see <A HREF="#0191" TARGET=body>Argument Binding</A>. 
<P><B>Concrete Syntax</B> 
<P><B>formal parameter</B>= <BR>
<A HREF="isom2005.html#0387" TARGET=body>value parameter specification</A> | <A HREF="isom2005.html#0387" TARGET=body>variable parameter specification</A> ; 
<P><A NAME="0049">
<A HREF="#0048" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0048" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0050" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Value Parameters</H5>

<P>Value parameters provide a means of explicitly passing a value into a procedure block body. Corresponding actual parameters must be expressions. In the procedure block body, a value parameter acts like a local variable to which the result of the evaluation of the actual parameter is assigned as an initial value. 
<P><B>Concrete Syntax</B> 
<P><B>value parameter specification</B>= <A HREF="isom2005.html#0398" TARGET=body>identifier list</A>, &quot;:&quot;, <A HREF="isom2005.html#0405" TARGET=body>formal type</A> ; 
<P><B>Abstract Syntax</B> 
<P>annotations In the translation from concrete to abstract syntax, each identifier in the identifier list is associated with its formal type. 
<P><B>Declaration Semantics</B> 
<P>A value parameter specification shall define each identifier in the identifier list to be a value formal parameter having the declared formal type &mdash; see <A HREF="#0084" TARGET=body>Formal Types</A>. 
<P><A NAME="0050">
<A HREF="#0048" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0049" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0051" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Variable Parameters</H5>

<P>Variable parameters provide a means of explicitly passing a variable into a procedure block body. Corresponding actual parameters must designate variables. In the procedure block body, the variable parameter identifier stands as an alias for the designated variable. 
<P><B>Concrete Syntax</B> 
<P><B>variable parameter specification</B>= &quot;VAR&quot;, <A HREF="isom2005.html#0398" TARGET=body>identifier list</A>, &quot;:&quot;, <A HREF="isom2005.html#0405" TARGET=body>formal type</A> ; 
<P><B>Abstract Syntax</B> 
<P>annotations In the translation from concrete to abstract syntax, each identifier in the identifier list is associated with its formal type. 
<P><B>Declaration Semantics</B> 
<P>A variable parameter specification shall define each identifier in the identifier list to be a variable formal parameter having the declared formal type | see 6.3.10. 
<P><HR>
<A NAME="0051">
<A HREF="#0040" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0050" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0052" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Declarations</H3>

<P>Declarations introduce identifiers into their scope in a procedure or module (other than a definition module). Decla- rations also specify certain permanent properties of the associated entities denoted by the identifiers, such as: 
<UL>
 
<LI>whether the entity is a constant and, if so, its associated type and value; </LI>
<LI>whether the entity is a type and, if so, its structure and, in the case of a new ordinal type, its set of permitted values; </LI>
<LI>whether the entity is a variable and, if so, its type and possibly its address; </LI>
<LI>whether the entity is a procedure and, if so, the structure of its heading and the associated block; </LI>
<LI>whether the entity is a local module and, if so, its exported identifiers and its associated block. </LI>
</UL>

<P>The identifier is used to denote the associated entity, but only in those parts of the program that are within the scope of the identifier. 
<P><B>Note:</B> The scope of an identifier declared in a procedure is the procedure block, but this can be restricted by redeclaring it within a nested procedure or by not importing it into a (nested) local module. The scope of an identifier declared in a local module is the module block plus enclosing blocks to which it is exported, but this can be restricted by redeclaring it within a nested procedure or by not importing it into a (nested) local module. 
<P><B>Concrete Syntax</B> 
<P><B>declarations</B>= { <A HREF="isom2005.html#0388" TARGET=body>declaration</A> } ; 
<P><B>declaration</B>= <BR>
&quot;CONST&quot;, { <A HREF="isom2005.html#0389" TARGET=body>constant declaration</A>, &quot;;&quot; } | <BR>
&quot;TYPE&quot;, { <A HREF="isom2005.html#0390" TARGET=body>type declaration</A>, &quot;;&quot; } | <BR>
&quot;VAR&quot;, { <A HREF="isom2005.html#0391" TARGET=body>variable declaration</A>, &quot;;&quot; } | <BR>
<A HREF="isom2005.html#0392" TARGET=body>procedure declaration</A>, &quot;;&quot; | <BR>
<A HREF="isom2005.html#0393" TARGET=body>local module declaration</A>, &quot;;&quot; ; 
<P><B>Declaration Semantics</B> 
<P>The identifiers and entities defined by a sequence of declarations shall be the identifiers and entities defined by each declaration in the context of any preceding declaration in the sequence. 
<P>annotations The environment constructed from each declaration is used in the construction of the environment from any following declarations 
<P><B>Static Semantics</B> 
<P>The identifiers that are used in the declarations of a module block or procedure block shall be identifiers whose scope includes those declarations. 
<P>An identifier that is used in a declaration may not be one whose defining occurrence is given in a following declaration, unless its use is within a new pointer type or a new procedure type and it is subsequently declared as a type identifier. 
<P><B>Note:</B> The use of an identifier within a new pointer type or a new procedure type follows the keywords <TT>POINTER&nbsp;TO</TT> or <TT>PROCEDURE</TT> and is &lsquo;shielded&rsquo; from the declare-before-use-in-declarations rule that otherwise applies. 
<P>The declarations of a block may include only one defining occurrence of a particular identifier. 
<P><B>Notes:</B> 
<OL>
 
<LI>Identifiers declared in a local module declaration, and exported from that module by an unqualified export, are effectively declared in the block that contains the module declaration &mdash; their scope includes that block and they are not imported into that block. </LI>
<LI>Identifiers declared in a local module declaration, and exported from that module by a qualified export, may have the same spelling as identifiers whose scope includes the block that contains the module declaration. Uses of such identifiers must be qualified by the identifier of the local module. </LI>
</OL>

<P>annotations p dclonly once, that shielded identifiers are visible, that the declare before use in declarations rule is satisfied, that all procedures that have been declared as <TT>FORWARD</TT> are fully declared, and that the bodies of modules and procedures are well-formed. 
<P>annotations Check that no identifier is declared twice in a sequence of declarations. Identifiers exported from local modules will be included in the check. Identical enumeration constants may be exported from more than one local module because of implicit export. 
<P>annotations Check that all identifiers shielded by POINTER TO or PROCEDURE in new types in a sequence of declarations are visible to those definitions as type identifiers. 
<P><B>Dynamic Semantics</B> 
<P>The elaboration of the declarations of a block shall associate, in the resulting execution environment, the identifiers and entities defined by each declaration. 
<P>annotations Resolve all declarations and then allocate storage. 
<P><HR>
<A NAME="0052">
<A HREF="#0040" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0051" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0053" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Ordering of Procedure and Module Declarations</H3>

<P>This International Standard gives meaning to programs that conform to either or both of the alternative static semantic rules for the ordering of procedure and module declarations given below. 
<P><B>Note:</B> Modula-2 implementations are required to choose one of the alternative rules for the ordering of procedure and module declarations according to the criteria of 4.3.
<P><B>Declare Before Use in Declarations Model</B> 
<P>The bodies of procedures and local modules declared within a sequence of declarations shall be well-formed given an environment in which all identifiers declared in that sequence are visible and in which the meaning of identifiers introduced in all declarations of that sequence is known. Thus, the identifiers used in the statements of a procedure declaration or the statements of a local module declaration of a block may be identifiers whose defining occurrence is given in a subsequent declaration of that block. 
<P><B>Declare Before Use Model</B> 
<P>The bodies of procedures and local modules declared within a sequence of declarations shall be well-formed given an environment in which all identifiers declared in that sequence are visible but in which the meaning of identifiers introduced in subsequent declarations of that sequence is unknown. Thus, the identifiers used in the statements of a procedure declaration or the statements of a local module declaration of a block may not be identifiers whose defining occurrence is given in a subsequent declaration of that block. 
<P><HR>
<A NAME="0053">
<A HREF="#0040" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0052" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0054" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Constant Declarations</H3>

<P>A constant declaration introduces an identifier as a synonym for a value. The value is specified by a constant expression. Each occurrence of the identifier is equivalent to an explicit occurrence of the value itself. 
<P><B>Concrete Syntax</B> 
<P><B>constant declaration</B>= identifier, &quot;=&quot;, <A HREF="isom2005.html#0450" TARGET=body>constant expression</A> ; 
<P><B>Declaration Semantics</B> 
<P>The identifier of a constant declaration shall be defined as a constant identifier that is associated with the type and value given by the evaluation of the constant expression at the point of the constant declaration. 
<P>annotations The identifier is associated with the constant value, and its type, in the consts component of the constructed environment. 
<P><B>Static Semantics</B> 
<P>The expression component of a constant declaration shall be a constant expression. The identifier of a constant declaration shall not be used in the constant expression. 
<P><B>Note:</B> The value of a constant expression can be determined statically since a constant expression can be completely evaluated by an analysis of the source code without executing the program &mdash; see <A HREF="#0179" TARGET=body>Constant Expressions</A>. 
<P><B>Dynamic Semantics</B> 
<P>The elaboration of a constant declaration shall associate, in the resulting execution environment, the identifier of the declaration, the value obtained from the evaluation of the constant expression, and the type of that value. 
<P><HR>
<A NAME="0054">
<A HREF="#0040" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0053" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0055" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Type Declarations</H3>

<P>Every value and every variable has a type &mdash; see <A HREF="#0069" TARGET=body>Data Types</A> and <A HREF="#0195" TARGET=body>Predefined Types</A>. The type of a value determines the operations that may be applied to that value &mdash; see <A HREF="#0099" TARGET=body>Expression Compatibility</A> and <A HREF="#0188" TARGET=body>Value Parameter Compatibility</A>. The type of a variable determines the set of values that may be assigned to that variable and determines the other operations that may be applied to that variable &mdash; see <A HREF="#0100" TARGET=body>Assignment Compatibility</A> and <A HREF="#0189" TARGET=body>Variable Parameter Compatibility</A>. 
<P>Type declarations are used to introduce new identifiers for existing identified types and to introduce identifiers for new types. Type identifiers may be used in variable declarations to specify the type of declared variables and are needed in procedure headings to specify the types of formal parameters and the return type of function procedures. 
<P><B>Notes:</B> 
<OL>
 
<LI>Type identifiers are not always needed in variable declarations since variables can be declared to be of a new type. In that case, the new type is an anonymous type since no type identifier is associated with that type. </LI>
<LI>Each occurrence of a new type defines a type that is different from any other type. </LI>
</OL>

<P><B>Concrete Syntax</B> 
<P><B>type declaration</B>= identifier, &quot;=&quot;, <A HREF="isom2005.html#0395" TARGET=body>type denoter</A> ; 
<P><B>Declaration Semantics</B> 
<P>The identifier of a type declaration shall be defined as a type identifier that is associated with the unique type denoted by the type denoter. 
<P><B>Note:</B> If the type denoter of a type declaration denotes a new enumeration type, the identifiers of the identifier list of the enumeration type are declared as constant identifiers of values of the enumeration type &mdash; see <A HREF="#0073" TARGET=body>Enumeration Types</A>. 
<P>annotations The identifier is associated with a unique name for the type in the types component of the constructed environment, and the unique name for the type is associated with its structure in the strucs component of that environment. 
<P><B>Static Semantics</B> 
<P>The identifier of a type declaration shall not be used in the type denoter unless its use is within a new pointer type or a new procedure type. 
<P><B>Example:</B> Use of the identifier of a type declaration in the type denoter. 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;ScanState&nbsp;=&nbsp;(*&nbsp;The&nbsp;type&nbsp;of&nbsp;lexical&nbsp;scanning&nbsp;control&nbsp;procedures&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;(CHAR,&nbsp;VAR&nbsp;ScanClass,&nbsp;VAR&nbsp;ScanState);
</PRE>

<P>This type declaration is taken from the standard strings conversion library &mdash; see ???.
<P><B>Dynamic Semantics</B> 
<P>The elaboration of a type declaration shall associate, in the resulting execution environment, the identifier of the declaration and the unique type that is the result of the elaboration of the type denoter 
<P><HR>
<A NAME="0055">
<A HREF="#0040" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0054" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0056" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Variable Declarations</H3>

<P>A variable declaration serves to declare one or more variables of a specified type and to introduce an identifier for each variable. Each variable declared in a variable declaration can be associated with a specified address. 
<P><B>Concrete Syntax</B> 
<P><B>variable declaration</B>= <A HREF="isom2005.html#0391" TARGET=body>variable identifier list</A>, &quot;:&quot;, <A HREF="isom2005.html#0395" TARGET=body>type denoter</A> ; 
<P><B>variable identifier list</B>= <BR>
identifier, [ <A HREF="isom2005.html#0391" TARGET=body>machine address</A> ], { &quot;,&quot;, identifier, [ <A HREF="isom2005.html#0391" TARGET=body>machine address</A> ] } ; 
<P><B>machine address</B>= &quot;[&quot;, <A HREF="isom2005.html#0391" TARGET=body>value of address type</A>, &quot;]&quot; ; 
<P><B>value of address type</B>= <A HREF="isom2005.html#0450" TARGET=body>constant expression</A> ; 
<P><B>Abstract Syntax</B> 
<P>annotations Identifiers may only occur once in a variable identifier list, and thus the cardinality of the set of identifiers of a <I>Variable-declaration</I> is the same as the number of identifiers in the variable identifier list. 
<P><B>Declaration Semantics</B> 
<P>The identifiers of a variable declaration shall be defined as variable identifiers of variables that are of the unique type denoted by the type denoter. 
<P><B>Notes:</B> 
<OL>
 
<LI>If the type denoter of a type declaration denotes a new type, the new type is an anonymous type since no type identifier is associated with that type. </LI>
<LI>If the type denoter of a type declaration denotes a new enumeration type, the identifiers of the identifier list of the enumeration type are declared as constant identifiers of values of the enumeration type &mdash; see <A HREF="#0073" TARGET=body>Enumeration Types</A>. </LI>
</OL>

<P>annotations The identifiers are associated with a unique name for the type in the vars component of the constructed environment, and the unique name for the type is associated with its structure in the strucs component of that environment. 
<P><B>Static Semantics</B> 
<P>The identifiers occurring in the variable identifier list of a variable declaration shall not be used in the type denoter. 
<P>Each machine address appearing in a variable declaration shall be a constant expression of the address type. 
<P><B>Notes:</B> 
<OL>
 
<LI>Since the declarations of a block may include only one defining occurrence of a particular identifier, the identifiers occurring in the variable identifier list of a variable declaration must be distinct from each other &mdash; see <A HREF="#0051" TARGET=body>Declarations</A>. </LI>
<LI>Constant values of the address type may only be formed by application of the predefined function procedures <TT>MAKEADR</TT> or <TT>CAST</TT> from the system module <TT>SYSTEM</TT>. The use of a machine address to fix the address of a variable thus requires a direct or indirect import from <TT>SYSTEM</TT>. </LI>
</OL>

<P><B>Dynamic Semantics</B> 
<P>The elaboration of a variable declaration shall associate, in the resulting execution environment, the identifiers of the declaration with variables of the unique type denoted by the type denoter. 
<P>Storage shall be allocated for each variable as appropriate for the type of the variables. If a machine address is used in declaring a variable, the storage shall be allocated at the given address. 
<P>annotations The elaboration of a variable declaration involves the elaboration of the type information to give the structure of the storage associated with the type, followed by the allocation of that storage. The variable identifier is associated with the storage by using a mapping in the environment. 
<P><B>Auxiliaries</B> 
<P>annotations Storage is allocated for each of the variables declared in the variable declaration. 
<P>annotations If the variable is of an elementary type, storage is allocated for it and information about the storage is added to the environment. If the variable is structured, then storage is allocated for each of its components, and the storage information is added to the environment. The result of this operation is the updated environment. 
<P><HR>
<A NAME="0056">
<A HREF="#0040" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0055" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0057" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Procedure Declarations</H3>

<P>There are two kinds of procedures, namely proper procedures and function procedures. A proper procedure is activated by a procedure call statement. A function procedure is activated by a function call as a factor of an expression, and yields a result that is used as an operand in the expression. A function procedure declaration is distinguished from a proper procedure declaration by its heading &mdash; see <A HREF="#0045" TARGET=body>Procedure Headings</A>. 
<P>A full procedure declaration consists of a procedure heading followed by a procedure block. The procedure block gives the declarations that are to be elaborated when the procedure is activated and the procedure body that is to be executed on that activation. 
<P>A forward procedure declaration consists of a procedure heading followed by the keyword <TT>FORWARD</TT>. A forward dec- laration may be used to avoid the forward references that would otherwise occur when two or more full procedure declarations contain mutually recursive references, and which will not be accepted by an implementation choosing the &lsquo;declare before use model&rsquo; &mdash; see <A HREF="#0052" TARGET=body>Ordering of Procedure and Module Declarations</A>. 
<P><B>Concrete Syntax</B> 
<P><B>procedure declaration</B>= <BR>
<A HREF="isom2005.html#0392" TARGET=body>proper procedure declaration</A> | <A HREF="isom2005.html#0392" TARGET=body>function procedure declaration</A> ; 
<P><B>Static Semantics</B> 
<P>If a forward declaration of a procedure is made, it shall precede a corresponding full declaration of that procedure. The full declaration shall be made in the same block or in a nested local module from which it is exported unqualified. 
<P>A procedure that is exported from a separate module, having a corresponding procedure heading in the definition module, shall not be given a forward procedure declaration in the implementation module. 
<P>The parameter lists of the headings of the forward declaration of the procedure and full declaration of that procedure shall match. The formal parameter lists of procedure headings shall match if the formal types of each of the value parameter specifications or variable parameter specifications of corresponding formal parameters are the same. 
<P><B>Note:</B> The rule for matching the procedure headings of forward and full procedure declarations is the same as the rule for matching the definition of a procedure in a definition module and the corresponding declaration of that procedure in the implementation module &mdash; see <A HREF="#0023" TARGET=body>Program Module and Separate Module Consistency</A>. The identifiers used to denote the parameters need not be the same, and the identifiers used to denote the types of these parameters need not be the same. 
<P><UL>
<LI><A HREF="#0057" TARGET=body>Proper Procedure Declarations</A>
<LI><A HREF="#0058" TARGET=body>Function Procedure Declarations</A>
</UL>
<P><HR>
<A NAME="0057">
<A HREF="#0056" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0056" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0058" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Proper Procedure Declarations</H4>

<P>A proper procedure declaration consists of a proper procedure heading, which declares the procedure identifier and the formal parameters, followed by the keyword <TT>FORWARD</TT> in the case of a forward procedure declaration, or followed by a proper procedure block in the case of a full procedure declaration. The proper procedure block contains the local declarations and the procedure body that is executed when the procedure is called. 
<P><B>Concrete Syntax</B> 
<P><B>proper procedure declaration</B>= <BR>
<A HREF="isom2005.html#0385" TARGET=body>proper procedure heading</A>, &quot;;&quot;, <BR>
( <A HREF="isom2005.html#0411" TARGET=body>proper procedure block</A>, <A HREF="isom2005.html#0392" TARGET=body>procedure identifier</A> | &quot;FORWARD&quot; ) ; 
<P><B>procedure identifier</B>= identifier ; 
<P>In a full proper procedure declaration the procedure identifier of the proper procedure heading shall be identical to the procedure identifier following the proper procedure block of that declaration. 
<P><B>Change:</B> The keyword <TT>FORWARD</TT> is not in early editions of Programming in Modula-2 . 
<P><B>Declaration Semantics</B> 
<P>A proper procedure declaration shall, through its heading, declare its identifier as a procedure identifier of a proper procedure structure, with the declared number, positions, and types of parameters, and with the declaration level of the block in which it is declared. 
<P><B>Note:</B> The blocks of static modules are at the declaration level of 0. The declaration level of a procedure block is one more than the declaration level of the block in which the procedure is declared. 
<P>Within the block of a full proper procedure declaration, the proper procedure heading shall declare the identifiers of any formal parameters to be variable identifiers of variables that are of the type denoted by the corresponding formal type. 
<P><B>Static Semantics</B> 
<P>The identifiers declared as formal parameters in the formal parameter list of the proper procedure heading of a proper procedure declaration shall be distinct from each other, and distinct from the formal type identifiers. 
<P>The identifiers declared in the declarations of a full proper procedure declaration shall be distinct from the identifiers declared as formal parameters in the formal parameter list of the proper procedure heading, and the declarations shall be well-formed given the environment that applies at the point of the procedure declaration, as overwritten by the parameters declared in the procedure heading. 
<P>Given a declaration level greater by one than the declaration level of the block in which the procedure is declared, and given the environment that applies at the point of the procedure declaration, as overwritten by the parameters declared in the procedure heading: 
<UL>
 
<LI>the bodies of module and procedure declarations of a full proper procedure declaration shall be well-formed &mdash; see <A HREF="#0052" TARGET=body>Ordering of Procedure and Module Declarations</A>, </LI>
<LI>if present, the body of the procedure block shall be a well-formed proper procedure body &mdash; see <A HREF="#0102" TARGET=body>Proper Procedure Blocks</A>. </LI>
</UL>

<P><B>Note:</B> The environment that applies at the point of the procedure declaration depends upon the &lsquo;declare before use&rsquo; rule that is applied &mdash; see <A HREF="#0052" TARGET=body>Ordering of Procedure and Module Declarations</A>. 
<P><B>Dynamic Semantics</B> 
<P>The elaboration of a full proper procedure declaration shall associate, in the resulting execution environment, the procedure identifier with a procedure value corresponding to the proper procedure block. The associated procedure value shall be such that, on activation, the actual parameters will be bound to the formal parameters and the proper procedure block will be executed. 
<P><B>Notes:</B> 
<OL>
 
<LI>The binding of the actual parameters to the formal parameters includes the allocation of storage for the parameters &mdash; see <A HREF="#0191" TARGET=body>Argument Binding</A>. </LI>
<LI>The elaboration of the declarations of the procedure block, including the allocation of storage for the local variables of the procedure block, occurs on the execution of the block. </LI>
<LI>Conforming implementations are required to document rules for the calculation of the amount of workspace that will be needed by a single activation of a particular proper procedure (without taking into account the workspace needed by any procedure that it calls) &mdash; see ???.</LI>
</OL>

<P>The associated procedure value shall also be such that, on normal or exceptional completion of the execution of the proper procedure block, the storage associated with the parameters will be freed. 
<P>annotations The elaboration of a proper procedure declaration is a proper procedure denotation that is the meaning of the parameters followed by the meaning of the block of the procedure. 
<P><B>Auxiliaries</B> 
<P>annotations Check that the identifiers declared in a proper procedure heading are not re-declared in the associated proper procedure block. 
<P>annotations The result is an identifier that is the name of a formal parameter. 
<P><HR>
<A NAME="0058">
<A HREF="#0056" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0057" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0059" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Function Procedure Declarations</H4>

<P>A function procedure declaration consists of a function procedure heading, which declares the procedure identifier, the formal parameters and the result type of the function procedure, followed by the keyword <TT>FORWARD</TT> in the case of a forward procedure declaration, or followed by a function procedure block in the case of a full procedure declaration. The function procedure block contains the local declarations and the procedure body that evaluates the result of the procedure. 
<P><B>Concrete Syntax</B> 
<P><B>function procedure declaration</B>= <BR>
<A HREF="isom2005.html#0386" TARGET=body>function procedure heading</A>, &quot;;&quot;, <BR>
( <A HREF="isom2005.html#0412" TARGET=body>function procedure block</A>, <A HREF="isom2005.html#0392" TARGET=body>procedure identifier</A> | &quot;FORWARD&quot; ) ; 
<P>In a full function procedure declaration the procedure identifier of the function procedure heading shall be identical to the procedure identifier following the function procedure block of that declaration. 
<P><B>Change:</B> The keyword <TT>FORWARD</TT> is not in early editions of <I>Programming in Modula-2</I> . 
<P><B>Declaration Semantics</B> 
<P>A function procedure declaration shall, through its heading, declare its identifier as a procedure identifier of a function procedure structure, with the declared number, positions, and types of parameters, with the declared result type, and with the declaration level of the block in which it is declared. 
<P><B>Note:</B> The blocks of static modules are at the declaration level of 0. The declaration level of a procedure block is one more than the declaration level of the block in which the procedure is declared. 
<P>Within the block of a full function procedure declaration, the function procedure heading shall declare the identifiers of any formal parameters to be variable identifiers of variables that are of the type denoted by the corresponding formal type. 
<P><B>Static Semantics</B> 
<P>The identifiers declared as formal parameters in the formal parameter list of the proper procedure heading of a proper procedure declaration shall be distinct from each other, and distinct from the formal type identifiers. 
<P>The identifiers declared in the declarations of a full function procedure declaration shall be distinct from the identifiers declared as formal parameters in the formal parameter list of the function procedure heading, and the declarations shall be well-formed given the environment that applies at the point of the procedure declaration, as overwritten by the parameters declared in the procedure heading. 
<P>Given a declaration level greater by one than the declaration level of the block in which the procedure is declared, and given the environment that applies at the point of the procedure declaration, as overwritten by the parameters declared in the procedure heading: 
<UL>
 
<LI>the bodies of module and procedure declarations of a full function procedure declaration shall be well-formed &mdash; see <A HREF="#0052" TARGET=body>Ordering of Procedure and Module Declarations</A>, </LI>
<LI>given the type denoted by the function result type, the body of the procedure block shall be a well-formed function procedure body &mdash; see <A HREF="#0103" TARGET=body>Function Procedure Blocks</A>. </LI>
</UL>

<P><B>Note:</B> The environment that applies at the point of the procedure declaration depends upon the &lsquo;declare before use&rsquo; rule that is applied &mdash; see <A HREF="#0052" TARGET=body>Ordering of Procedure and Module Declarations</A>. 
<P><B>Dynamic Semantics</B> 
<P>The elaboration of a full function procedure declaration shall associate, in the resulting execution environment, the procedure identifier with a procedure value corresponding to the function procedure block. The associated procedure value shall be such that, on activation, the actual parameters will be bound to the formal parameters, and the function procedure block will be executed. 
<P><B>Notes:</B> 
<OL>
 
<LI>The binding of the actual parameters to the formal parameters includes the allocation of storage for the parameters &mdash; see <A HREF="#0191" TARGET=body>Argument Binding</A>. </LI>
<LI>The elaboration of the declarations of the procedure block, including the allocation of storage for the local variables of the procedure, occurs on the execution of the block. </LI>
<LI>Conforming implementations are required to document rules for the calculation of the amount of workspace that will be needed by a single activation of a particular function procedure (without taking into account the workspace needed by any procedure that it calls) &mdash; see ???.</LI>
</OL>

<P>The associated procedure value shall also be such that, on normal or exceptional completion of the execution of the function procedure block, the storage associated with the parameters will be freed, and, on normal completion, the result value will be returned to the caller of the function procedure. 
<P><B>Note:</B> Normal completion of a function procedure block occurs on the execution of a return statement of that block. 
<P>annotations The elaboration of a function procedure declaration is a function procedure denotation that is the meaning of the parameters followed by the meaning of the block of the procedure. 
<P><B>Auxiliaries</B> 
<P>annotations Check that the identifiers declared in a function procedure heading are not redeclared in the associated function procedure block. 
<P><HR>
<A NAME="0059">
<A HREF="#0040" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0058" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0060" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Local Module Declarations</H3>

<P>A local module consists of a sequence of import lists, an optional export list, a sequence of declarations, and an optional module body. Both of these sequences may be empty. The import lists, if present, control the visibility of identifiers declared outside the module but usable within it. The export list, if present, controls the visibility of identifiers declared inside the module and usable outside it. 
<P>A local module may have a protection specified in its heading. The statements and procedures in the domain of protection are then executed under a protection as specified by the protection expression and the optional access- control procedures &mdash; see <A HREF="#0039" TARGET=body>Protected Modules</A>. 
<P><B>Concrete Syntax</B> 
<P><B>local module declaration</B>= <BR>
&quot;MODULE&quot;, <A HREF="isom2005.html#0373" TARGET=body>module identifier</A>, [ <A HREF="isom2005.html#0379" TARGET=body>interrupt protection</A> ], &quot;;&quot;, <BR>
<A HREF="isom2005.html#0377" TARGET=body>import lists</A>, [ <A HREF="isom2005.html#0378" TARGET=body>export list</A> ], <BR>
<A HREF="isom2005.html#0413" TARGET=body>module block</A>, <A HREF="isom2005.html#0373" TARGET=body>module identifier</A> ; 
<P>The two module identifier components of a module declaration shall be identical. 
<P><B>Declaration Semantics</B> 
<P>A local module declaration shall declare its identifier as a module identifier that may be used to qualify the identifiers exported from that module. In the case of unqualified export, the scope of the exported identifiers shall include the block in which the module is declared. 
<P>If the module is a protected module, or if the module is exported from an enclosing protected module, any exported procedures shall be protected procedures; otherwise, any exported procedures of the module that are also exported from an enclosing protected module shall be protected procedures. 
<P><B>Static Semantics</B> 
<P>A local module shall not import itself. If present, the import lists and the declarations of a local module block shall be consistent with one another &mdash; see <A HREF="#0034" TARGET=body>Import Consistency in Module Blocks</A>. If present, the import lists of a local module shall be valid given the environment that applies at the point of the local module declaration &mdash; see <A HREF="#0029" TARGET=body>Import Lists</A>. 
<P>If present, an export list of a local module shall be valid given the environment that is constructed from the declarations of the local module block &mdash; see <A HREF="#0035" TARGET=body>Export Lists</A>. 
<P>Any identifiers that are explicitly exported from a local module shall not be the identifiers of control variables of for statements of the module block. 
<P>The declarations of the local module shall be well-formed given the identifiers that are imported into the module. 
<P>If present in the local module heading, the interrupt protection shall be a valid interrupt protection in the context of the environment that applies at the point of the module declaration &mdash; see <A HREF="#0039" TARGET=body>Protected Modules</A>. 
<P>Given the environment that applies at the point of the local module declaration, restricted to the identifiers that are imported into the module: 
<UL>
 
<LI>the bodies of module and procedure declarations of the module block shall be well-formed &mdash; see <A HREF="#0052" TARGET=body>Ordering of Procedure and Module Declarations</A>, </LI>
<LI>if present, the body of the module block shall be a well-formed module body &mdash; see <A HREF="#0104" TARGET=body>Module Blocks</A>. </LI>
</UL>

<P><B>Note:</B> The environment that applies at the point of the local module declaration depends upon the &lsquo;declare before use&rsquo; rule that is applied &mdash; see <A HREF="#0052" TARGET=body>Ordering of Procedure and Module Declarations</A>. 
<P><B>Dynamic Semantics</B> 
<P>The elaboration of a local module declaration shall elaborate the declarations of the module block, given the meaning of the imported identifiers, and shall associate, in the resulting execution environment, the module identifier with the identifiers that are exported by the local module, and the identifiers that are exported unqualified with their associated entities. 
<P>If the local module is a protected module, the protection specified for that local module shall be used to protect the protection domain of the local module, instead of the protection of any enclosing protected module. 
<P><B>Note:</B> Only the innermost protection domain applies to procedures exported through more than one enclosing protected module. 
<P><B>Note:</B> The local module is executed on static or dynamic module initialization &mdash; see <A HREF="#0105" TARGET=body>Static Module Initialization</A> and <A HREF="#0107" TARGET=body>Dynamic Module Initialization</A>. 
<P><HR>
<A NAME="0060">
<A HREF="#0040" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0059" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0061" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Auxiliary Formal Model Definitions</H3>

<P><UL>
<LI><A HREF="#0061" TARGET=body>Identifiers Defined in Definitions</A>
<LI><A HREF="#0062" TARGET=body>Identifiers Declared in Declarations</A>
<LI><A HREF="#0063" TARGET=body>Identifiers Defined in New Types</A>
<LI><A HREF="#0064" TARGET=body>Qualified Identifiers Used in Declarations</A>
<LI><A HREF="#0065" TARGET=body>Qualified Identifiers used in Expressions</A>
<LI><A HREF="#0066" TARGET=body>Qualified Identifiers Used in Types</A>
<LI><A HREF="#0067" TARGET=body>Qualified Identifiers Used in Parameters</A>
<LI><A HREF="#0068" TARGET=body>Shielded Environments and Shielded Identifiers</A>
</UL>
<P><HR>
<A NAME="0061">
<A HREF="#0060" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0060" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0062" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Identifiers Defined in Definitions</H4>

<P>annotations The result of this operation is a set containing those identifiers that have been defined in a sequence of definitions. 
<P>annotations Return a set containing those identifiers that have been explicitly defined by a definition. 
<P>annotations Return a set containing those identifiers that have been implicitly defined in a definition - namely enumeration constants. 
<P><HR>
<A NAME="0062">
<A HREF="#0060" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0061" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0063" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Identifiers Declared in Declarations</H4>

<P>annotations The result of this function is a set containing those identifiers that have been declared in a sequence of declarations. 
<P>annotations Return a set containing those identifiers that have been declared in a declaration. 
<P>annotations Return a set containing those identifiers that have been implicitly declared in a declaration &mdash; namely enumeration constants. 
<P><HR>
<A NAME="0063">
<A HREF="#0060" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0062" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0064" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Identifiers Defined in New Types</H4>

<P>annotations Return a set of identifiers containing all the identifiers defined in a type component of a definition. These are the enumeration type constants (identifiers). 
<P>annotations Return a set of the identifiers defined in a fields list. 
<P>annotations Return a set of the identifiers defined in fields. These are the enumeration type constants (identifiers) defined in any type components of the components of the fields. 
<P>annotations Return a set of the identifiers defined in a variant. These are the enumeration type constants (identifiers) defined in the components of the variant. 
<P><HR>
<A NAME="0064">
<A HREF="#0060" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0063" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0065" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Qualified Identifiers Used in Declarations</H4>

<P>annotations The result is a set containing those qualified identifiers that have been used in a sequence of declarations. 
<P>annotations The result is a set containing those qualified identifiers that have been used in the declaration of an identifier. 
<P><HR>
<A NAME="0065">
<A HREF="#0060" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0064" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0066" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Qualified Identifiers used in Expressions</H4>

<P>annotations The result is a set of qualified identifiers used in an expression; this is the set containing all the qualified identifiers used in the components of the expression. 
<P>annotations The result is the set of qualified identifiers used in an infix expression; this is the set that is the union of the sets of qualified identifiers used in both of the expression components of the infix expression. 
<P>annotations The result is the set of qualified identifiers used in a prefix expression; this is the set of qualified identifiers used in the expression component of the prefix expression. 
<P>annotations The result is the set of qualified identifiers used in a value designator; this is the set of qualified identifiers used in either an entire value, an indexed value, a selected value, or a dereferenced value. The set of qualified identifiers used in an entire value consists of the qualified identifier used to denote the entire value. The set of qualified identifiers used in an indexed value consists of the qualified identifiers used in the value designator component together with the qualified identifiers used in the expression component. The set of qualified identifiers used in a selected value consists of the qualified identifiers used in the value designator component. The set of qualified identifiers used in a dereferenced value consists of the qualified identifiers used in the value designator component. 
<P>annotations The result is the set of qualified identifiers used in a function call; this is the set of qualified identifiers used in the function designator component, together with the qualified identifiers used in the actual parameters of the function call. 
<P>annotations The result is the set of qualified identifiers used in the actual parameters of a function call; this set consists of all the qualified identifiers used in each of the actual parameters. 
<P>annotations The result is a set of qualified identifiers used in an actual parameter to a procedure or function call; this set consists of the qualified identifiers used in the actual parameter. 
<P>annotations The result is the set of qualified identifiers used in a variable designator; this is the set of qualified identifiers used in either an entire designator, an indexed designator, a selected designator, or a dereferenced designator. The set of qualified identifiers used in an entire designator consists of the qualified identifier used to denote the entire variable. The set of qualified identifiers used in an indexed designator consists of the qualified identifiers used in the variable designator component together with the qualified identifiers used in the expression component. The set of qualified identifiers used in a selected designator consists of the qualified identifiers used in the variable designator component. The set of qualified identifiers used in a dereferenced designator consists of the qualified identifiers used in the variable designator component. 
<P>annotations The result is the set of qualified identifiers used in a value constructor; this set consists of the qualified identifiers used either in an array constructor, a record constructor, or a set constructor. 
<P>annotations The result is the qualified identifiers used in an array constructor; this set consists of the union of the qualified identifiers used in all the expression components of the array constructor together with the qualified identifier used to denote the array. 
<P>annotations The result is the set of qualified identifiers used in a record constructor; this set consists of the union of the qualified identifiers used in all the expression components of the record constructor, together with the qualified identifier used to denote the record. 
<P>annotations The result is the set of qualified identifiers used in an element of a value constructor. 
<P>annotations The result is the set of qualified identifiers used in a set constructor; this set consists of the union of the qualified identifiers used in all the members of the set constructor together with the qualified identifier used to denote the set. 
<P>annotations The result is the set of qualified identifiers used in a member; this set consists of the union of the qualified identifiers used in the expression component(s) of the member. 
<P><HR>
<A NAME="0066">
<A HREF="#0060" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0065" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0067" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Qualified Identifiers Used in Types</H4>

<P>annotations The result is the set of qualified identifiers used in a type; the members of this set are the qualified identifiers used to denote type names and any qualified identifiers that appear in any constant expressions. The set does not include those type identifiers that are shielded either by <TT>POINTER&nbsp;TO</TT> or by <TT>PROCEDURE</TT>. 
<P>annotations The result is the set of qualified identifiers used in a fields list; these are the qualified identifiers used to denote type names in each of the components of the fields list. 
<P>annotations The result is the set of qualified identifiers used in fields; these are the qualified identifiers used to denote type names in each of the components of the fields. 
<P>annotations The result is the set of qualified identifiers used in variants; these are the qualified identifiers used in each of the components of the variants. 
<P>annotations The result is the set of qualified identifiers used in a variant; these are the qualified identifiers used in the labels component and fields component of the variant. 
<P><HR>
<A NAME="0067">
<A HREF="#0060" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0066" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0068" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Qualified Identifiers Used in Parameters</H4>

<P>annotations The result is the set of qualified identifiers used in parameters; these are the qualified identifiers used in each of the components of the parameters. 
<P>annotations The result is the set of qualified identifiers used in a parameter; these are the qualified identifiers used to denote type names in the formal type of the parameter. 
<P>annotations The result is the set of qualified identifiers used in a formal type; these are the qualified identifiers used to denote type names in either a parameter formal type or an array formal type. 
<P>annotations The result is the set of qualified identifiers used in a formal type; these are the qualified identifiers used to denote type names in an array formal type. 
<P><HR>
<A NAME="0068">
<A HREF="#0060" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0067" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0069" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Shielded Environments and Shielded Identifiers</H4>

<P>annotations The result of this operation is a set consisting of those qualified identifiers that are shielded in a declaration. An identifier is shielded if it is used within a new pointer type or a new procedure type. 
<P>annotations Return a set of qualified identifiers consisting of all the identifiers that are shielded in a type component of a definition. 
<P>annotations Return the set of qualified identifiers shielded in a fields list; these are the identifiers that are shielded in each of the components of the field list. 
<P>annotations Return the set of qualified identifiers shielded in fields. 
<P>annotations Return the set of qualified identifiers shielded in variants. 
<P>annotations Return the set of qualified identifiers shielded in a variant. 
<P>
<P><HR>
<A NAME="0069">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0068" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0070" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Data Types</H2>

<P>Every value and every variable has a type. The type of a value determines the operations that may be applied to that value &mdash; see <A HREF="#0099" TARGET=body>Expression Compatibility</A> and <A HREF="#0188" TARGET=body>Value Parameter Compatibility</A>. The type of a variable determines the set of values that may be assigned to that variable and determines the other operations that may be applied to that variable &mdash; see <A HREF="#0100" TARGET=body>Assignment Compatibility</A> and <A HREF="#0189" TARGET=body>Variable Parameter Compatibility</A>. 
<P>Some types, such as the number types, are basic to the language. For every basic type, the language provides a set of fundamental operations that may be performed on values of the type. Other types are constructed, using mechanisms provided by the language, as enumeration, subrange, opaque, set, pointer, procedure, array, and record types. 
<P>A distinction is made between elementary types and structured (composite) types. Array types and record types are structured types in the sense that values or variables of such types are compositions of other constituent values or variables which may be denoted as such. Values or variables of an elementary type have no constituents that may be denoted as components. 
<P><B>Note:</B> The term structured type has been adopted from <I>Programming in Modula-2</I> . However, constructed types other than array types and record types also have a structure. For example, procedure types have a specified number of parameters of specified types. Where there might be ambiguity, array and record types are also referred to as composite types in this International Standard. 
<P>Ordinal types are types for which the permitted values form a discrete set for which there is a complete ordering; ordinal types are therefore elementary types. Of the basic types, the Boolean, character, unsigned, signed, and Ztypes are all ordinal types. Of the constructed types, enumeration types and subrange types are ordinal types. The ordinal number of a value of an ordinal type may be ascertained using the standard function procedure <TT>ORD</TT> &mdash; see <A HREF="#0232" TARGET=body>The Function ORD</A>. 
<P><UL>
<LI><A HREF="#0070" TARGET=body>Type Denoters and Ordinal Type Denoters</A>
<LI><A HREF="#0071" TARGET=body>Type Identifiers</A>
<LI><A HREF="#0072" TARGET=body>New Types</A>
<LI><A HREF="#0073" TARGET=body>Enumeration Types</A>
<LI><A HREF="#0074" TARGET=body>Subrange Types</A>
<LI><A HREF="#0075" TARGET=body>Set Types</A>
<LI><A HREF="#0076" TARGET=body>Packedset Types</A>
<LI><A HREF="#0077" TARGET=body>Pointer Types</A>
<LI><A HREF="#0078" TARGET=body>Procedure Types</A>
<LI><A HREF="#0084" TARGET=body>Formal Types</A>
<LI><A HREF="#0085" TARGET=body>Array Types</A>
<LI><A HREF="#0086" TARGET=body>Record Types</A>
<LI><A HREF="#0089" TARGET=body>Storage Allocation</A>
</UL>
<P><HR>
<A NAME="0070">
<A HREF="#0069" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0069" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0071" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Type Denoters and Ordinal Type Denoters</H3>

<P>Type denoters are used to refer to existing identified types or to new types. The form of type denoter that is used to refer to an identified type is a type identifier. The identified type must either have a predefined identifier or an identifier must be introduced in a type definition or a type declaration &mdash; see <A HREF="#0195" TARGET=body>Predefined Types</A>, Chapter <A HREF="isom2004.html#0305" TARGET=body>System Modules</A>, <A HREF="#0044" TARGET=body>Type Definitions</A> and <A HREF="#0054" TARGET=body>Type Declarations</A>. 
<P>The form of type denoter that is used to refer to a new type has the effect of establishing a programmer-defined type that is distinct from any other type. This unique type will only become an identified type if the new type is being used as the type denoter in a type definition or a type declaration; otherwise the unique type is an anonymous type. 
<P>Apart from their use as type denoters in type declarations, new types may be used as type denoters in variable declarations. In addition to their use as type denoters in type declarations and variable declarations, type identifiers may be used to denote formal parameter types in procedure headings and in procedure types &mdash; see <A HREF="#0045" TARGET=body>Procedure Headings</A> and <A HREF="#0078" TARGET=body>Procedure Types</A>. 
<P>There are constructs in the language which require an ordinal type to be denoted rather than a general type. For example, the base type of a set type and the index type of an array type must be ordinal types. The concrete syntax uses the category &lsquo;ordinal type denoter&rsquo; to indicate that a denoter of some ordinal type is expected. The form of ordinal type denoter that is used to refer to an identified ordinal type is an ordinal type identifier. The form of ordinal type denoter that is used to establish an ordinal type that is distinct from any other type is a new ordinal type. Enumeration types and subrange types are the two forms of new ordinal type. 
<P><B>Concrete Syntax</B> 
<P><B>type denoter</B>= <A HREF="isom2005.html#0396" TARGET=body>type identifier</A> | <A HREF="isom2005.html#0397" TARGET=body>new type</A> ; 
<P><B>ordinal type denoter</B>= <A HREF="isom2005.html#0396" TARGET=body>ordinal type identifier</A> | <A HREF="isom2005.html#0397" TARGET=body>new ordinal type</A> ; 
<P><B>Abstract Syntax</B> 
<P>annotations In the translation from concrete to abstract syntax a value of type <I>Type-identifier</I> is used if the concrete syntax contains an ordinal type identifier, and a value of type <I>New-type</I> is used if the concrete syntax contains a new ordinal type. 
<P><B>Declaration Semantics</B> 
<P>annotations The functions specifying the declaration semantics translate a new type into a type structure in which any new type component of the new type has been replaced by a unique type name (a &lsquo;hidden&rsquo; name that cannot be generated in source code). Thus the &lsquo;new types&rsquo; defined by some type declarations and variable declarations are each denoted by a name that is unique with respect to the complete program. Any type identifier occurring within a new type is replaced by its corresponding unique type name. The unique type name is associated with its structure by a mapping that is a component of the environment. Type identifiers are associated with their unique type names by a mapping that is another component of the environment. Thus an identifier denoting a type is mapped by a component of the environment into a unique type name, and that type name is mapped by a component of the environment into the structure of that type. 
<P><HR>
<A NAME="0071">
<A HREF="#0069" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0070" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0072" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Type Identifiers</H3>

<P>A type identifier denotes an identified type that is predefined or is defined elsewhere in a type definition or a type declaration &mdash; see <A HREF="#0044" TARGET=body>Type Definitions</A> and <A HREF="#0054" TARGET=body>Type Declarations</A>. There are some predefined types for which there are predefined type identifiers that are are pervasive &mdash; see <A HREF="#0195" TARGET=body>Predefined Types</A>. The pervasive identifiers for the basic types are <TT>BOOLEAN</TT>, for the Boolean type; <TT>CARDINAL</TT>, for the unsigned type; <TT>CHAR</TT>, for the character type; <TT>COMPLEX</TT>, for the complex type; <TT>INTEGER</TT>, for the signed type; <TT>LONGCOMPLEX</TT>, for the long complex type; <TT>LONGREAL</TT>, for the long real type; and <TT>REAL</TT>, for the real type. The pervasive identifiers for the predefined constructed types are <TT>BITSET</TT>, for the bitset type (which is a packedset type); and <TT>PROC</TT>, for the proc type (which is a procedure type). <TT>PROTECTION</TT> is a pervasive identifier for the implementation- defined protection type &mdash; see <A HREF="#0208" TARGET=body>The Protection Type</A>. 
<P>All of the types with pervasive identifiers are elementary types. 
<P><B>Concrete Syntax</B> 
<P><B>type identifier</B>= <A HREF="isom2005.html#0381" TARGET=body>qualified identifier</A> ; 
<P><B>ordinal type identifier</B>= <A HREF="isom2005.html#0396" TARGET=body>type identifier</A> ; 
<P><B>Declaration Semantics</B> 
<P>A type identifier shall denote the unique type that is associated with the qualified identifier. 
<P><B>Static Semantics</B> 
<P>The qualified identifier shall denote a type that is predefined or is defined elsewhere in a type definition or a type declaration &mdash; see <A HREF="#0044" TARGET=body>Type Definitions</A> and <A HREF="#0054" TARGET=body>Type Declarations</A>. 
<P><HR>
<A NAME="0072">
<A HREF="#0069" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0071" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0073" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>New Types</H3>

<P>A new type denotes a unique programmer-defined type and specifies the structure of values and variables of that type. 
<P><B>Concrete Syntax</B> 
<P><B>new type</B>= <BR>
<A HREF="isom2005.html#0397" TARGET=body>new ordinal type</A> | <A HREF="isom2005.html#0400" TARGET=body>set type</A> | <BR>
<A HREF="isom2005.html#0401" TARGET=body>packedset type</A> | <A HREF="isom2005.html#0402" TARGET=body>pointer type</A> | <BR>
<A HREF="isom2005.html#0403" TARGET=body>procedure type</A> | <A HREF="isom2005.html#0406" TARGET=body>array type</A> | <BR>
<A HREF="isom2005.html#0407" TARGET=body>record type</A> ; 
<P><B>new ordinal type</B>= <A HREF="isom2005.html#0398" TARGET=body>enumeration type</A> | <A HREF="isom2005.html#0399" TARGET=body>subrange type</A> ; 
<P><B>Declaration Semantics</B> 
<P>Each use of a new type shall be a defining occurrence for a type that is distinct from any other type and that has the structure specified by the new type. 
<P><HR>
<A NAME="0073">
<A HREF="#0069" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0072" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0074" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Enumeration Types</H3>

<P>An enumeration type defines a new ordinal type, whose sequence of values is denoted by the sequence of identifiers contained in its identifier list. The identifiers of an enumeration type are introduced into their scope as constant identifiers of the values of the new type. 
<P><B>Concrete Syntax</B> 
<P><B>enumeration type</B>= &quot;(&quot;, <A HREF="isom2005.html#0398" TARGET=body>identifier list</A>, &quot;)&quot; ; 
<P><B>identifier list</B>= identifier, { &quot;,&quot;, identifier } ; 
<P><B>Declaration Semantics</B> 
<P>Each identifier occurring in the identifier list of an enumeration type shall be defined as a constant identifier that is associated with the corresponding value of the unique type established for the new type. 
<P>The type established by an enumeration type shall be an ordinal type. The ordering of the values of an enumeration type shall be determined by the textual order in which the identifiers of the identifier list are written. The ordinal number of the value associated with the <I>i</I>th identifier of the list shall be the value (<I>i</I> - 1) 
<P>annotations A unique type name is generated to denote the new type that is being defined. The identifiers occurring in the identifier list are added to the environment as constants, each constant being associated with the value it denotes. The structure of the new type is also added to the environment. 
<P><B>Static Semantics</B> 
<P>The identifiers occurring in the identifier list of an enumeration type shall be distinct from each other. 
<P><HR>
<A NAME="0074">
<A HREF="#0069" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0073" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0075" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Subrange Types</H3>

<P>A subrange type defines a new ordinal type, whose sequence of values is a subsequence of those defined for an associated ordinal type, called the &lsquo;host type&rsquo; of the subrange type. A subrange type specifies the smallest and the largest values of the ordinal type; a value to be assigned to a variable of a subrange type must lie within the closed interval defined by these two values. The operations that are applicable to operands of a subrange type are those that are applicable to operands of its host type. 
<P>The host type of a subrange type is determined by the type associated with the range of values from the smallest to the largest value. There are rules for choosing a default type for this range in cases where there are alternatives. For example, if the smallest and largest values are both specified by positive whole number literals, the type of the range is assumed to be the unsigned type and not the signed type. Alternatively, a range type may be explicitly specified with the subrange type. 
<P><B>Change:</B> In <I>Programming in Modula-2</I> the term &lsquo;base type&rsquo; is used for the associated ordinal type of both subrange types and set types. In this International Standard, the term &lsquo;base type&rsquo; is only used for set types, and the term &lsquo;host type&rsquo; is used for subrange types. 
<P><B>Concrete Syntax</B> 
<P><B>subrange type</B>= <BR>
[0 pt] [ <A HREF="isom2005.html#0399" TARGET=body>range type</A> ], &quot;[&quot;, <A HREF="isom2005.html#0450" TARGET=body>constant expression</A>, &quot;..&quot;, <A HREF="isom2005.html#0450" TARGET=body>constant expression</A>, &quot;]&quot; ; 
<P><B>range type</B>= <A HREF="isom2005.html#0396" TARGET=body>ordinal type identifier</A> ; 
<P><B>Clarification:</B> A range type may be specified in the definition of a subrange by providing an identifier denoting a previously defined ordinal type. 
<P><B>Abstract Syntax</B> 
<P>annotations If the range type of a subrange type is not explicitly specified, the translation process (from concrete to abstract syntax) supplies a range type according to the table given under Static Semantics below. 
<P><B>Declaration Semantics</B> 
<P>The values of a subrange type shall be the values of the range type that are in the closed interval defined by the &lsquo;lower bound&rsquo; and &lsquo;upper bound&rsquo; of the subrange type. These values shall be specified by the values of the first and second constant expressions, respectively. 
<P>If a type <TT>X</TT> is a subrange type, then its host type shall be the type that is the host type of the range type of the type <TT>X</TT>; otherwise the host type shall be the type <TT>X</TT>. 
<P>The type established by a subrange type shall be an ordinal type. The ordering of the values of a subrange type shall be determined by the ordering of the values of the host type. The ordinal number of a value of a subrange type shall be the same as the ordinal number which the value has in the host type. 
<P>annotations The range type of the subrange is determined, and the range is evaluated. A unique type name is generated to denote the new type that is being defined, and the structure of the new type is added to the environment. 
<P><B>Static Semantics</B> 
<P>The range type of a subrange type shall be an ordinal type. If the range type is explicitly specified by an ordinal type identifier then this type identifier shall be predefined or have a defining occurrence that appears elsewhere; otherwise the range type of the subrange type <TT>[M..N]</TT> shall be determined according to the following table. In the table the type <TT>T</TT> denotes any ordinal type other than a whole number type. 
<P>N unsigned type signed type Z-type the type T unsigned type unsigned type error unsigned type error signed type error signed type signed type error M Z-type unsigned type signed type M&lt;0 signed type error M?0 unsigned type the type T error error error the type T 
<P>Both the type of the first constant expression and the type of the second constant expression shall be expression- compatible with the range type. The lower bound shall be less than or equal to the upper bound, and the bounds shall both be values of the range type. 
<P><HR>
<A NAME="0075">
<A HREF="#0069" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0074" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0076" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Set Types</H3>

<P>A set type defines a new elementary type whose set of values is the power set of an associated ordinal type, called the &lsquo;base type&rsquo; of the set type. Thus each value of a set type is a set whose elements are values of the base type of the set type. 
<P><B>Changes:</B> 
<OL>
 
<LI>In <I>Programming in Modula-2</I> the base type cannot have values that are less than zero. </LI>
<LI>This International Standard does not require a specific representation for set types. In <I>Programming in Modula-2</I> there is some advice to the implementor to restrict the number of values of the base type, so that a value of a set type can be fitted into a small number of words of memory. In this International Standard, this advice is appropriate for packedset types rather than for set types. </LI>
<LI>In <I>Programming in Modula-2</I> the pervasive identifier <TT>BITSET</TT> is the type identifier of a predefined set type, whereas in this International Standard, it is the type identifier of a predefined packedset type. </LI>
</OL>

<P><B>Concrete Syntax</B> 
<P><B>set type</B>= &quot;SET&quot;, &quot;OF&quot;, <A HREF="isom2005.html#0400" TARGET=body>base type</A> ; 
<P><B>base type</B>= <A HREF="isom2005.html#0395" TARGET=body>ordinal type denoter</A> ; 
<P><B>Declaration Semantics</B> 
<P>A new type that is a set type shall define the denoted base type as the base type of the unique set type that is established by the new type. The values of the set type shall be the elements of the power set of the base type of the set type. 
<P>annotations The base type of the set type is elaborated; a unique type name is generated to denote the new type that is being defined; and the structure of the new type is added to the environment. 
<P><B>Static Semantics</B> 
<P>The type denoted by the base type of a set type shall be an ordinal type. If the base type is denoted by an ordinal type identifier, then this type identifier shall be predefined or have a defining occurrence that appears elsewhere; otherwise the base type shall be denoted by a new ordinal type. 
<P><B>Note:</B> An implementation may place a restriction on the number of values of the base type of a set type &mdash; see ???
<P><B>Example:</B> Declaration of set types. All of the following are valid declarations of set types provided that both of the bounds of each subrange type lie within the range of values of the signed type: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;TYPE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s1&nbsp;=&nbsp;SET&nbsp;OF&nbsp;INTEGER&nbsp;[0&nbsp;..&nbsp;N&nbsp;-&nbsp;1]&nbsp;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s2&nbsp;=&nbsp;SET&nbsp;OF&nbsp;INTEGER&nbsp;[1&nbsp;..&nbsp;N]&nbsp;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s3&nbsp;=&nbsp;SET&nbsp;OF&nbsp;INTEGER&nbsp;[N&nbsp;+&nbsp;1&nbsp;..&nbsp;2*N]&nbsp;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s4&nbsp;=&nbsp;SET&nbsp;OF&nbsp;INTEGER&nbsp;[-2*N&nbsp;+&nbsp;1&nbsp;..&nbsp;-N]&nbsp;;
</PRE>

<P><HR>
<A NAME="0076">
<A HREF="#0069" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0075" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0077" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Packedset Types</H3>

<P>A packedset type defines a new elementary type whose set of values is the power set of an associated ordinal type, called the &lsquo;base type&rsquo; of the packedset type. Thus each value of a packedset type is a set whose elements are values of the base type of the packedset type. 
<P>Packedset types have a representation that can be mapped, in a known way, to the individual bits of a machine register for a particular underlying architecture &mdash; see <A HREF="isom2004.html#0322" TARGET=body>Packedset mapping</A>. This leads to the ability to implement operations on values of a packedset type in a very efficient manner. 
<P><B>Note:</B> The pervasive identifier <TT>BITSET</TT> is the type identifier of a predefined packedset type &mdash; see <A HREF="#0206" TARGET=body>The Bitset Type</A>. 
<P><B>Change:</B> Packedset types are not explicitly described in <I>Programming in Modula-2</I> , where all set types are implicitly packedset types. 
<P><B>Concrete Syntax</B> 
<P><B>packedset type</B>= &quot;PACKEDSET&quot;, &quot;OF&quot;, <A HREF="isom2005.html#0400" TARGET=body>base type</A> ; 
<P><B>Declaration Semantics</B> 
<P>A new type that is a packedset type shall define the denoted base type as the base type of the unique packedset type that is established by the new type. The values of the packedset type shall be the elements of the power set of the base type of the packedset type. 
<P>annotations The base type of the packedset type is elaborated; a unique type name is generated to denote the new type that is being defined; and the structure of the new type is added to the environment. 
<P><B>Static Semantics</B> 
<P>The type denoted by the base type of a packedset type shall be an ordinal type. If the base type is denoted by an ordinal type identifier, then this type identifier shall be predefined or have a defining occurrence that appears elsewhere; otherwise the base type shall be denoted by a new ordinal type. 
<P><B>Notes:</B> 
<OL>
 
<LI>Since packedset types are intended to mirror the underlying architecture, an implementation may impose narrow restrictions on the range of values of the base type of a packedset type &mdash; see ???.</LI>
<LI>The representation of packedset types is defined by the semantics of bit-level operations on packedset values which are available by import from the system module <TT>SYSTEM</TT> &mdash; see <A HREF="isom2004.html#0321" TARGET=body>Packedset Functions</A> </LI>
</OL>

<P><HR>
<A NAME="0077">
<A HREF="#0069" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0076" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0078" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Pointer Types</H3>

<P>A pointer type defines a new elementary type. One of the values of every pointer type is called the nil value, and is denoted by the pervasive identifier <TT>NIL</TT>. The values of a pointer type other than the nil value can be used to designate variables of a type called the bound type of the pointer type. A value of a pointer type is frequently obtained by a call to an allocation procedure exported from a storage management module. 
<P><B>Note:</B> The type of the nil value is an anonymous type called the &lsquo;nil type&rsquo;. All pointer types are assignment compatible (and hence value-parameter-compatible) with the nil type &mdash; see <A HREF="#0100" TARGET=body>Assignment Compatibility</A> and <A HREF="#0188" TARGET=body>Value Parameter Compatibility</A>. All pointer types are expression- compatible with the nil type in pointer relational operations &mdash; see <A HREF="#0156" TARGET=body>Pointer Relational Operations</A>. 
<P><B>Concrete Syntax</B> 
<P><B>pointer type</B>= &quot;POINTER&quot;, &quot;TO&quot;, <A HREF="isom2005.html#0402" TARGET=body>bound type</A> ; 
<P><B>bound type</B>= <A HREF="isom2005.html#0395" TARGET=body>type denoter</A> ; 
<P><B>Declaration Semantics</B> 
<P>A new type that is a pointer type shall define the denoted bound type as the bound type of the unique pointer type that is established by the new type. 
<P>annotations The bound type is elaborated; a unique type name is generated to denote the new type being defined; and the structure of the new type is added to the environment. 
<P><B>Static Semantics</B> 
<P>If the bound type of a pointer type is specified by a type identifier, then this type identifier shall be predefined or have a defining occurrence that appears elsewhere; otherwise the bound type shall be specified by a new type. 
<P><B>Note:</B> The declaration of a pointer type may precede the declaration of its bound type &mdash; see <A HREF="#0051" TARGET=body>Declarations</A>. 
<P><HR>
<A NAME="0078">
<A HREF="#0069" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0077" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0079" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Procedure Types</H3>

<P>A procedure type may be either a proper procedure type or a function procedure type. 
<P><B>Concrete Syntax</B> 
<P><B>procedure type</B>= <A HREF="isom2005.html#0403" TARGET=body>proper procedure type</A> | <A HREF="isom2005.html#0403" TARGET=body>function procedure type</A> ; 
<P><UL>
<LI><A HREF="#0079" TARGET=body>Proper Procedure Types</A>
<LI><A HREF="#0080" TARGET=body>Function Procedure Types</A>
<LI><A HREF="#0081" TARGET=body>Formal Parameter Type Lists</A>
<LI><A HREF="#0082" TARGET=body>Variable Formal Types</A>
<LI><A HREF="#0083" TARGET=body>Value Formal Types</A>
</UL>
<P><HR>
<A NAME="0079">
<A HREF="#0078" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0078" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0080" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Proper Procedure Types</H4>

<P>A proper procedure type defines a new elementary type. Each value of the type is a proper procedure, with a declaration level of 0, and with formal parameters that correspond with those defined in the formal parameter type list of the type. 
<P><B>Concrete Syntax</B> 
<P><B>proper procedure type</B>= <BR>
&quot;PROCEDURE&quot;, [ &quot;(&quot;, [ <A HREF="isom2005.html#0404" TARGET=body>formal parameter type list</A> ], &quot;)&quot; ] ; 
<P><B>Declaration Semantics</B> 
<P>A new type that is a proper procedure type shall establish a unique procedure type that has the associated structure of a proper procedure with the number, positions, formal types, and binding of formal parameters specified by the formal parameter type list. 
<P>annotations The type of each of the parameters is elaborated; a unique type name is generated to denote the new type that is being defined; and the structure of the new type is added to the environment. 
<P><HR>
<A NAME="0080">
<A HREF="#0078" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0079" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0081" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Function Procedure Types</H4>

<P>A function procedure type defines a new elementary type. Each value of the type is a function procedure, with a declaration level of 0, with formal parameters that correspond with those defined in the formal parameter type list of the type, and with a result type that is identical to the function result type of the type. 
<P><B>Concrete Syntax</B> 
<P><B>function procedure type</B>= <BR>
&quot;PROCEDURE&quot;, &quot;(&quot;, [ <A HREF="isom2005.html#0404" TARGET=body>formal parameter type list</A> ], &quot;)&quot;, &quot;:&quot;, <A HREF="isom2005.html#0386" TARGET=body>function result type</A> ; 
<P><B>Declaration Semantics</B> 
<P>A new type that is a function procedure type shall establish a unique procedure type that has the associated structure of a function procedure with the number, positions, formal types, and binding of formal parameters specified by the formal parameter type list, and with the result type that is denoted by the function result type of the new type. 
<P>annotations The type of each of the parameters is elaborated; the type of the returned value is elaborated; a unique type name is generated to denote the new type that is being defined; and the structure of the new type is added to the environment. 
<P><B>Static Semantics</B> 
<P>The function result type shall be specified by a type identifier that is predefined or has a defining occurrence that appears elsewhere. 
<P><B>Clarification:</B> In this International Standard, the function result type of a function procedure type can be any elementary type or structured (composite) type. It may be identical to the function procedure type. 
<P><HR>
<A NAME="0081">
<A HREF="#0078" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0080" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0082" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Formal Parameter Type Lists</H4>

<P>A formal parameter type list specifies the number of formal parameters of a procedure type, the formal type of each of these formal parameters, and whether each formal parameter is a value parameter or a variable parameter &mdash; see <A HREF="#0048" TARGET=body>Formal Parameters</A>. 
<P><B>Concrete Syntax</B> 
<P><B>formal parameter type list</B>= <BR>
<A HREF="isom2005.html#0404" TARGET=body>formal parameter type</A>, { &quot;,&quot;, <A HREF="isom2005.html#0404" TARGET=body>formal parameter type</A> } ; 
<P><B>formal parameter type</B>= <BR>
<A HREF="isom2005.html#0404" TARGET=body>variable formal type</A> | <A HREF="isom2005.html#0404" TARGET=body>value formal type</A> ; 
<P><HR>
<A NAME="0082">
<A HREF="#0078" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0081" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0083" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Variable Formal Types</H4>

<P>A variable formal parameter type defines the formal type of a variable formal parameter of a procedure type. 
<P><B>Concrete Syntax</B> 
<P><B>variable formal type</B>= &quot;VAR&quot;, <A HREF="isom2005.html#0405" TARGET=body>formal type</A> ; 
<P><B>Declaration Semantics</B> 
<P>A variable formal type shall define the corresponding formal parameter of the procedure type to be a variable formal parameter of the declared formal type &mdash; see <A HREF="#0084" TARGET=body>Formal Types</A>. 
<P><HR>
<A NAME="0083">
<A HREF="#0078" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0082" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0084" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Value Formal Types</H4>

<P>A value formal parameter type defines the formal type of a value formal parameter of a procedure type. 
<P><B>Concrete Syntax</B> 
<P><B>value formal type</B>= <A HREF="isom2005.html#0405" TARGET=body>formal type</A> ; 
<P><B>Declaration Semantics</B> 
<P>A value formal type shall define the corresponding formal parameter of the procedure type to be a value formal parameter of the declared formal type &mdash; see <A HREF="#0084" TARGET=body>Formal Types</A>. 
<P><HR>
<A NAME="0084">
<A HREF="#0069" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0083" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0085" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Formal Types</H3>

<P>Formal types are used in procedure headings and in procedure types to specify the structure of formal parameters. The structure of a formal parameter may either be a single identified type or an open array of an identified type or of another open array. 
<P><B>Concrete Syntax</B> 
<P><B>formal type</B>= <A HREF="isom2005.html#0396" TARGET=body>type identifier</A> | <A HREF="isom2005.html#0405" TARGET=body>open array formal type</A> ; 
<P><B>open array formal type</B>= &quot;ARRAY&quot;, &quot;OF&quot;, <A HREF="isom2005.html#0405" TARGET=body>open array component type</A> ; 
<P><B>open array component type</B>= <A HREF="isom2005.html#0405" TARGET=body>formal type</A> ; 
<P><B>Change:</B> This International Standard permits multidimensional open array parameters. 
<P><B>Declaration Semantics</B> 
<P>A formal type that is a type identifier shall define the structure of the corresponding formal parameter, or open array component type, to be the single type that is denoted by the type identifier. 
<P>An open array formal type shall define the structure of the corresponding formal parameter, or open array component type, to be an open array with a component type that has the structure defined by the open array component type of the open array formal type. 
<P><B>Static Semantics</B> 
<P>If a formal type is a type identifier, then this type identifier shall be predefined or have a defining occurrence that appears elsewhere. 
<P><B>Clarification:</B> In this International Standard, the defining occurrence of a type identifier used as a formal type may be the definition or declaration of the procedure type in which that formal type occurs; the formal type of a procedure type may thus be of a type that is identical to the procedure type &mdash; see <A HREF="#0054" TARGET=body>Type Declarations</A>. 
<P>If a formal type is an open array formal type, then the type identifier of the open array formal type shall be predefined or have a defining occurrence that appears elsewhere. 
<P><HR>
<A NAME="0085">
<A HREF="#0069" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0084" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0086" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Array Types</H3>

<P>An array type defines a new structured (composite) type. An array type is a mapping from a set of values defined by an index type onto a set of distinct components. Each one of these components has the same type, called the component type of the array type. 
<P><B>Concrete Syntax</B> 
<P><B>array type</B>= &quot;ARRAY&quot;, <A HREF="isom2005.html#0406" TARGET=body>index type</A>, { &quot;,&quot;, <A HREF="isom2005.html#0406" TARGET=body>index type</A> }, &quot;OF&quot;, <A HREF="isom2005.html#0406" TARGET=body>component type</A> ; 
<P><B>index type</B>= <A HREF="isom2005.html#0395" TARGET=body>ordinal type denoter</A> ; 
<P><B>component type</B>= <A HREF="isom2005.html#0395" TARGET=body>type denoter</A> ; 
<P>The concrete syntax allows for a full or abbreviated form of array type in cases where a component type is itself an array type. In the abbreviated form, a single comma shall replace the sequence &lsquo;<TT>OF&nbsp;ARRAY</TT>&rsquo; that occurs in the full form. The abbreviated form and the full form shall be equivalent. 
<P><B>Example:</B> Abbreviated form for array of array types. An array type of the form: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;ARRAY&nbsp;MonthType&nbsp;OF&nbsp;ARRAY&nbsp;[1&nbsp;..&nbsp;31]&nbsp;OF&nbsp;CARDINAL
</PRE>

<P>may be abbreviated to: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;ARRAY&nbsp;MonthType,&nbsp;[1&nbsp;..&nbsp;31]&nbsp;OF&nbsp;CARDINAL
</PRE>

<P><B>Abstract Syntax</B> 
<P>annotations The abstract syntax only uses the full form. 
<P><B>Declaration Semantics</B> 
<P>If the index type ordinal type denoter of an array type (in its full form) is a new ordinal type, a corresponding new ordinal type shall be established for the index type; otherwise, if the index type ordinal type denoter is a type identifier, the index type shall be the corresponding identified type. 
<P>If the component type denoter of an array type (in its full form) is a new type, a corresponding new type shall be established for the component type; otherwise, if the component type denoter is a type identifier, the component type shall be the corresponding identified type. 
<P>The array type (denoter) shall establish a unique array type that has the specified index type and component type. 
<P>The type of each component of the array type shall be the component type of the array type. 
<P>annotations The types of the index and components are elaborated; a unique type name is generated to denote the new type that is being defined; and the structure of the new type is added to the environment. 
<P><B>Static Semantics</B> 
<P>The index type of an array type shall be an ordinal type. If the index type is specified by an ordinal type identifier, then this type identifier shall be predefined or have a defining occurrence that appears elsewhere; otherwise the index type shall be specified by a new type that is an enumeration type or a subrange type. If the component type of an array type is specified by a type identifier, then this type identifier shall be predefined or have a defining occurrence that appears elsewhere; otherwise the component type shall be specified by a new type. 
<P><B>Note:</B> If the index type of an array type is an enumeration type, the enumeration constant identifiers that are thereby declared may be used in the component type of the array type. 
<P><HR>
<A NAME="0086">
<A HREF="#0069" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0085" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0087" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Record Types</H3>

<P>A record type defines a new structured (composite) type. Each value of the type has a collection of components. These components, called the fields of the record type, may be of different types. The individual fields of a value or variable of a record type are selected by their names (called field identifiers). A record type may specify that some groups of fields (called fixed fields) are always to be present in values and variables of that type. A record type may specify that other groups of fields (called variant fields) include alternatives (called variants) whose presence within a value or variable of that type depends upon the value of another field (called the tag field). The variant that applies, given the value of the tag field, is called the &lsquo;active variant&rsquo;. 
<P><B>Concrete Syntax</B> 
<P><B>record type</B>= &quot;RECORD&quot;, <A HREF="isom2005.html#0407" TARGET=body>field list</A>, &quot;END&quot; ; 
<P><B>field list</B>= <A HREF="isom2005.html#0407" TARGET=body>fields</A>, { &quot;;&quot;, <A HREF="isom2005.html#0407" TARGET=body>fields</A> } ; 
<P><B>fields</B>= [ <A HREF="isom2005.html#0408" TARGET=body>fixed fields</A> | <A HREF="isom2005.html#0409" TARGET=body>variant fields</A> ] ; 
<P><B>Declaration Semantics</B> 
<P>A new type that is a record type shall establish a unique record type that has the structure of the group or groups of fields specified by the record type field list. Any enumeration constant identifiers introduced by enumeration types within a group of fields shall be defined for possible use within subsequent groups of fields. 
<P>annotations The type of each of the components of the record is elaborated; a unique type name is generated to denote the new type that is being defined; and the structure of the new type is added to the environment. 
<P><B>Static Semantics</B> 
<P>All the field identifiers of a record type shall be distinct. 
<P><UL>
<LI><A HREF="#0087" TARGET=body>Fixed Fields</A>
<LI><A HREF="#0088" TARGET=body>Variant Fields</A>
</UL>
<P><HR>
<A NAME="0087">
<A HREF="#0086" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0086" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0088" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Fixed Fields</H4>

<P>A group of fields specified as fixed fields of a record type share the same field type; the group shall always be present in values and variables of the record type, unless the group is part of an inactive variant. 
<P><B>Concrete Syntax</B> 
<P><B>fixed fields</B>= <A HREF="isom2005.html#0398" TARGET=body>identifier list</A>, &quot;:&quot;, <A HREF="isom2005.html#0408" TARGET=body>field type</A> ; 
<P><B>field type</B>= <A HREF="isom2005.html#0395" TARGET=body>type denoter</A> ; 
<P><B>Declaration Semantics</B> 
<P>If the field type of a group of fixed fields is a new type, a corresponding new type shall be established which shall be the type of each field in the group of fixed fields; otherwise, if the field type is a type identifier, the type of each field shall be the corresponding identified type. 
<P>annotations The type of the fixed fields component of the record is elaborated; a unique type name is generated to denote any new type that may be defined; the result is the structure of the component. 
<P><B>Static Semantics</B> 
<P>If the field type of a group of fixed fields is specified by a type identifier, this type identifier shall be predefined or have a defining occurrence that appears elsewhere; otherwise the field type shall be specified by a new type. 
<P><HR>
<A NAME="0088">
<A HREF="#0086" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0087" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0089" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Variant Fields</H4>

<P>A groups of fields specified as variant fields of a record type include alternatives (called variants) whose presence within a value or variable of that type depends upon the value of another field (called the tag field). The variant that applies, given the value of the tag field, is called the &lsquo;active variant&rsquo;. 
<P><B>Concrete Syntax</B> 
<P><B>variant fields</B>= &quot;CASE&quot;, <A HREF="isom2005.html#0409" TARGET=body>tag field</A>, &quot;OF&quot;, <A HREF="isom2005.html#0409" TARGET=body>variant list</A>, &quot;END&quot; ; 
<P><B>tag field</B>= [ <A HREF="isom2005.html#0409" TARGET=body>tag identifier</A> ], &quot;:&quot;, <A HREF="isom2005.html#0409" TARGET=body>tag type</A> ; 
<P><B>tag identifier</B>= identifier ; 
<P><B>tag type</B>= <A HREF="isom2005.html#0396" TARGET=body>ordinal type identifier</A> ; 
<P><B>variant list</B>= <A HREF="isom2005.html#0409" TARGET=body>variant</A>, { &quot;|&quot;, <A HREF="isom2005.html#0409" TARGET=body>variant</A> }, [ <A HREF="isom2005.html#0409" TARGET=body>variant else part</A> ] ; 
<P><B>variant else part</B>= &quot;ELSE&quot;, <A HREF="isom2005.html#0407" TARGET=body>field list</A> ; 
<P><B>Declaration Semantics</B> 
<P>The tag type of a group of variant fields shall be the ordinal type denoted by the tag type ordinal type identifier. If present, the tag identifier shall be defined as the field identifier of the tag field; otherwise, the group of variant fields shall not have an identifiable tag field. 
<P>The variants of a group of variant fields shall have the structure specified by each variant of the variant list and, if present, the variant else part. Any enumeration constant identifiers introduced by enumeration types within a variant shall be defined for possible use within subsequent variants, including a variant else part. 
<P>The variant else part, if present, shall have the structure of the group or groups of fields specified by the variant else part field list. 
<P>annotations The type of the tag field of the variant field is obtained; the structures of the variant components and of the optional variant else part list component are elaborated; the result is the structure of the component. 
<P><B>Static Semantics</B> 
<P>The tag type of a group of variant fields shall be an ordinal type. The tag type shall be specified by an ordinal type identifier that is predefined or has a defining occurrence that appears elsewhere. The types of the constant expressions of the variant label list of each variant shall be expression compatible with the tag type. 
<P>The values contained in different variant label lists of a variant shall be distinct from each other. 
<P><B>Note:</B> In addition to the requirement that the values contained in different variant label lists of a variant shall be distinct from each other, it is also required that the values contained in each variant label list shall be distinct from each other. 
<P><B>Example:</B> Duplication of variant labels in record declarations. The alternatives illustrated in the following source code are illegal for the reasons given in the associated comments. 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;TYPE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TagRange&nbsp;=&nbsp;[1..19];
&nbsp;&nbsp;&nbsp;&nbsp;RECORD
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CASE&nbsp;TagFieldIdentifier&nbsp;:&nbsp;TagRange&nbsp;OF
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*a*)&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(*&nbsp;duplicate&nbsp;of&nbsp;label&nbsp;in&nbsp;list&nbsp;d&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*b*)&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(*&nbsp;label&nbsp;11&nbsp;in&nbsp;b&nbsp;duplicated&nbsp;in&nbsp;range&nbsp;11..13&nbsp;in&nbsp;list&nbsp;i&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*c*)&nbsp;15..17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(*&nbsp;range&nbsp;15..17&nbsp;in&nbsp;c&nbsp;overlaps&nbsp;with&nbsp;range&nbsp;16..19&nbsp;in&nbsp;list&nbsp;j&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*d*)&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(*&nbsp;duplicate&nbsp;of&nbsp;label&nbsp;in&nbsp;list&nbsp;a&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*e*)&nbsp;2,&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(*&nbsp;label&nbsp;2&nbsp;is&nbsp;duplicated&nbsp;in&nbsp;list&nbsp;e&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*f*)&nbsp;3..5,&nbsp;3..5&nbsp;&nbsp;:&nbsp;(*&nbsp;range&nbsp;3..5&nbsp;is&nbsp;duplicated&nbsp;in&nbsp;list&nbsp;f&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*g*)&nbsp;6,&nbsp;6..7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(*&nbsp;label&nbsp;6&nbsp;duplicated&nbsp;in&nbsp;range&nbsp;6..7&nbsp;in&nbsp;list&nbsp;g&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*h*)&nbsp;8..9,&nbsp;8..10&nbsp;:&nbsp;(*&nbsp;range&nbsp;8..9&nbsp;overlaps&nbsp;range&nbsp;8..10&nbsp;in&nbsp;list&nbsp;h&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*i*)&nbsp;11..13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(*&nbsp;label&nbsp;11&nbsp;in&nbsp;b&nbsp;duplicated&nbsp;in&nbsp;range&nbsp;11..13&nbsp;in&nbsp;list&nbsp;i&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*j*)&nbsp;16..19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(*&nbsp;range&nbsp;15..17&nbsp;in&nbsp;c&nbsp;overlaps&nbsp;with&nbsp;range&nbsp;16..19&nbsp;in&nbsp;list&nbsp;j&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END
&nbsp;&nbsp;&nbsp;&nbsp;END
</PRE>

<P>If there is no variant else part, there shall be a value contained in the variant label lists for each value of the tag type. 
<P><B>Example:</B> Coverage of variant labels in record declarations. The requirement that if there is no variant else part there shall be a value contained in the variant label lists for each value of the tag type means that example (a) is illegal, whereas examples (b) and (c) are legal. 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;(a)			&nbsp;(b)			&nbsp;(c)
&nbsp;&nbsp;&nbsp;&nbsp;RECORD		&nbsp;RECORD			&nbsp;RECORD
&nbsp;&nbsp;&nbsp;&nbsp;CASE&nbsp;:&nbsp;INTEGER&nbsp;OF	&nbsp;CASE&nbsp;:&nbsp;INTEGER&nbsp;OF	&nbsp;CASE&nbsp;:&nbsp;INTEGER&nbsp;OF
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1:&nbsp;x:&nbsp;BOOLEAN	&nbsp;|&nbsp;1:&nbsp;x:&nbsp;BOOLEAN	&nbsp;|&nbsp;1:&nbsp;x:&nbsp;BOOLEAN
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2:&nbsp;y:&nbsp;CARDINAL	&nbsp;|&nbsp;2:&nbsp;y:&nbsp;CARDINAL	&nbsp;|&nbsp;2:&nbsp;y:&nbsp;CARDINAL
&nbsp;&nbsp;&nbsp;&nbsp;END			&nbsp;ELSE&nbsp;(*empty*)		&nbsp;|&nbsp;MIN(INTEGER)..0:&nbsp;(*empty*)
&nbsp;&nbsp;&nbsp;&nbsp;END			&nbsp;END			&nbsp;|&nbsp;3..MAX(INTEGER):&nbsp;(*empty*)
&nbsp;&nbsp;&nbsp;			&nbsp;END			&nbsp;END
&nbsp;&nbsp;&nbsp;						&nbsp;END
</PRE>

<P><B>Variants</B> 
<P>A variant specifies the value or values of the tag field for which the variant is to be active, and the group or groups of fields that are present when the variant is active. 
<P><B>Concrete Syntax</B> 
<P><B>variant</B>= [ <A HREF="isom2005.html#0409" TARGET=body>variant label list</A>, &quot;:&quot;, <A HREF="isom2005.html#0407" TARGET=body>field list</A> ] ; 
<P><B>variant label list</B>= <A HREF="isom2005.html#0409" TARGET=body>variant label</A>, { &quot;,&quot;, <A HREF="isom2005.html#0409" TARGET=body>variant label</A> } ; 
<P><B>variant label</B>= <A HREF="isom2005.html#0450" TARGET=body>constant expression</A>, [ &quot;..&quot;, <A HREF="isom2005.html#0450" TARGET=body>constant expression</A> ] ; 
<P><B>Abstract Syntax</B> 
<P>annotations The translation process (from concrete to abstract syntax) will ensure that the number of members in the labels component of a Variant component of the abstract representation is equal to the number of variant labels in the variant label list of the concrete representation. 
<P><B>Declaration Semantics</B> 
<P>The values of the tag field for which the variant is to be active shall be the set of values contained in the variant label list. A value shall be contained in a variant label list if it is equal to the value of one of the constant expressions of the variant label list, or if the value lies within the range specified by a pair of constant expressions of the variant label list. 
<P>The group or groups of fields that are present when the variant is active shall be the those specified by the variant field list. 
<P>annotations The value of the labels that are associated with the variant are evaluated; the structures of the fields are elaborated; and the result is the structure of the component. 
<P><B>Static Semantics</B> 
<P>Each variant label shall be a constant expression, or a range indicated by a pair of constant expressions. The values contained in a variant label list shall be distinct from each other. 
<P><B>Auxiliaries</B> 
<P>annotations Check that all the field identifiers of a field list are distinct. 
<P>annotations The result of this function is a sequence containing the field identifiers of a record type. The order of the identifiers in the sequence is identical to the order in which they occur in the record type. 
<P>annotations The result of this function is a sequence containing the field identifiers of a fixed fields or a variant fields. The order of the identifiers in the sequence is identical to the order in which they occur in the fixed fields or variant fields. 
<P>annotations The result of this function is a sequence containing the field identifiers of a variant field component of a record. The order of the identifiers in the sequence is identical to the order in which they occur in the variant field component. 
<P>annotations The result of this function is a sequence containing the field identifiers of a variant component of a variant field of a record. The order of the identifiers in the sequence is identical to the order in which they occur in the variant component. 
<P>annotations Check that all of the variant labels are expression-compatible with the tag type. 
<P>annotations Check that the sets of values defined by each of the variant label lists are disjoint. 
<P>annotations Check that there is a value contained in the variant label lists for each value of the tag type. 
<P><HR>
<A NAME="0089">
<A HREF="#0069" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0088" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0090" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Storage Allocation</H3>

<P>Program storage is allocated during the elaboration of variable declarations and during the binding of actual parameters to formal parameters that occurs on procedure calls. 
<P>annotations Note that a value of type <I>Type</I> has been replaced by a value of type <I>Typed</I> at this point | information on the type defined in the environment is used for storage allocation, rather than the type information defined by the source code. 
<P><UL>
<LI><A HREF="#0090" TARGET=body>Allocating Storage for Constructed Types</A>
<LI><A HREF="#0091" TARGET=body>Allocating Storage for Elementary Types</A>
<LI><A HREF="#0095" TARGET=body>Allocating Storage for Structured (Composite) Types</A>
</UL>
<P><HR>
<A NAME="0090">
<A HREF="#0089" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0089" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0091" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Allocating Storage for Constructed Types</H4>

<P>annotations Identifiers that have been declared as identifiers of variables or parameters of a constructed type have their type name looked up in the environment to give their structure, and storage is allocated for this structure. 
<P><HR>
<A NAME="0091">
<A HREF="#0089" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0090" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0092" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Allocating Storage for Elementary Types</H4>

<P><A NAME="0092">
<A HREF="#0091" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0091" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0093" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Allocating Storage for Basic Types</H5>

<P>All basic types are elementary types | see 6.10.2. 
<P>annotations The storage for a whole-number variable is tagged withthe values included in the whole-number type; there are no individual storage-allocation functions for other basic types since they have no associated structure. 
<P><A NAME="0093">
<A HREF="#0091" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0092" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0094" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Allocating Storage for Subrange Types</H5>

<P>annotations The storage for a subrange variable is tagged with the values included in the subrange. 
<P><A NAME="0094">
<A HREF="#0091" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0093" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0095" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Allocating Storage for Pointer Types</H5>

<P>annotations The storage for a pointer variable is tagged with the type of the bound type of the pointer type. 
<P><HR>
<A NAME="0095">
<A HREF="#0089" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0094" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0096" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Allocating Storage for Structured (Composite) Types</H4>

<P>The meaning given to programs by this International Standard is independent of any particular layout strategy in mapping components of a variable of a structured (composite) type onto the addressable locations of an underlying computer system. The storage model of this International Standard, therefore allocates storage for each component of a variable of a structured (composite) type independently of any other components of that variable. 
<P><B>Note:</B> Conforming implementations are required to document the layout strategy that is used for a particular target computer system &mdash; see ???.
<P><A NAME="0096">
<A HREF="#0095" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0095" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0097" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Allocating Storage for Array Types</H5>

<P><B>Dynamic Semantics</B> 
<P>The allocation of storage for a variable of an array structure shall allocate storage for each component of the array structure such that each component may be accessed using an indexed designator | see 6.7.2. 
<P>annotations The result is an array variable, which is a mapping from each value in the set specified by its index type to a distinct variable whose type is the component type of the array type. 
<P><A NAME="0097">
<A HREF="#0095" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0096" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0098" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Allocating Storage for Record Types</H5>

<P><B>Dynamic Semantics</B> 
<P>The allocation of storage for a variable of a record structure shall allocate storage for each group of fixed fields of the record structure such that each field may be accessed using a selected designator &mdash; see <A HREF="#0140" TARGET=body>Selected Designators</A>. 
<P>The allocation of storage for a variable of a record structure shall allocate storage for each group of variant fields of the record structure such that each field of the active variant, and the tag field, if present, may be accessed using a selected designator &mdash; see <A HREF="#0140" TARGET=body>Selected Designators</A>. 
<P><B>Note:</B> In the case of a group of variant fields with an identified tag field, storage is allocated for the tag field and the active variant is determined by the value of that field. If there is no identified tag field, the storage model in this International Standard constructs an implicit tag field so that it can be specified that an exception occurs if a field of an inactive variant is accessed by a value designator &mdash; see <A HREF="#0165" TARGET=body>Selected Values</A>. 
<P>annotations The result is a record variable that consists of a mapping from the identifier field names to the associated storage. 
<P><B>Allocating Storage for Fields</B> 
<P>annotations The result is a record variable that consists of a mapping from the identifier field names to the associated storage. 
<P><B>Allocating Storage for Fixed Fields</B> 
<P>annotations The result is a record variable that consists of a mapping from the identifier field names to the associated storage. 
<P><B>Allocating Storage for Implicitly Tagged Variants</B> 
<P>annotations Allocate storage for each of the components of a variant fields component of a variant record. 
<P>annotations Construct a tagged variable from the tag location and the range of values associated with that variant component. 
<P><B>Allocating Storage for Explicitly Tagged Variants</B> 
<P>annotations Allocate a storage location for the tag field. Allocate storage for each variant, and for the variant else part if it is present. 
<P>annotations Construct a mapping that associates a variant variable with each of the label values of a variant component. 
<P><B>Auxiliaries</B> 
<P>annotations Construct a sequence of variant structures from a sequence of variants. 
<P>annotations Allocate storage space for the variant else part if it is present. 
<P>
<P><HR>
<A NAME="0098">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0097" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0099" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Expression and Assignment Compatibility</H2>

<P>The concept of compatibility between entities of possibly differing type is fundamental to Modula-2. Expression compatibility determines the types that may be combined in forming expressions; assignment compatibility determines, for a given type of variable, the type or types of the values of expressions that may be assigned to variables of that type. 
<P>There is a third form of compatibility, called &lsquo;parameter compatibility&rsquo;, which determines for a given type and structure of formal parameter, the type and structure of the actual parameters that may be passed to formal parameters of that type and structure &mdash; see <A HREF="#0187" TARGET=body>Parameter Compatibility</A>. 
<P><UL>
<LI><A HREF="#0099" TARGET=body>Expression Compatibility</A>
<LI><A HREF="#0100" TARGET=body>Assignment Compatibility</A>
</UL>
<P><HR>
<A NAME="0099">
<A HREF="#0098" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0098" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0100" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Expression Compatibility</H3>

<P>Modula-2 limits the types that may be combined in forming expressions to identical types except that there are special rules where subrange types are involved and where literal values are involved. Expression compatibility is a symmetric relation &mdash; a type of an expression T e1 is expression compatible with a type of an expression T e2 if T e 2 is expression compatible with T e1 . 
<P><B>Static Semantics</B> 
<P>The types of two expressions shall be expression-compatible if any of the following statements is true: 
<P>a) The types are identical types. 
<P>b) One type is a complex number type and the other type is the C -type. 
<P>c) One type is a real number type and the other type is the R-type. 
<P>d) One type is a whole number type and the other type is the Z-type. 
<P>e) One type is the character type and the other type is the character literal type (the string literal type of length 0 or of length 1). 
<P><B>Change:</B> In <I>Programming in Modula-2</I> a string literal of length 0 represents the empty string only and the character type is not expression-compatible with the type of the empty string. 
<P><B>Notes:</B> 
<OL>
 
<LI>A value of a subrange type is also a value of the host type of that subrange type, and the type of expressions that are value designators, or function calls, is defined in terms of the host type of any subrange type that might otherwise apply &mdash; see <A HREF="#0162" TARGET=body>Value Designators</A> and <A HREF="#0167" TARGET=body>Function Calls</A>. Values of subranges of the same host type are therefore expression compatible with each other, and with that host type, under rule <A HREF="#0099" TARGET=body>Expression Compatibility</A>a. </LI>
<LI>There are other special cases of expression compatibility for pointer relational operations and for procedure relational operations; these are dealt with where they arise &mdash; see <A HREF="#0151" TARGET=body>Relational Operations</A>. </LI>
</OL>

<P>annotations The &lsquo;<I>t-</I>...&rsquo; functions used in applications of the function <I>is-expression-compatible</I> return the host type for values of a subrange type; thus this function does not need to deal with special rules for subrange types. In parts of the formal definition, expression compatibility between the types of two expressions, <I>expra</I> and <I>exprb</I>, is tested using relations of the form <I>t-expression (expra )? = t-expression (exprb)?</I> 
<P><HR>
<A NAME="0100">
<A HREF="#0098" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0099" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0101" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Assignment Compatibility</H3>

<P>Modula-2 limits the types of value that may be assigned to a variable to identical types except that there are special rules for subrange types, literal values, whole number types, and the address type. Assignment compatibility is not a symmetric relation since the types of variables and of values are treated differently. 
<P>Within a procedure block, formal parameters are treated as variables to which assignments may be made. However, formal parameters are of a formal type and may have the structure of an open array | see 6.3.10. No direct assignments to open array formal parameters may be made, even from another open array formal parameter of identical structure. 
<P><B>Static Semantics</B> 
<P>The type T v of a variable denoted by a variable designator shall be assignment-compatible with the type T e of the value of an expression if any of the following statements is true: 
<P>a) T v is identical to the type T e and that type is not a formal type having an open array structure. 
<P>b) T v is a subrange of the type T e . 
<P>c) T v is the unsigned type or a subrange of the unsigned type and T e is the signed type or is the Z-type. 
<P>d) T v is the signed type or a subrange of the signed type and T e is the unsigned type or is the Z-type. 
<P>e) T v is a real number type and T e is the R-type. 
<P>f ) T v is a complex number type and T e is the C -type. 
<P>g) T v is a pointer type and T e is the nil type. 
<P>h) T v is a proper procedure type or a function procedure type, and the expression designates a procedure value, or procedure constant value, of a procedure that has the same structure as the procedure type T v , and that has been declared at declaration level 0. 
<P>i) T v is the character type, or a subrange of the character type, and T e is the character literal type (the string literal type of length 0 or of length 1). 
<P>j) T v is an array type having the character type as its component type and T e is the string literal type of length less than or equal to the number of components in arrays of the type T v . 
<P>k) T v is the address type and T e is a pointer type, or T v is a pointer type and T e is the address type. 
<P><B>Notes:</B> 
<OL>
 
<LI>A variable designator only occurs on the left-hand side of an assignment statement, or as an actual parameter that corresponds to a variable formal parameter; only the first of these uses is relevant to assignment compatibility. Variable identifiers that occur in expressions are <I>value</I> designators. </LI>
<LI>The component type of a concrete string type is the character type. Since it must be possible to assign the value of the character type that has been defined by an implementation as its string terminating character to a component of a concrete string variable, a quoted string is not assignment-compatible with an array whose component type is a subrange of the character type. </LI>
</OL>

<P><B>Changes:</B> 
<OL>
 
<LI>In <I>Programming in Modula-2</I> a string literal of length zero represents the empty string only and the character type is not assignment-compatible with the type of the empty string. </LI>
<LI>A concrete string type, i.e. an array whose component type is the character type, that is either the target of a string assignment, or a formal parameter to which a string is passed as an actual parameter, may have an index type of any ordinal type. </LI>
</OL>

<P><B>Clarification:</B> This International Standard has not adopted a change to Modula-2 (described in the fourth edition of <I>Programming in Modula-2</I> ) of always requiring a string terminator for a string value. The length of a string literal may therefore equal the number of components in an array to which it is assigned. 
<P>annotations The type of the variable designator and the type of the expression are identical. The result type of the expression is not an open array type. 
<P>annotations The type of the variable designator is a subrange of the type of the expression. 
<P>annotations The type of the variable designator is the unsigned type or a subrange of the unsigned type, and the type of the expression is the signed type or Z-type. 
<P>annotations The type of the variable designator is the signed type or a subrange of the signed type, and the type of the expression is the unsigned type or Z-type. 
<P>annotations The type of the variable designator is a real type and the type of the expression is the R-type. 
<P>annotations The type of the variable designator is a complex type and the type of the expression is the C -type. 
<P>annotations The type of the variable designator is a pointer type and the type of the expression is the nil type. 
<P>annotations The type of the variable designator is a proper procedure type or function procedure type, and the type of the expression is a proper procedure or function procedure value with the same structure, declared at level 0. 
<P>annotations The type of the variable designator is a character type, and the type of the expression is the character literal type. 
<P>annotations The type of the variable for string literal assignment is an array of characters. The result of the expression is a string literal, and the length of the string literal is less than or equal to the number of elements in the array associated with the type ltype . 
<P>annotations The type of the variable is the address type, and the result of the expression is a pointer type, or vice-versa.  
<P><HR>
<A NAME="0101">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0100" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0102" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Blocks</H2>

<P>Blocks consist of a possibly empty sequence of declarations which may be followed by a body; they are a component of program modules, implementation modules, local modules, and full procedure declarations. The body contains the statements that are to be executed when a module is initialized or finalized, or when a procedure is activated. 
<P>The presence of a body is required only for function procedure blocks; the bodies of function procedures return a result value whereas the bodies of modules and of proper procedures do not return a result value. 
<P>The presence of a body is marked by the keyword <TT>BEGIN</TT> which is followed by a block body. In the case of module blocks, the block body marked by the keyword <TT>BEGIN</TT> is the initialization body; it may be followed by a finalization body, marked by the keyword <TT>FINALLY</TT>. Block bodies have a normal part and, optionally, an exceptional part to handle exceptions raised during execution of the normal part. 
<P>The execution of the block bodies of protected modules and of protected procedures is protected from the occurrence of interrupts &mdash; see <A HREF="#0039" TARGET=body>Protected Modules</A>. 
<P><UL>
<LI><A HREF="#0102" TARGET=body>Proper Procedure Blocks</A>
<LI><A HREF="#0103" TARGET=body>Function Procedure Blocks</A>
<LI><A HREF="#0104" TARGET=body>Module Blocks</A>
<LI><A HREF="#0105" TARGET=body>Static Module Initialization</A>
<LI><A HREF="#0106" TARGET=body>Static Module Finalization</A>
<LI><A HREF="#0107" TARGET=body>Dynamic Module Initialization</A>
<LI><A HREF="#0108" TARGET=body>Dynamic Module Finalization</A>
<LI><A HREF="#0109" TARGET=body>Block Bodies and Exception Handling</A>
</UL>
<P><HR>
<A NAME="0102">
<A HREF="#0101" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0101" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0103" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Proper Procedure Blocks</H3>

<P>A proper procedure block defines the sequence of declarations and the optional procedure body that are associated with the proper procedure identifier. On a call of the procedure, the initialization bodies of any local modules declared in the declarations are executed. If a procedure body is present, it is then executed in an environment that includes identifiers introduced in the declarations of the procedure block. 
<P><B>Concrete Syntax</B> 
<P><B>proper procedure block</B>= <A HREF="isom2005.html#0388" TARGET=body>declarations</A>, [ <A HREF="isom2005.html#0411" TARGET=body>procedure body</A> ], &quot;END&quot; ; 
<P><B>procedure body</B>= &quot;BEGIN&quot;, <A HREF="isom2005.html#0414" TARGET=body>block body</A> ; 
<P><B>Abstract Syntax</B> 
<P>annotations In the translation from concrete to abstract syntax, a proper procedure block without a procedure body is repre- sented by a <I>Proper-procedure-block</I> with a nil value for the <I>body</I> component. 
<P><B>Static Semantics</B> 
<P>If present, the block body of a proper procedure block shall be a well-formed block body that does not return a result. 
<P><B>Dynamic Semantics</B> 
<P>If there are local modules contained in the declarations of the proper procedure block, they shall be initialized in the textual order in which they occur &mdash; see <A HREF="#0107" TARGET=body>Dynamic Module Initialization</A>. 
<P>On the execution of a proper procedure block that is not protected and does not have an exceptional part, the procedure body shall be executed in the state of exceptional execution or in the state of normal execution, according to the state of execution of the caller of the procedure. 
<P><B>Note:</B> If the procedure block has no exceptional part, the exceptional part that is the current exception handler is found as follows: 
<UL>
 
<LI>If the procedure has been called, directly or indirectly, from a normal part of another procedure block, or from the initialization body or finalization body of a module block, and the calling procedure or module block has an exceptional part, then that exceptional part will be the current exception handler. </LI>
<LI>If the procedure has been called, directly or indirectly, from the exceptional part of a static module, no exceptional part will be the current exception handler. </LI>
<LI>If the procedure has been called, directly or indirectly, from the exceptional part of another procedure, the current exception handler will be the exception handler for the caller of that other procedure. </LI>
<LI>If the procedure has been called, directly or indirectly, from the exceptional part of a dynamic module, the current exception handler will be the exception handler for the caller of the procedure in which the dynamic module is declared. </LI>
</UL>

<P>If the procedure block has no exceptional part, and no other exceptional part is the current exception handler, the raising of an exception during the execution of the normal part is a termination event &mdash; see <A HREF="#0028" TARGET=body>Program Termination</A>. 
<P>On completion of the execution of the procedure body, if there are local modules contained in the declarations of the proper procedure block, they shall be finalized in the reverse order of their initialization &mdash; see <A HREF="#0108" TARGET=body>Dynamic Module Finalization</A>. 
<P>If an exception is raised during execution of the procedure body the local dynamic modules shall not be finalized. 
<P>If the procedure is a protected procedure, the protection domain shall be entered before the local dynamic modules are initialized and shall be left after the local dynamic modules have been finalized. 
<P>If an exception is raised during execution of the procedure body the protection domain shall not be left. 
<P>On the execution of a proper procedure block that has an exceptional part, the procedure body shall be executed in the state of normal execution. 
<P>On completion of the execution of the block body, the execution state shall revert to that which applied before the execution of the block body. 
<P>If execution of the procedure body completed in the state of exceptional execution, the exception shall be re-raised after the local dynamic modules have been finalized. 
<P>If an exception is raised during execution of the exceptional part of the procedure body, the local dynamic modules shall not be finalized. 
<P>On the execution of a proper procedure block that is protected and whose body has an exceptional part, if execution of the procedure body completes in the state of exceptional execution, the exception shall be re-raised after the protection domain has been left. 
<P>If an exception is raised during execution of the exceptional part of the procedure body, the protection domain shall not be left. 
<P><HR>
<A NAME="0103">
<A HREF="#0101" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0102" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0104" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Function Procedure Blocks</H3>

<P>A function procedure block defines the sequence of declarations and the procedure body that are associated with the procedure identifier. On a call of the procedure, the initialization bodies of any local modules declared in the declarations are executed. The procedure body is then executed in an environment that includes identifiers introduced in the declarations of the procedure block. 
<P><B>Concrete Syntax</B> 
<P><B>function procedure block</B>= <A HREF="isom2005.html#0388" TARGET=body>declarations</A>, <A HREF="isom2005.html#0412" TARGET=body>function body</A>, &quot;END&quot; ; 
<P><B>function body</B>= &quot;BEGIN&quot;, <A HREF="isom2005.html#0414" TARGET=body>block body</A> ; 
<P><B>Change:</B> <I>Programming in Modula-2</I> allows the body of a function procedure to be empty, but the well-formed rules in this International Standard demand at least one return statement. The concrete syntax has been changed to reflect this. 
<P><B>Static Semantics</B> 
<P>The block body of a function procedure block shall be a well-formed block body that returns a result. 
<P><B>Dynamic Semantics</B> 
<P>If there are local modules contained in the declarations of the procedure block, they shall be initialized in the textual order in which they occur &mdash; see <A HREF="#0107" TARGET=body>Dynamic Module Initialization</A>. 
<P>On the execution of a function procedure block, that is not protected and does not have an exceptional part, the procedure body shall be executed in the state of exceptional execution or in the state of normal execution, according to the state of execution of the caller of the procedure. 
<P><B>Note:</B> If the procedure block has no exceptional part, the exceptional part that is the current exception handler is found as follows: 
<UL>
 
<LI>If the procedure has been called, directly or indirectly, from an normal part of another procedure block, or from the initialization body or finalization body of a module block, and the calling procedure or module block has an exceptional part, then that exceptional part will be the current exception handler. </LI>
<LI>If the procedure has been called, directly or indirectly, from the exceptional part of a static module, no exceptional part will be the current exception handler. </LI>
<LI>If the procedure has been called, directly or indirectly, from the exceptional part of another procedure, the current exception handler will be the exception handler for the caller of that other procedure. </LI>
<LI>If the procedure has been called, directly or indirectly, from the exceptional part of a dynamic module, the current exception handler will be the exception handler for the caller of the procedure in which the dynamic module is declared. </LI>
</UL>

<P>If the procedure block has no exceptional part, and no other exceptional part is the current exception handler, the raising of an exception during the execution of the normal part is a termination event &mdash; see <A HREF="#0028" TARGET=body>Program Termination</A>. 
<P>On completion of the execution of the procedure body, if there are local modules contained in the declarations of the procedure block, they shall be finalized in the reverse order of their initialization &mdash; see <A HREF="#0108" TARGET=body>Dynamic Module Finalization</A>. 
<P>If an exception is raised during execution of the procedure body the local dynamic modules shall not be finalized. 
<P>If the procedure is a protected procedure, the protection domain shall be entered before the local dynamic modules are initialized and shall be left after the local dynamic modules have been finalized. 
<P>If an exception is raised during execution of the procedure body the protection domain shall not be left. 
<P>On the execution of a function procedure block that is not protected but does have an exceptional part, the procedure body shall be executed in the state of normal execution. 
<P>On completion of the execution of the block body, the execution state shall revert to that which applied before the execution of the block body. 
<P>If execution of the procedure body completed in the state of exceptional execution, the exception shall be re-raised after the local dynamic modules have been finalized. 
<P>If an exception is raised during execution of the exceptional part of the procedure body, the local dynamic modules shall not be finalized. 
<P>On the execution of a function procedure block that is protected and has an exceptional part, if execution of the procedure body completes in the state of exceptional execution, the exception shall be re-raised after the protection domain has been left. 
<P>If an exception is raised during execution of the exceptional part of the procedure body, the protection domain shall not be left. 
<P><HR>
<A NAME="0104">
<A HREF="#0101" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0103" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0105" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Module Blocks</H3>

<P>A module block consists of a sequence of declarations and an optional module body. It is a component of a program module, an implementation module, or a local module. 
<P>Module bodies have an initialization body and, optionally, a finalization body. The initialization body is executed during static module initialization or dynamic module initialization &mdash; see <A HREF="#0105" TARGET=body>Static Module Initialization</A> and <A HREF="#0107" TARGET=body>Dynamic Module Initialization</A>. The finalization body, if present, is executed during static module finalization or dynamic module finalization &mdash; see <A HREF="#0106" TARGET=body>Static Module Finalization</A> and <A HREF="#0108" TARGET=body>Dynamic Module Finalization</A>. Initial- ization and finalization takes place in an environment that includes identifiers introduced in the declarations of the module block. 
<P><B>Concrete Syntax</B> 
<P><B>module block</B>= <A HREF="isom2005.html#0388" TARGET=body>declarations</A>, [ <A HREF="isom2005.html#0413" TARGET=body>module body</A> ], &quot;END&quot; ; 
<P><B>module body</B>= <A HREF="isom2005.html#0413" TARGET=body>initialization body</A>, [ <A HREF="isom2005.html#0413" TARGET=body>finalization body</A> ] ; 
<P><B>initialization body</B>= &quot;BEGIN&quot;, <A HREF="isom2005.html#0414" TARGET=body>block body</A> ; 
<P><B>finalization body</B>= &quot;FINALLY&quot;, <A HREF="isom2005.html#0414" TARGET=body>block body</A> ; 
<P><B>Abstract Syntax</B> 
<P>annotations In the translation from concrete to abstract syntax, a module block with no module body is represented by a <I>Module-block</I> with nil values for both the <I>initial</I> and <I>final</I> components and a module body with no finalization body is represented by a <I>Module-block</I> with a nil value for the <I>final</I> component. 
<P><B>Static Semantics</B> 
<P>If present, The initialization body of a module block shall be a well-formed block body that does not return a result. 
<P>If a module block has a finalization body, that body shall be a well-formed block body that does not return a result. 
<P><B>Dynamic Semantics</B> 
<P>The elaboration of a module block shall allocate storage for the declarations of of the block. 
<P><HR>
<A NAME="0105">
<A HREF="#0101" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0104" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0106" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Static Module Initialization</H3>

<P>Static module initialization applies to the initialization of the module blocks of implementation modules, to the execution of the program module block, and, recursively, to the initialization of local modules declared in these module blocks &mdash; see <A HREF="#0018" TARGET=body>Program Modules</A> and <A HREF="#0021" TARGET=body>Sourced Implementation Modules</A>. 
<P>A module block comprises a sequence of declarations and, optionally, a module body. The local modules contained in the declarations of a static module block are initialized in the textual order in which they occur. 
<P>A module body comprises an initialization body and, optionally, a finalization body. Finalization bodies of static modules are executed during program termination &mdash; see <A HREF="#0028" TARGET=body>Program Termination</A> and <A HREF="#0106" TARGET=body>Static Module Finalization</A>. If a coroutine causes termination, and starts to finalize the static modules, no further static modules are initialized &mdash; see <A HREF="#0028" TARGET=body>Program Termination</A>. 
<P>The initialization body of a static module is executed in the environment defined by its import lists and declarations. 
<P><B>Dynamic Semantics</B> 
<P>If program termination is in progress, there shall be no further initialization of static modules. 
<P>The local modules contained in the declarations of the static module block shall be initialized in the textual order in which they occur. 
<P><B>Notes:</B> 
<OL>
 
<LI>The use of an imported variable or procedure in the initialization body of a local module might cause an exception to occur if that variable or procedure is declared in a local module that is declared later in the same block: since local modules are initialized in the textual order in which they occur, the local module that exports the variable or procedure will not have initialized that variable or any local variables which the procedure might use. 
<P>This situation does not usually arise with variables or procedures that are imported from separate modules because the rules for initialization of separate modules guarantee that the initialization body of the module that exports the variable is executed before that of the module that imports it | provided that no separate module indirectly imports itself &mdash; see <A HREF="#0027" TARGET=body>Module Initialization Order</A>. It will be prevented from arising with local modules in implementations that choose the &lsquo;declare before use&rsquo; model for the ordering of declarations &mdash; see <A HREF="#0052" TARGET=body>Ordering of Procedure and Module Declarations</A>. </LI>
<LI>The use of an imported variable or procedure in the initialization body of a local module might cause an exception to occur if that variable or procedure is declared (earlier or later) in the same block as the local module: since local modules are initialized before the execution of the body of the block in which they are declared, that body will not have initialized the variable or any local variables which the procedure might use. </LI>
</OL>

<P>On the execution of an initialization body that does not have an exceptional part, the initialization body shall be executed without changing the current execution state. 
<P><B>Note:</B> The current execution state will always be that of normal execution during static module initialization. If the static module initialization body has no exceptional part, the raising of an exception is a termination event &mdash; see <A HREF="#0028" TARGET=body>Program Termination</A>. 
<P>annotations After the initialization of local static modules, the finalization body is queued for execution during program termi- nation. 
<P>If the static module is a protected module, the protection domain for that module shall be entered before the local static modules are initialized and shall be left after execution of the initialization body has completed. 
<P>If an exception is raised during execution of the static module initialization body, the protection domain shall not be left. 
<P>If the static module initialization body has an exceptional part, completion of the initialization body in the state of exceptional execution shall be a termination event &mdash; see <A HREF="#0028" TARGET=body>Program Termination</A>. 
<P><B>Note:</B> The raising of an exception during execution of the exceptional part of the initialization body is also a termination event. 
<P>If the static module is protected and the initialization body has an exceptional part then, if execution of the initial- ization body completes in the state of exceptional execution, the protection domain shall be left. 
<P>If an exception is raised during execution of the exceptional part of the initialization body, the protection domain shall not be left. 
<P><B>Auxiliaries</B> 
<P>annotations The environment for the execution of the block of a static module is retrieved from the given environment. 
<P><HR>
<A NAME="0106">
<A HREF="#0101" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0105" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0107" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Static Module Finalization</H3>

<P>The finalization body of a static module is executed on program termination &mdash; see <A HREF="#0028" TARGET=body>Program Termination</A>. Execution is in the environment defined by the import lists and declarations of the module block. 
<P><B>Dynamic Semantics</B> 
<P>On the finalization of a static module, the finalization body shall be executed. 
<P>On the execution of a finalization body that does not have an exceptional part, the finalization body shall be executed without changing the current execution state. 
<P><B>Note:</B> In normal termination, the coroutine execution state is that of normal execution; in exceptional termination, the coroutine execution state is that of exceptional execution &mdash; see <A HREF="#0028" TARGET=body>Program Termination</A>. Normal termination can switch to exceptional termination because of the raising of an exception during termination that is not handled. Exceptional termination can switch to normal termination during the execution of a finalization body that has an exception handler or that calls a procedure that has an exception handler. If the standard procedure <TT>HALT</TT> is then called, subsequent static module finalization will remain in the state of normal execution. 
<P>If the static module is a protected module, the protection domain for that module shall be entered before the finalization body is executed, and shall be left after execution of the finalization body has completed. 
<P>If an exception is raised during execution of the static module finalization body, the protection domain shall not be left. 
<P>If the static module finalization body has an exceptional part, the finalization body shall be executed in the state of normal execution. Completion of the finalization body in the state of exceptional execution shall be a termination event &mdash; see <A HREF="#0028" TARGET=body>Program Termination</A>. 
<P><B>Note:</B> The raising of an exception during execution of the exceptional part of the finalization body is also a termination event. 
<P>If the static module is protected and the finalization body has an exceptional part then, if execution of the finalization body completes in the state of exceptional execution, the protection domain shall be left. 
<P>If an exception is raised during execution of the exceptional part of the finalization body, the protection domain shall not be left. 
<P><HR>
<A NAME="0107">
<A HREF="#0101" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0106" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0108" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Dynamic Module Initialization</H3>

<P>Dynamic module initialization applies to the initialization of the module blocks of local modules declared in a procedure block and recursively to the initialization of local modules declared in these module blocks &mdash; see <A HREF="#0102" TARGET=body>Proper Procedure Blocks</A> and <A HREF="#0103" TARGET=body>Function Procedure Blocks</A>. 
<P><B>Dynamic Semantics</B> 
<P>The local modules contained in the declarations of a procedure block shall be initialized in the textual order in which they occur. 
<P><B>Note:</B> Since the local modules contained in the declarations of a procedure block are initialized in the textual order in which they occur, and are initialized before the procedure body is executed, the direct or indirect use of variables initialized in following local modules, or in the procedure body, might cause an exception to occur. 
<P>annotations The environment for the execution of the block of a local dynamic module is the environment constructed by the elaboration of its declarations given the imported identifiers. 
<P>The local modules contained in the declarations of the dynamic module block shall be initialized in the textual order in which they occur. 
<P>An initialization body that does not have an exceptional part shall be executed without changing the current execution state. 
<P><B>Note:</B> If the initialization body of a dynamic module has no exceptional part, the exceptional part that is the current exception handler is the exceptional part that is the current exception handler for the caller of the procedure whose dynamic modules are being initialized &mdash; see <A HREF="#0102" TARGET=body>Proper Procedure Blocks</A> and <A HREF="#0103" TARGET=body>Function Procedure Blocks</A>. 
<P>If the dynamic module is a protected module, the protection domain for that module shall be entered before the local dynamic modules are initialized, and shall be left after execution of the initialization body has completed. 
<P>If an exception is raised during execution of the dynamic module initialization body, the protection domain shall not be left. 
<P>If the initialization body of the dynamic module has an exceptional part, the initialization body shall be executed in the state of normal execution. 
<P>On completion of the execution of the block body, the execution state shall revert to that which applied before the execution of the block body. 
<P>If execution of the initialization body completed in the state of exceptional execution, the exception shall be re-raised. 
<P>On the initialization of a dynamic module that is protected and whose initialization body has an exceptional part, if execution of the initialization body completes in the state of exceptional execution, the exception shall be re-raised after the protection domain has been left. 
<P>If an exception is raised during execution of the exceptional part of the initialization body, the protection domain shall not be left. 
<P><HR>
<A NAME="0108">
<A HREF="#0101" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0107" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0109" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Dynamic Module Finalization</H3>

<P>Dynamic module finalization applies to the finalization of the module blocks of local modules declared in a procedure block and recursively to the finalization of local modules declared in these module blocks &mdash; see <A HREF="#0102" TARGET=body>Proper Procedure Blocks</A> and <A HREF="#0103" TARGET=body>Function Procedure Blocks</A>. 
<P><B>Dynamic Semantics</B> 
<P>The local modules contained in the declarations of a procedure block shall be finalized in the reverse order of their initialization. 
<P>annotations The environment for the execution of the block of a local dynamic module is the environment constructed by the elaboration of its declarations given the imported identifiers. 
<P>A finalization body that does not have an exceptional part shall be executed without changing the current execution state. 
<P><B>Note:</B> If the finalization body of a dynamic module has no exceptional part, the exceptional part that is the current exception handler is the exceptional part that is the current exception handler for the caller of the procedure whose dynamic modules are being finalized &mdash; see <A HREF="#0102" TARGET=body>Proper Procedure Blocks</A> and <A HREF="#0103" TARGET=body>Function Procedure Blocks</A>. 
<P>The local modules contained in the declarations of the dynamic module block shall be finalized in the reverse order of their initialization. 
<P>If the dynamic module is a protected module, the protection domain for that module shall be entered before the finalization body is executed, and shall be left after the local modules contained in the declarations of the dynamic module block have been finalized. 
<P>If an exception is raised during execution of the dynamic module finalization body, the protection domain shall not be left. 
<P>If the finalization body of the dynamic module has an exceptional part, the finalization body shall be executed in the state of normal execution. 
<P>On completion of the execution of the block body, the execution state shall revert to that which applied before the execution of the block body. 
<P>If execution of the finalization body completed in the state of exceptional execution, the exception shall be re-raised after the local modules contained in the declarations of the dynamic module block have been finalized. 
<P>If an exception is raised during execution of the exceptional part of the finalization body, the local modules contained in the declarations of the dynamic module block shall not be finalized. 
<P>On the finalization of a dynamic module that is protected and whose finalization body has an exceptional part, if execution of the finalization body completes in the state of exceptional execution, the exception shall be re-raised after the protection domain has been left. 
<P>If an exception is raised during execution of the exceptional part of the finalization body, the protection domain shall not be left. 
<P><HR>
<A NAME="0109">
<A HREF="#0101" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0108" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0110" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Block Bodies and Exception Handling</H3>

<P>Block bodies contain the statements that are to be executed when a module is initialized or finalized, or when a procedure is activated. 
<P>The block bodies of function procedures return a result value, whereas the block bodies of modules and of proper procedures do not return a result value. 
<P>Block bodies have a normal part and, optionally, an exceptional part to handle exceptions raised during execution of the normal part. 
<P>Execution of a coroutine takes place in normal execution state or in exceptional execution state. Initially, in each coroutine, the execution state is that of normal execution, and no exceptional part is selected as the current exception handler. 
<P>If a block body has an exceptional part, that exceptional part becomes the new current exception handler during execution of the normal part. 
<P>If an exception is raised in the state of normal execution, the execution state becomes that of exceptional execution. If there is an exceptional part that is the current exception handler for the coroutine, that exceptional part is executed in the state of exceptional execution. 
<P>The execution of a retry statement within the exceptional part of a block body causes the normal part to be retried, in the state of normal execution. 
<P>The execution of a return statement within the exceptional part of a block body causes normal completion of execution of the block body. 
<P>If an exception is raised in the state of exceptional execution, it is re-raised in the calling context; finalization of local dynamic modules will not take place, and the protection domain, if any, will not be left. 
<P>Exceptional completion occurs if there is no return or retry statement executed in the exceptional part; the finalization of local dynamic modules will take place, and the protection domain, if any, will be left. The exception will then be re-raised in the calling context. 
<P>If there is no exceptional part selected as the current exception handler for the coroutine, the raising of the exception is a termination event &mdash; see <A HREF="#0028" TARGET=body>Program Termination</A>. In that case, the subsequent execution of the finalization bodies of the static modules of the program will take place in the state of exceptional execution &mdash; see <A HREF="#0106" TARGET=body>Static Module Finalization</A>. 
<P><B>Example:</B> Exception handling. In the following example, use is made of the example module <TT>GeneralUserExceptions</TT> &mdash; see <A HREF="isom2004.html#0353" TARGET=body>The Use of EXCEPTIONS</A>. 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;FROM&nbsp;LibModule&nbsp;IMPORT
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fly,&nbsp;ReplaceRubberBand,&nbsp;SupplyRubberBands,&nbsp;IsLibException,&nbsp;LibException,&nbsp;LibExceptions;
&nbsp;&nbsp;&nbsp;&nbsp;FROM&nbsp;GeneralUserExceptions&nbsp;IMPORT
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GeneralExceptions,&nbsp;RaiseGeneralException;

&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;TryFlying();
&nbsp;&nbsp;&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fly
&nbsp;&nbsp;&nbsp;&nbsp;EXCEPT
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;statements&nbsp;in&nbsp;exceptional&nbsp;execution&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF&nbsp;IsLibException()&nbsp;THEN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CASE&nbsp;LibException()&nbsp;OF
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|brokenRubberBand:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReplaceRubberBand;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RETRY
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Exceptional&nbsp;return&nbsp;re-raises&nbsp;the&nbsp;exception&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;TryFlying;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;KeepFlying();
&nbsp;&nbsp;&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;statements&nbsp;in&nbsp;normal&nbsp;execution&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TryFlying;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;statements&nbsp;in&nbsp;normal&nbsp;execution&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;EXCEPT
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;statements&nbsp;in&nbsp;exceptional&nbsp;execution&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF&nbsp;IsLibException()&nbsp;THEN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CASE&nbsp;LibException()&nbsp;OF
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|outOfRubberBands:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SupplyRubberBands;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RETRY
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;can&nbsp;keep&nbsp;flying&nbsp;no&nbsp;longer&nbsp;-&nbsp;normal&nbsp;return&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RETURN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ELSE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RaiseGeneralException(disaster,&nbsp;&quot;Unexpected&nbsp;exception&nbsp;from&nbsp;LibModule&quot;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END
&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;KeepFlying;
</PRE>

<P><B>Concrete Syntax</B> 
<P><B>block body</B>= <A HREF="isom2005.html#0414" TARGET=body>normal part</A>, [ &quot;EXCEPT&quot;, <A HREF="isom2005.html#0414" TARGET=body>exceptional part</A> ] ; 
<P><B>normal part</B>= <A HREF="isom2005.html#0416" TARGET=body>statement sequence</A> ; 
<P><B>exceptional part</B>= <A HREF="isom2005.html#0416" TARGET=body>statement sequence</A> ; 
<P><B>Abstract Syntax</B> 
<P>annotations In the translation from concrete to abstract syntax, a block body that has no exceptional part shall be represented by a <I>Block-body</I> with a <TT>nil</TT> value for the <I>except</I> component. 
<P><B>Static Semantics</B> 
<P>The control variable of any for statement contained within a block body shall be declared as a simple variable within the declarations of the block body. 
<P>Any exit statements contained within the block body shall be contained within a loop statement inside the statement part. 
<P>There shall be no retry statements within the normal part of a block body. 
<P><UL>
<LI><A HREF="#0110" TARGET=body>Non-result Bodies</A>
<LI><A HREF="#0111" TARGET=body>Result Bodies</A>
</UL>
<P><HR>
<A NAME="0110">
<A HREF="#0109" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0109" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0111" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Non-result Bodies</H4>

<P>Non-result bodies are the block bodies of proper procedure blocks or the initialization or finalization bodies of module blocks. 
<P><B>Static Semantics</B> 
<P>Any return statements contained within non-result bodies shall be simple return statements. 
<P><B>Dynamic Semantics</B> 
<P>If there is no exceptional part to a non-result body, the execution of such a body shall cause execution of the normal part with no change to the current exception handler. 
<P>The execution of a simple return statement contained in the normal part shall cause the execution of the block body to terminate prematurely. 
<P>If there is an exceptional part to a non-result body, the execution of such a body shall cause execution of the normal part with that exceptional part as the new current exception handler. 
<P>The execution of a simple return statement contained in the normal part shall cause the execution of the block body to complete prematurely. 
<P>The raising of an exception during execution of the normal part shall cause execution of the exceptional part in the state of exceptional execution. 
<P>The execution of a simple return statement contained in the exceptional part shall cause the execution of the block body to complete prematurely in the state of normal execution. 
<P>The execution of a retry statement contained in the exceptional part shall cause reversion to the state of normal execution and cause the normal part to be retried. 
<P><B>Note:</B> The exceptional part will again be the handler for any exceptions raised during execution of the normal part. 
<P>If an exception is raised during execution of the exceptional part, it shall replace the exception that was being handled and shall be raised in the calling context. 
<P>If execution reaches the end of the exceptional part, execution of the handled body shall complete in the state of exceptional execution. 
<P><HR>
<A NAME="0111">
<A HREF="#0109" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0110" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0112" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Result Bodies</H4>

<P>Result bodies are the block bodies of function procedure blocks. 
<P><B>Static Semantics</B> 
<P>The return statements of result-bodies shall be function return statements returning a value of the result type of the function. The normal part of a block body shall have at least one function return statement. 
<P><B>Dynamic Semantics</B> 
<P>If there is no exceptional part to a non-result body, the execution of such a body shall cause execution of the normal part with no change to the current exception handler. 
<P>The execution of a function return statement contained in the normal part shall cause the execution of the block body to terminate prematurely. The value of the function return statement expression shall be the value that is returned as the value of the call. 
<P>It shall be an exception if the completion of the normal part of a result body is not by the execution of a return statement. 
<P>If there is an exceptional part to a result body, the execution of such a body shall cause execution of the normal part with that exceptional part as the new current exception handler. 
<P>The execution of a function return statement contained in the normal part shall cause the execution of the block body to complete prematurely. The value of the function return statement expression shall be the value that is returned as the value of the call. 
<P>The raising of an exception during execution of the normal part shall cause execution of the exceptional part in the state of exceptional execution. 
<P>The execution of a function return statement contained in the exceptional part shall cause the execution of the block body to complete prematurely in the state of normal execution. The value of the function return statement expression shall be the value that is returned as the value of the call. 
<P>The execution of a retry statement contained in the exceptional part shall cause reversion to the state of normal execution, and cause the normal part to be retried. 
<P><B>Note:</B> The exceptional part will again be the handler for any exceptions raised during execution of the normal part. 
<P>If an exception is raised during execution of the exceptional part, it shall replace the exception that was being handled, and shall be raised in the calling context. 
<P>If execution reaches the end of the exceptional part, execution of the handled body shall complete in the state of exceptional execution. 
<P>
<P><HR>
<A NAME="0112">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0111" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0113" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Statements</H2>

<P>Except for the empty statement, statements denote actions. Statements are executed and their execution has an effect that is a transformation of the program state. The empty statement, the assignment statement, the procedure call, the return statement, the retry statement, and the exit statement are not composed of any parts that are themselves statements. The remaining statements have components that are themselves statements; these are the with statement, the if statement, the case statement, the while statement, the repeat statement, the loop statement, and the for statement. 
<P><B>Concrete Syntax</B> 
<P><B>statement</B>= <BR>
<A HREF="isom2005.html#0417" TARGET=body>empty statement</A> | <A HREF="isom2005.html#0418" TARGET=body>assignment statement</A> | <A HREF="isom2005.html#0419" TARGET=body>procedure call</A> | <BR>
<A HREF="isom2005.html#0420" TARGET=body>return statement</A> | <A HREF="isom2005.html#0421" TARGET=body>retry statement</A> | <A HREF="isom2005.html#0422" TARGET=body>with statement</A> | <BR>
<A HREF="isom2005.html#0423" TARGET=body>if statement</A> | <A HREF="isom2005.html#0424" TARGET=body>case statement</A> | <A HREF="isom2005.html#0426" TARGET=body>while statement</A> | <BR>
<A HREF="isom2005.html#0427" TARGET=body>repeat statement</A> | <A HREF="isom2005.html#0428" TARGET=body>loop statement</A> | <A HREF="isom2005.html#0429" TARGET=body>exit statement</A> | <BR>
<A HREF="isom2005.html#0430" TARGET=body>for statement</A> ; 
<P><UL>
<LI><A HREF="#0113" TARGET=body>Statement Sequences</A>
<LI><A HREF="#0114" TARGET=body>Empty Statements</A>
<LI><A HREF="#0115" TARGET=body>Assignment Statements</A>
<LI><A HREF="#0116" TARGET=body>Procedure Calls</A>
<LI><A HREF="#0117" TARGET=body>Return Statements</A>
<LI><A HREF="#0120" TARGET=body>Retry Statements</A>
<LI><A HREF="#0121" TARGET=body>With Statements</A>
<LI><A HREF="#0122" TARGET=body>If Statements</A>
<LI><A HREF="#0123" TARGET=body>Case Statements</A>
<LI><A HREF="#0125" TARGET=body>While Statements</A>
<LI><A HREF="#0126" TARGET=body>Repeat Statements</A>
<LI><A HREF="#0127" TARGET=body>Loop Statements</A>
<LI><A HREF="#0128" TARGET=body>Exit Statements</A>
<LI><A HREF="#0129" TARGET=body>For Statements</A>
<LI><A HREF="#0130" TARGET=body>Well-formed Control Variables</A>
<LI><A HREF="#0132" TARGET=body>Auxiliary Functions</A>
</UL>
<P><HR>
<A NAME="0113">
<A HREF="#0112" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0112" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0114" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Statement Sequences</H3>

<P>A statement sequence specifies that a sequence of actions is to be performed. Each action is specified by a statement. The statements of a statement sequence are separated by semicolons. 
<P><B>Concrete Syntax</B> 
<P><B>statement sequence</B>= <A HREF="isom2005.html#0415" TARGET=body>statement</A>, { &quot;;&quot;, <A HREF="isom2005.html#0415" TARGET=body>statement</A> } ; 
<P><B>Static Semantics</B> 
<P>annotations Check each statement of the statement sequence. 
<P><B>Dynamic Semantics</B> 
<P>The execution of a statement sequence shall cause the execution of the first statement in the sequence, followed by the execution, in order, of any remaining statements of the sequence. 
<P><B>Notes:</B> 
<OL>
 
<LI>The execution of a statement sequence may be prematurely terminated by the execution of a return statement, or by the execution of an exit statement if the statement sequence is contained within a loop statement. </LI>
<LI>The execution of a statement sequence may be prematurely terminated if an exception is raised. </LI>
</OL>

<P><HR>
<A NAME="0114">
<A HREF="#0112" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0113" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0115" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Empty Statements</H3>

<P>An empty statement contains no symbols and denotes no action. Its use permits the relaxation of punctuation rules in statement sequences. 
<P><B>Concrete Syntax</B> 
<P><B>empty statement</B>= ; 
<P><B>Dynamic Semantics</B> 
<P>An empty statement shall denote no action; its execution shall produce no changes to the state. 
<P><HR>
<A NAME="0115">
<A HREF="#0112" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0114" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0116" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Assignment Statements</H3>

<P>An assignment statement specifies that a variable is to be given a value. The variable may be either an elementary variable or a structured (composite) variable. 
<P><B>Concrete Syntax</B> 
<P><B>assignment statement</B>= <A HREF="isom2005.html#0431" TARGET=body>variable designator</A>, &quot;:=&quot;, <A HREF="isom2005.html#0436" TARGET=body>expression</A> ; 
<P><B>Static Semantics</B> 
<P>The variable designator shall denote a variable. The type of the variable designator shall be assignment-compatible with the type of the expression &mdash; see <A HREF="#0100" TARGET=body>Assignment Compatibility</A>. 
<P><B>Dynamic Semantics</B> 
<P>The execution of an assignment statement shall cause the expression to be evaluated and the resulting value to become the new value of the variable denoted by the variable designator. The order of evaluation of the variable designator and the expression shall be implementation-dependent. 
<P>If the assignment is to an elementary variable, and the value to be assigned is not a value of the range of values defined by the type of the variable designator, an exception shall be raised. 
<P>If the assignment is of a string constant or string literal to an array whose component type is the character type, and the string constant does not fill the array, the string shall be terminated with a string terminator, and the remainder of the array shall become undefined. 
<P><B>Note:</B> For assignment to a concrete string variable to work as described, it is not sufficient for the variable&rsquo;s component type to be a subrange of <TT>CHAR</TT>. It must be identical to <TT>CHAR</TT> so that it can contain a string terminator. 
<P>If the assignment is to a tag field of a record, and the new value of the tag field causes a new variant to be selected, the value of each field of the field list of the variant associated with the old value of the tag field shall become undefined. If the new value of the tag field does not cause a new variant to be selected, the assignment to the tag field shall produce no change to the associated variant. 
<P><B>Notes:</B> 
<OL>
 
<LI>The evaluations of the variable designator and the expression could produce a transformation of the program state, i.e. have side-effects. </LI>
<LI>An exception occurs during the evaluation of the expression if the value of an elementary variable that is a factor of that expression is undefined. If the value of a variable of a record or array structure is to be assigned, and the value of any of the components is undefined, then no exception occurs. Undefined values can therefore be assigned to the components of a structured (composite) variable, but only if the assignment is applied to the entire variable. </LI>
<LI>An exception occurs during the evaluation of the variable designator if the variable designator is a selected designator and the assignment is to a field of a variant for which there is an explicit tag field and the variant is inactive &mdash; see <A HREF="#0140" TARGET=body>Selected Designators</A>. </LI>
<LI>An exception occurs if assignment is to a variable whose designator is an indexed designator and the index is not a valid value of the variable&rsquo;s index type. </LI>
</OL>

<P>annotations The above evaluation order for the variable designator and the expression is just one of those permitted; the expression may instead be evaluated before the variable designator, or both may be evaluated in parallel &mdash; see ???.
<P>After the two evaluations, the result of the expression evaluation is assigned to the target of the assignment. 
<P>When the variable designator is a selected designator and the target is a field of a variant, then in the case of explicit tag fields, the evaluation of the selected designator will check that the values of the tag fields that select the field are correctly set. In the case of implicit tag fields selecting the variant, these implicit tag fields will be set to appropriate values. 
<P><B>Auxiliaries</B> 
<P>annotations This function is used to assign to elementary variables, and is used recursively to assign to array, record, tag, variant, and tagged variables. An undefined value can only occur as part of an array or record value; it cannot occur as an elementary value. 
<P>annotations Check that the value to be assigned is within range or is undefined: if it is, change the value of the target designator; otherwise an exception shall be raised. Character literals are interpreted as values of the character type. 
<P>annotations Component by component assignment of the array value to the array variable occurs, and assignment of an undefined value is allowed for. 
<P>annotations If the assignment is a string literal to an array of <TT>CHAR</TT>, and the string constant does not fill the array, the string is terminated with a string terminator (denoted by end-of-string-char) and the remainder of the array is set to undefined. The well-formed conditions guarantee that the length of the string constant is less than or equal to the number of the components of the array. 
<P>annotations Set the variables that are components of a variant to undefined. 
<P>annotations Return the (variant) component of a record that corresponds to the value of the associated tag field. If the tag field contains an undefined value, the result is an empty record. 
<P>annotations Assign a value to a field of a variant for the case where there is an explicit tag field. 
<P>annotations Assign a value to a field of a variant for the case where there is an implicit tag field. 
<P><HR>
<A NAME="0116">
<A HREF="#0112" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0115" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0117" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Procedure Calls</H3>

<P>A procedure call specifies the evaluation of any actual parameters and the execution of the actions associated with the procedure designator of the procedure call. 
<P><B>Concrete Syntax</B> 
<P><B>procedure call</B>= <A HREF="isom2005.html#0419" TARGET=body>procedure designator</A>, [ <A HREF="isom2005.html#0452" TARGET=body>actual parameters</A> ] ; 
<P><B>procedure designator</B>= <A HREF="isom2005.html#0439" TARGET=body>value designator</A> ; 
<P><B>Abstract Syntax</B> 
<P>annotations The identifiers of predefined procedures are distinguished since these do not denote values (that can be assigned or compared in expressions). If the actual parameter list is not present in the concrete representation, then the translation process (from concrete to abstract syntax) will supply an empty sequence for the <I>aps</I> component of <I>Procedure-call</I> . 
<P><B>Static Semantics</B> 
<P>The procedure designator of a procedure call shall be a value designator that denotes a proper procedure or the identifier of a predefined proper procedure. 
<P><B>Notes:</B> 
<OL>
 
<LI>A value designator that denotes a proper procedure is either a procedure identifier of a proper procedure heading (possibly qualified by the name or names of modules from which the procedure identifier is exported), a value designator that denotes a constant that has a proper procedure value, or a value designator that denotes a variable that has a proper procedure type. </LI>
<LI>The identifiers of predefined procedures are not value designators since predefined procedures are not values that can be assigned, compared in expressions, or passed as procedure parameters. </LI>
</OL>

<P>In the case of a call of a predefined proper procedure, the actual parameters shall correspond in number and in type to those required for that predefined proper procedure; otherwise, each actual parameter shall be parameter compatible with the corresponding formal parameter of the designated proper procedure. 
<P><B>Dynamic Semantics</B> 
<P>The execution of a procedure call shall be the evaluation of any actual parameters to give corresponding arguments, the binding of the results of this evaluation to the corresponding formal parameters, and the execution of the actions associated with the procedure designator. In the case of a call of a predefined proper procedure, the actions are as specified for that predefined procedure; otherwise, the actions are as specified by the block of the proper procedure declaration. 
<P>The order of evaluation, the order of accessing, and the order of binding of the actual parameters shall be implementation-dependent. The order of evaluation of the procedure designator and the actual parameters shall be implementation-dependent. 
<P>The actual parameters shall be evaluated before the execution of the actions associated with the proper procedure designator. 
<P>annotations The above evaluation order for the procedure designator and the actual parameters is one of those permitted; the actual parameters may instead be evaluated before the procedure designator, or both may be evaluated in parallel | see 4.1. 
<P><HR>
<A NAME="0117">
<A HREF="#0112" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0116" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0118" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Return Statements</H3>

<P>A return statement specifies the termination of the execution of the block of a proper procedure, a function procedure, or a module. 
<P><B>Concrete Syntax</B> 
<P><B>return statement</B>= <A HREF="isom2005.html#0420" TARGET=body>simple return statement</A> | <A HREF="isom2005.html#0420" TARGET=body>function return statement</A> ; 
<P><B>Static Semantics</B> 
<P>annotations The checks that simple return statements are only contained in modules and proper procedures, and that function return statements must be contained in function procedures are performed by <I>wf-module-block</I> (see <A HREF="#0104" TARGET=body>Module Blocks</A>), <I>wf-proper-procedure-block</I> (see <A HREF="#0102" TARGET=body>Proper Procedure Blocks</A>), and <I>wf-function-procedure-block</I> (see <A HREF="#0103" TARGET=body>Function Procedure Blocks</A>). 
<P><UL>
<LI><A HREF="#0118" TARGET=body>Simple Return Statements</A>
<LI><A HREF="#0119" TARGET=body>Function Return Statements</A>
</UL>
<P><HR>
<A NAME="0118">
<A HREF="#0117" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0117" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0119" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Simple Return Statements</H4>

<P>A simple return statement specifies the termination of the execution of a proper procedure block or a module block. 
<P><B>Concrete Syntax</B> 
<P><B>simple return statement</B>= &quot;RETURN&quot; ; 
<P><B>Dynamic Semantics</B> 
<P>The execution of a simple return statement shall terminate the execution of a proper procedure block or a module block. 
<P><B>Note:</B> There is an implicit simple return statement at the end of the proper procedure block of a proper procedure. An explicit simple return statement within the proper procedure block means that there is an additional point at which the execution of the block is to be terminated. 
<P><HR>
<A NAME="0119">
<A HREF="#0117" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0118" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0120" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Function Return Statements</H4>

<P>A function return statement specifies the termination of the execution of a function procedure block, and defines the value to be returned by that function procedure. 
<P><B>Concrete Syntax</B> 
<P><B>function return statement</B>= &quot;RETURN&quot;, <A HREF="isom2005.html#0436" TARGET=body>expression</A> ; 
<P><B>Static Semantics</B> 
<P>The result type (see <A HREF="#0058" TARGET=body>Function Procedure Declarations</A>) of the function procedure in which the function return statement appears shall be assignment-compatible with the type of the expression. 
<P><B>Dynamic Semantics</B> 
<P>The execution of a function return statement shall terminate the execution of a function procedure block and return a value. If the type of the function result is a subrange type, the value returned shall belong to the set of values defined by the subrange type; otherwise an exception shall be raised. 
<P><B>Notes:</B> 
<OL>
 
<LI>There may be several function return statements in a function procedure block, although only one of these will be executed on any activation of the function procedure. </LI>
<LI>An exception is raised if the termination of a function procedure block is not by the execution of a function return statement &mdash; see <A HREF="#0103" TARGET=body>Function Procedure Blocks</A>. </LI>
</OL>

<P>annotations The expression of the return statement is evaluated. If the result is one of the values of the type defined by the return type of the function procedure, the result is returned, otherwise an exception is raised. A character literal is converted to a character value before the range is checked. 
<P><HR>
<A NAME="0120">
<A HREF="#0112" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0119" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0121" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Retry Statements</H3>

<P>A retry statement may occur only within the exceptional part of a module body or procedure body. It specifies that the normal part of the block body is to be re-executed &mdash; see <A HREF="#0109" TARGET=body>Block Bodies and Exception Handling</A>. 
<P><B>Concrete Syntax</B> 
<P><B>retry statement</B>= &quot;RETRY&quot; ; 
<P>Static Semantics 
<P>A retry statement shall be contained within an exceptional part of a block body. 
<P>annotations The check that the retry statement is contained within an exceptional part of a block body is included in the consistency check for the procedure/function/module that contains the retry statement &mdash; see <A HREF="#0102" TARGET=body>Proper Procedure Blocks</A>, <A HREF="#0103" TARGET=body>Function Procedure Blocks</A>, and <A HREF="#0104" TARGET=body>Module Blocks</A>. 
<P><B>Dynamic Semantics</B> 
<P>The execution of a retry statement shall revert to the state of normal execution and cause the handled block body to be retried &mdash; see <A HREF="#0109" TARGET=body>Block Bodies and Exception Handling</A>. 
<P><HR>
<A NAME="0121">
<A HREF="#0112" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0120" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0122" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>With Statements</H3>

<P>A with statement specifies a record designator and a statement sequence; within that statement sequence, the field identifiers of the designated record need not be qualified by the record designator. 
<P><B>Concrete Syntax</B> 
<P><B>with statement</B>= &quot;WITH&quot;, <A HREF="isom2005.html#0422" TARGET=body>record designator</A>, &quot;DO&quot;, <A HREF="isom2005.html#0416" TARGET=body>statement sequence</A>, &quot;END&quot; ; 
<P><B>record designator</B>= <A HREF="isom2005.html#0431" TARGET=body>variable designator</A> | <A HREF="isom2005.html#0439" TARGET=body>value designator</A> ; 
<P><B>Static Semantics</B> 
<P>The record designator shall denote a record variable or a record value. Within the statement sequence, the field identifiers of the record variable or record value may be used without selection. 
<P>annotations Check that the designator designates either a record variable or record value. Add the field identifiers with their corresponding types to the current environment to give the environment for the body of the with statement. 
<P><B>Dynamic Semantics</B> 
<P>The record variable designator or record value designator shall be evaluated before the statement sequence of the with statement is executed, and that evaluation shall establish a reference to the variable or value throughout the execution of the statement sequence of the with statement. 
<P>annotations Add the field identifiers with their corresponding variables or values to the current environment to give the envi- ronment for the body of the with statement. 
<P><HR>
<A NAME="0122">
<A HREF="#0112" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0121" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0123" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>If Statements</H3>

<P>An if statement is used to select one statement sequence for execution from an ordered list of alternatives guarded by Boolean expressions. 
<P><B>Concrete Syntax</B> 
<P><B>if statement</B>= <A HREF="isom2005.html#0423" TARGET=body>guarded statements</A>, [ <A HREF="isom2005.html#0423" TARGET=body>if else part</A> ], &quot;END&quot; ; 
<P><B>guarded statements</B>= <BR>
&quot;IF&quot;, <A HREF="isom2005.html#0423" TARGET=body>boolean expression</A>, &quot;THEN&quot;, <A HREF="isom2005.html#0416" TARGET=body>statement sequence</A>, <BR>
{ &quot;ELSIF&quot;, <A HREF="isom2005.html#0423" TARGET=body>boolean expression</A>, &quot;THEN&quot;, <A HREF="isom2005.html#0416" TARGET=body>statement sequence</A> } ; 
<P><B>if else part</B>= &quot;ELSE&quot;, <A HREF="isom2005.html#0416" TARGET=body>statement sequence</A> ; 
<P><B>boolean expression</B>= <A HREF="isom2005.html#0436" TARGET=body>expression</A> ; 
<P><B>Abstract Syntax</B> 
<P>annotations An if statement always contains at least one statement sequence (which follows the first occurrence of a <TT>THEN</TT> symbol); thus after the translation process (from concrete to abstract syntax) there is always a non-empty sequence of guarded statements. A missing if else part in the concrete syntax is denoted by nil in the abstract syntax. 
<P><B>Static Semantics</B> 
<P>All if statement boolean expressions shall be of the Boolean type. 
<P><B>Dynamic Semantics</B> 
<P>The boolean expressions of the guarded statements shall be evaluated in the order they occur, as far as the first boolean expression (if any) that has the value <I>true</I> . If there is such a boolean expression, its associated statement sequence shall then be executed; however, if all the boolean expressions have the value <I>false</I> , the statement sequence of the else part (if present) shall be executed. An if statement shall denote no action if all the boolean expressions have the value <I>false</I> , and there is no else part. 
<P><B>Note:</B> The evaluation of the if statement boolean expressions could produce a transformation of the program state, i.e. have side-effects. 
<P>annotations If there are no more elements remaining in the sequence of guarded statements then the if else part of the if statement (if present) is executed. If there are more elements remaining in the sequence of guarded statements, the Boolean expression of the first guarded statement in the sequence is evaluated, and if the result is true, the corresponding statement sequence is executed. If the result of the evaluation of the Boolean expression is false, then this element is removed from the sequence of guarded statements and the remainder of the sequence executed. 
<P><B>Auxiliaries</B> 
<P>annotations If an if else part is present, and no other component of the if statement has been executed, then the if else part is executed. 
<P><HR>
<A NAME="0123">
<A HREF="#0112" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0122" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0124" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Case Statements</H3>

<P>A case statement is used to select one statement sequence for execution from alternatives; the selection of the statement sequence depends on the value of an expression. 
<P><B>Concrete Syntax</B> 
<P><B>case statement</B>= &quot;CASE&quot;, <A HREF="isom2005.html#0424" TARGET=body>case selector</A>, &quot;OF&quot;, <A HREF="isom2005.html#0424" TARGET=body>case list</A>, &quot;END&quot; ; 
<P><B>case selector</B>= <A HREF="isom2005.html#0437" TARGET=body>ordinal expression</A> ; 
<P><B>case list</B>= <A HREF="isom2005.html#0425" TARGET=body>case alternative</A>, { &quot;|&quot;, <A HREF="isom2005.html#0425" TARGET=body>case alternative</A> }, [ <A HREF="isom2005.html#0424" TARGET=body>case else part</A> ] ; 
<P><B>case else part</B>= &quot;ELSE&quot;, <A HREF="isom2005.html#0416" TARGET=body>statement sequence</A> ; 
<P><B>Abstract Syntax</B> 
<P>annotations The number of elements in the cases component of the abstract representation of a case statement is equal to the number of case alternatives of the concrete representation. 
<P><B>Static Semantics</B> 
<P>The case selector shall be of an ordinal type and shall be expression compatible with the types of the constant expressions of the case label list of each case alternative. 
<P>The values contained in the case label lists of different case alternatives shall be distinct from each other. 
<P><B>Note:</B> In addition to the requirement that the values contained in the case label lists s of different case alternatives shall be distinct from each other, it is also required that the values contained in each case label list shall be distinct from each other. 
<P><B>Example:</B> Duplication of case labels in case statements. The alternatives illustrated in the following source code are illegal for the reasons given in the associated comments. 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;CASE&nbsp;i&nbsp;OF
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*a*)&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(*&nbsp;duplicate&nbsp;of&nbsp;label&nbsp;in&nbsp;list&nbsp;d&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*b*)&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(*&nbsp;label&nbsp;11&nbsp;in&nbsp;b&nbsp;duplicated&nbsp;in&nbsp;range&nbsp;11..13&nbsp;in&nbsp;list&nbsp;i&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*c*)&nbsp;15..17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(*&nbsp;range&nbsp;15..17&nbsp;in&nbsp;c&nbsp;overlaps&nbsp;with&nbsp;range&nbsp;16..19&nbsp;in&nbsp;list&nbsp;j&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*d*)&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(*&nbsp;duplicate&nbsp;of&nbsp;label&nbsp;in&nbsp;list&nbsp;a&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*e*)&nbsp;2,&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(*&nbsp;label&nbsp;2&nbsp;is&nbsp;duplicated&nbsp;in&nbsp;list&nbsp;e&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*f*)&nbsp;3..5,&nbsp;3..5&nbsp;&nbsp;:&nbsp;(*&nbsp;range&nbsp;3..5&nbsp;is&nbsp;duplicated&nbsp;in&nbsp;list&nbsp;f&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*g*)&nbsp;6,&nbsp;6..7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(*&nbsp;label&nbsp;6&nbsp;duplicated&nbsp;in&nbsp;range&nbsp;6..7&nbsp;in&nbsp;list&nbsp;g&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*h*)&nbsp;8..9,&nbsp;8..10&nbsp;:&nbsp;(*&nbsp;range&nbsp;8..9&nbsp;overlaps&nbsp;range&nbsp;8..10&nbsp;in&nbsp;list&nbsp;h&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*i*)&nbsp;11..13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(*&nbsp;label&nbsp;11&nbsp;in&nbsp;b&nbsp;duplicated&nbsp;in&nbsp;range&nbsp;11..13&nbsp;in&nbsp;list&nbsp;i&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(*j*)&nbsp;16..19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(*&nbsp;range&nbsp;15..17&nbsp;in&nbsp;c&nbsp;overlaps&nbsp;with&nbsp;range&nbsp;16..19&nbsp;in&nbsp;list&nbsp;j&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;END
</PRE>

<P>annotations Check each of the case alternatives and the case else part if it is present. Check that the case selector is of an ordinal type and that it is expression-compatible with the type associated with each case label list. 
<P><B>Dynamic Semantics</B> 
<P>The case selector shall be evaluated. The resulting value shall specify the execution of the statement sequence whose case label list contains that value. If the value of the case selector is not contained in any case label list, the statement sequence of the case else part (if present) shall be executed; otherwise an exception shall be raised. 
<P><B>Clarification:</B> In <I>Programming in Modula-2</I> , it is not stated what should happen when the value of the case selector is not contained in any case label list and there is no case else part. 
<P><B>Note:</B> The evaluation of the case selector could produce a transformation of the program state, i.e. have side-effects. 
<P>annotations The expression is evaluated, and the result is used to determine which statement sequence of the case statement is to be executed. 
<P><UL>
<LI><A HREF="#0124" TARGET=body>Case Alternatives</A>
</UL>
<P><HR>
<A NAME="0124">
<A HREF="#0123" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0123" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0125" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Case Alternatives</H4>

<P>A case alternative specifies the execution of a statement sequence if its case label list contains the value of the case selector. 
<P><B>Concrete Syntax</B> 
<P><B>case alternative</B>= [ <A HREF="isom2005.html#0425" TARGET=body>case label list</A>, &quot;:&quot;, <A HREF="isom2005.html#0416" TARGET=body>statement sequence</A> ] ; 
<P><B>case label list</B>= <A HREF="isom2005.html#0425" TARGET=body>case label</A>, { &quot;,&quot;, <A HREF="isom2005.html#0425" TARGET=body>case label</A> } ; 
<P><B>case label</B>= <A HREF="isom2005.html#0450" TARGET=body>constant expression</A>, [ &quot;..&quot;, <A HREF="isom2005.html#0450" TARGET=body>constant expression</A> ] ; 
<P><B>Abstract Syntax</B> 
<P>annotations The translation process (from concrete to abstract syntax) will ensure that the number of members in the <I>labels</I> component of a <I>Case</I> component of the abstract representation is equal to the number of case labels in the case label list of the concrete representation. 
<P><B>Static Semantics</B> 
<P>Each case label shall be a constant expression, or a range indicated by a pair of constant expressions. The values contained in a case label list shall be distinct from each other. A value shall be contained in a case label list if it is equal to the value of one of the constant expressions of the case label list, or if the value lies within the range specified by a pair of constant expressions of the case label list. 
<P><B>Auxiliaries</B> 
<P>annotations Check that all of the variant labels are expression-compatible with the tag type. 
<P>annotations Check that the sets of values defined by each of the case label lists are disjoint. 
<P><HR>
<A NAME="0125">
<A HREF="#0112" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0124" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0126" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>While Statements</H3>

<P>A while statement specifies the execution of a statement sequence zero or more times, depending on the value of a Boolean expression. 
<P><B>Concrete Syntax</B> 
<P><B>while statement</B>= <BR>
&quot;WHILE&quot;, <A HREF="isom2005.html#0423" TARGET=body>boolean expression</A>, &quot;DO&quot;, <A HREF="isom2005.html#0416" TARGET=body>statement sequence</A>, &quot;END&quot; ; 
<P><B>Static Semantics</B> 
<P>A while statement boolean expression shall be of the Boolean type. 
<P><B>Dynamic Semantics</B> 
<P>The while statement boolean expression shall be evaluated before each iteration of a while statement. If the expression has the value <I>true</I> , the statement sequence shall be executed, followed again by the execution of the while statement. If the expression has the value <I>false</I> , the statement sequence shall not be executed, and the execution of the while statement shall terminate. 
<P><B>Notes:</B> 
<OL>
 
<LI>If the result of the first evaluation of the boolean expression is <I>false</I> , the statement sequence of the while statement is not executed. </LI>
<LI>The evaluation of the while statement boolean expression could produce a transformation of the program state, i.e. have side-effects. </LI>
<LI>The execution of a while statement may be prematurely terminated by the execution of a return statement, or by the execution of an exit statement (if the while statement is contained within a loop statement). </LI>
</OL>

<P><HR>
<A NAME="0126">
<A HREF="#0112" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0125" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0127" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Repeat Statements</H3>

<P>A repeat statement specifies the execution of a statement sequence one or more times, depending on the value of a Boolean expression. 
<P><B>Concrete Syntax</B> 
<P><B>repeat statement</B>= <BR>
&quot;REPEAT&quot;, <A HREF="isom2005.html#0416" TARGET=body>statement sequence</A>, &quot;UNTIL&quot;, <A HREF="isom2005.html#0423" TARGET=body>boolean expression</A> ; 
<P><B>Static Semantics</B> 
<P>A repeat statement boolean expression shall be of the Boolean type. 
<P><B>Dynamic Semantics</B> 
<P>In the execution of a repeat statement, the statement sequence shall first be executed. The repeat statement boolean expression shall be evaluated; if the expression has the value <I>true</I> , the repeat statement shall be executed again. If the expression has the value <I>false</I> , the execution of the repeat statement shall terminate. 
<P><B>Notes:</B> 
<OL>
 
<LI>The statement sequence of a repeat statement is executed at least once. </LI>
<LI>The evaluation of the repeat statement boolean expression could produce a transformation of the program state, i.e. have side-effects. </LI>
<LI>The execution of a repeat statement may be prematurely terminated by the execution of a return statement, or by the execution of an exit statement (if the repeat statement is contained within a loop statement). </LI>
</OL>

<P><HR>
<A NAME="0127">
<A HREF="#0112" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0126" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0128" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Loop Statements</H3>

<P>A loop statement specifies the repeated execution of a statement sequence. The statement sequence may contain zero or more exit statements, the execution of any one of which terminates the execution of the loop statement. 
<P><B>Concrete Syntax</B> 
<P><B>loop statement</B>= &quot;LOOP&quot;, <A HREF="isom2005.html#0416" TARGET=body>statement sequence</A>, &quot;END&quot; ; 
<P><B>Dynamic Semantics</B> 
<P>The statement sequence of a loop statement shall be repeatedly executed until an exit statement of the loop statement is executed. 
<P><B>Note:</B> The execution of a loop statement may be prematurely terminated by the execution of a return statement. 
<P><HR>
<A NAME="0128">
<A HREF="#0112" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0127" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0129" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Exit Statements</H3>

<P>An exit statement may occur only within a loop statement, where it specifies the termination of that loop statement. 
<P><B>Concrete Syntax</B> 
<P><B>exit statement</B>= &quot;EXIT&quot; ; 
<P><B>Static Semantics</B> 
<P>annotations The check that the exit statement is contained inside a loop statement is part of the consistency check for the procedure/function/module that contains the exit statement. 
<P><B>Dynamic Semantics</B> 
<P>The execution of an exit statement shall terminate the execution of a loop statement; the loop statement that is terminated is the loop statement that most immediately contains the exit statement. 
<P><HR>
<A NAME="0129">
<A HREF="#0112" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0128" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0130" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>For Statements</H3>

<P>A for statement specifies that a statement sequence is to be repeatedly executed as elements of a sequence of values are assigned, one by one, to a control variable. 
<P><B>Concrete Syntax</B> 
<P><B>for statement</B>= <BR>
&quot;FOR&quot;, <A HREF="isom2005.html#0430" TARGET=body>control variable identifier</A>, &quot;:=&quot;, <A HREF="isom2005.html#0430" TARGET=body>initial value</A>, <BR>
&quot;TO&quot;, <A HREF="isom2005.html#0430" TARGET=body>final value</A>, [ &quot;BY&quot;, <A HREF="isom2005.html#0430" TARGET=body>step size</A> ], &quot;DO&quot;, <BR>
<A HREF="isom2005.html#0416" TARGET=body>statement sequence</A>, &quot;END&quot; ; 
<P><B>control variable identifier</B>= identifier ; 
<P><B>initial value</B>= <A HREF="isom2005.html#0437" TARGET=body>ordinal expression</A> ; 
<P><B>final value</B>= <A HREF="isom2005.html#0437" TARGET=body>ordinal expression</A> ; 
<P><B>step size</B>= <A HREF="isom2005.html#0450" TARGET=body>constant expression</A> ; 
<P><B>Abstract Syntax</B> 
<P>annotations If the step size is not present in the concrete representation, the translation process (from concrete to abstract syntax) will supply a <I>step</I> component in the abstract representation equal to 1. 
<P><B>Static Semantics</B> 
<P>The control variable identifier shall be the identifier of the control variable. The initial value and the final value shall be expressions. The type of the control variable shall be an ordinal type that is assignment-compatible with the type of the initial value. Either the type of the control variable or the host type of the type of the control variable and the type of the final value shall be expression-compatible. If a for statement does not contain a step size, the step size shall have the value 1. Otherwise the step size shall be a constant expression of a whole number type, shall be in an implementation-defined range, and shall not have the value 0. 
<P><B>Notes:</B> 
<OL>
 
<LI>The requirement that the type of the control variable is assignment-compatible with the type of the initial value is made since this value might be assigned to the control variable. </LI>
<LI>Other constraints on the use of a control variable are given in <A HREF="#0130" TARGET=body>Well-formed Control Variables</A>. </LI>
</OL>

<P><B>Change:</B> <I>In Programming in Modula-2</I> , it is required that the type of the control variable is expression-compatible with the type of the initial value. 
<P>annotations Check each of the components of the for statement. The check that the control variable is declared in a variable declaration part of the block that contains the for statement is part of the consistency check for the procedure, function, or module that contains the for statement. 
<P>annotations Check that the step value is between implementation-defined limits. 
<P><B>Dynamic Semantics</B> 
<P>The expressions that specify the initial value and the final value shall be evaluated in an implementation-dependent order. 
<P>If the step size is positive and the initial value is greater than the final value, the statement sequence shall not be executed, and the execution of the for statement shall terminate. If the step size is negative and the initial value is less than the final value, the statement sequence shall not be executed, and the execution of the for statement shall terminate. Otherwise a sequence of values shall be established and for each element of the sequence in turn, the element shall be assigned to the control variable, and then the statement sequence shall be executed; the execution of the for statement shall terminate when the statement sequence has been executed for each value in the sequence. 
<P>The sequence of values for the control variable shall be the longest sequence that satisfies the conditions that the first element of the sequence shall be equal to the initial value, the last element of the sequence shall be less than or equal to the final value if the step size is positive, or greater than or equal to the final value if the step size is negative, and the difference between adjacent values in the sequence shall be equal to the step size. 
<P>After termination of the for statement, the value of the control variable shall be undefined. 
<P><B>Notes:</B> 
<OL>
 
<LI>The expressions that are the initial value and the final value are evaluated only once at the start of the execution of a for statement. These evaluations could produce a transformation of the program state, i.e. have side-effects. </LI>
<LI>The statement sequence of a for statement is not executed at all if the initial value is greater than the final value (in the case that the step size is positive) or if the initial value is less than the final value (in the case that the step size is negative). </LI>
<LI>The execution of a for statement may be prematurely terminated by the execution of a return statement, or by the execution of an exit statement (if the for statement is contained within a loop statement). </LI>
</OL>

<P>annotations The above evaluation order for the initial value and the final value is one of those permitted; the final value may instead be evaluated before the initial value, or both may be evaluated in parallel | see 4.1. The iteration sequence for the loop is built from the initial value, step, and final value and then the loop is executed using the iteration sequence. 
<P><B>Auxiliaries</B> 
<P>annotations If the iteration sequence is empty, terminate the execution of the loop and assign the value undefined to the control variable. If the iteration sequence is not empty, assign the next iteration value to the control variable, execute the body of the loop and execute the for statement again with an iteration sequence having the value used for the current iteration removed. 
<P>annotations This function constructs the sequence of values that may be assigned to the control variable. The sequence of values starts with the initial value. The last value in the sequence is less than or equal to the final value if the step is positive, or greater than or equal to the final value if the step is negative. The difference between adjacent values in the sequence is equal to the step. If the initial value is greater than the final value (in the case that the step is positive) or if the initial value is less than the final value (in the case that the step is negative) the sequence of values is empty. 
<P>annotations Construct the sequence of consecutive values from the initial and final values. 
<P>annotations Construct a sequence of iteration values from the first and last values. 
<P><HR>
<A NAME="0130">
<A HREF="#0112" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0129" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0131" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Well-formed Control Variables</H3>

<P>A variable that is used as a control variable of a for statement must be a simple variable. It must be a local variable, and it must not be exported nor imported. It must not be threatened in any statement within the statement sequence of the for statement, or by any procedure in the declarations part of the block containing the for statement. 
<P>If a control variable is not threatened, no statement other than the for statement itself can attempt to alter the for loop control variable. 
<P><B>Static Semantics</B> 
<P>The control variable of each for statement in the body of a block shall be declared as a simple variable in a variable declaration part of the block that immediately contains the for statement. 
<P><B>Note:</B> Since a control variable must be declared in the declaration part of a block in which the variable is used, it follows that it is not possible for the control variable to be: 
<UL>
 
<LI>a formal parameter, or </LI>
<LI>a variable that is imported into a program module or an implementation module, or </LI>
<LI>a variable that is exported from a separate module. </LI>
</UL>

<P>A variable that is used as a control variable shall not be imported by a local module declaration of the block in which the variable is declared. 
<P>A variable that is used as a control variable in the block of a local module declaration shall not be exported from that module. 
<P><B>Note:</B> This restriction is checked by the well-formed condition for a module &mdash; see <A HREF="#0059" TARGET=body>Local Module Declarations</A>. 
<P>A control variable shall not be threatened in a statement of the statement sequence of the for statement. 
<P><B>Note:</B> This restriction is checked by the well-formed condition for a for statement &mdash; see <A HREF="#0129" TARGET=body>For Statements</A>. 
<P>A control variable shall not be threatened in a procedure declared in the declarations of the block that contains the for statement. 
<P><B>Clarification:</B> In <I>Programming in Modula-2</I> : 
<UL>
 
<LI>it is not stated that a control variable must be a local variable, </LI>
<LI>it is not stated that a control variable cannot be exported, </LI>
<LI>it is stated that the control variable should not be changed by the statement sequence of the for statement. </LI>
</UL>

<P><UL>
<LI><A HREF="#0131" TARGET=body>Threatening</A>
</UL>
<P><HR>
<A NAME="0131">
<A HREF="#0130" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0130" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0132" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Threatening</H4>

<P>A control variable shall be threatened in a proper procedure declaration if an identifier with the same spelling is not declared in the procedure heading, and the control variable is threatened in the block component of the procedure. 
<P>A control variable shall be threatened in a function procedure declaration if an identifier with the same spelling is not declared in the procedure heading, and the control variable is threatened in the block component of the procedure. 
<P>A control variable shall be threatened in a block if an identifier with the same spelling is not declared in a declaration of the block, and the control variable is threatened either in a procedure of a declaration of the block or in a statement of the statement sequence of the block. 
<P>A control variable shall be threatened in an assignment statement if it is the variable designator of the assignment, if it is threatened in an expression of the variable designator component, or if it is threatened in the expression component of the assignment statement. 
<P>A control variable shall be threatened in a procedure call if it is threatened in an expression component of the procedure designator component of the procedure call or it is threatened in an actual parameter of the procedure call. 
<P>A control variable shall be threatened in a return statement if the return statement is a function return statement and the control variable is threatened in the expression component of the return statement. 
<P>A control variable shall be threatened in a with statement if an identifier with the same spelling is not a field of the variable designated by the designator component of the with statement and the control variable is threatened in a statement of the statement sequence component of the with statement. 
<P>A control variable shall be threatened in an if statement if it is threatened in any Boolean expression components or if it is threatened in a statement of the statement sequence component. 
<P>A control variable shall be threatened in a case statement if it is threatened in the case selector or if it is threatened in a statement of the statement sequence component. 
<P>A control variable shall be threatened in a while statement if it is threatened in the Boolean expression component or if it is threatened in a statement of the statement sequence component. 
<P>A control variable shall be threatened in a repeat statement if it is threatened in a statement of the statement sequence component or if it is threatened in the Boolean expression component. 
<P>A control variable shall be threatened in a loop statement if it is threatened in a statement of the statement sequence component. 
<P>A control variable shall be threatened in a for statement if it is the control variable of the for statement, if it is 
<P>threatened in the initial value, if it is threatened in the final value, or if it is threatened in a statement of the statement sequence component. 
<P><B>Note:</B> This rule is concerned with the threatening of the control variable of a for statement in another for statement nested within the statement sequence of the first for statement. 
<P>A control variable shall be threatened in a variable designator if it is threatened in an expression component of the variable designator. 
<P>A control variable shall be threatened in an expression if it is threatened as an element of the expression. 
<P>A control variable shall be threatened in a function call if it is threatened in the value designator component or if it is threatened in an actual parameter of the function call. 
<P>A control variable shall be threatened in an actual parameter to a procedure or function call if it is an actual parameter corresponding to a variable formal parameter or if it is threatened in an expression component of the actual parameter. 
<P><B>Notes:</B> 
<OL>
 
<LI>The predefined procedures <TT>DEC</TT> and <TT>INC</TT>, and the function <TT>ADR</TT> of the module <TT>SYSTEM</TT>, are considered to take a variable parameter, and therefore cannot be passed a control variable. </LI>
<LI>A control variable is not threatened in an empty statement or in an exit statement or in a simple return statement or in a retry statement. </LI>
</OL>

<P>annotations Return the set of identifiers that are used (in a block) as the identifiers of for statement control variables. 
<P>annotations The result is true if and only if all the variables that are used as control variables are declared in the block, are not threatened in the statements or expressions contained in the block, are not threatened in procedures declared in the block, and are not imported by a module declared in the block. 
<P>annotations The result is true if and only if there exists a variable declaration that contains a declaration of the variable. 
<P>annotations The identifier parameter in the following operations is a control variable identifier and it designates a control variable. 
<P>annotations A control variable is threatened in the procedures declared in a block if there exists a procedure in the declarations component that threatens the control variable. 
<P>annotations A control variable is threatened in a proper procedure if an identifier with the same spelling is not declared in the procedure heading, and the control variable is threatened in the block component of the procedure. 
<P>annotations A control variable is threatened in a function procedure if an identifier with the same spelling is not declared in the procedure heading, and the control variable is threatened in the block component of the procedure. 
<P>annotations A control variable is threatened in a proper procedure block if an identifier with the same spelling is not declared in the declarations component of the block, and the control variable is threatened either in a procedure of the declarations component of the block or in the statement sequence of the block. 
<P>annotations A control variable is threatened in a function procedure block if an identifier with the same spelling is not declared in the declarations component of the block, and the control variable is threatened either in a procedure of the declarations component of the block or in the statement sequence of the block. 
<P>annotations A control variable is threatened in a statement sequence if at least one of the statements of the statement sequence threatens the control variable. 
<P>annotations Check if control variable threatened by a statement. 
<P>annotations A control variable is threatened in a procedure call if it is threatened as the procedure designator component of the procedure call or it is threatened in an actual parameter of the procedure call. 
<P>annotations A control variable is threatened in a return statement if the return statement is a function return statement and the control variable is threatened in the expression component of the return statement. 
<P>annotations A control variable is threatened in a with statement if an identifier with the same spelling is not a field of the variable or value designated by the designator component of the with statement and the control variable is threatened in the statement sequence that is the body of the with statement. renv is the addition to the environment caused by the with statement. If the control variable identifier belongs to the domain of the mapping then within the with statement, it is to a field of the record that is being threatened, not the control variable. 
<P>annotations A control variable is threatened in an if statement if it is threatened in the Boolean expression component of a guarded statement, if it is threatened in the statement sequence component of a guarded statement, or if it is threatened in the statement sequence component of the if else part. 
<P>annotations A control variable is threatened in a case statement if it is threatened in the case selector, if it is threatened in one of the statement sequences of the case alternatives, or if it is threatened in the statement sequence of the if else part. 
<P>annotations A control variable is threatened in a while statement if it is threatened in the expression or if it is threatened in the statement sequence. 
<P>annotations A control variable is threatened in a repeat statement if it is threatened in the statement sequence or if it is threatened in the expression. 
<P>annotations A control variable is threatened in a loop statement if it is threatened in the statement sequence. 
<P>annotations A control variable is threatened in a for statement if it is the control variable of the for statement, if it is threatened in the initial expression, if it is threatened in the final expression, or if it is threatened in the statement sequence that is the body of the for statement. 
<P>annotations A control variable is threatened in a variable designator if it is threatened in any expression component of the variable designator. 
<P>annotations A control variable is threatened in an expression if it is threatened as an element of the expression. 
<P>annotations A control variable is threatened in an infix expression if it is threatened in an expression component of the infix expression. 
<P>annotations A control variable is threatened in an prefix expression if it is threatened in the expression component of the prefix expression. 
<P>annotations A control variable is threatened in a value designator if it is threatened in any expression component of the value designator. 
<P>annotations A control variable is threatened in a function call if it is threatened as the value designator component or if it is threatened in an actual parameter of the function call. 
<P>annotations A control variable is threatened in a value constructor if it is threatened in any expression component of the value constructor. 
<P>annotations A control variable is threatened in a structured value if it is threatened in any expression component of the structured value. Note that a control variable cannot be threatened in the replication component as it is a constant expression. 
<P>annotations A control variable is threatened in a set constructor if it is threatened in any expression component of the set constructor. 
<P>annotations A control variable is threatened as an actual parameter to a procedure or function call if it is an actual parameter corresponding to a variable formal parameter or if it is threatened in an expression component of the actual parameter. 
<P>annotations Check if a control variable is imported by a module declaration of the block. 
<P><HR>
<A NAME="0132">
<A HREF="#0112" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0131" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0133" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Auxiliary Functions</H3>

<P><UL>
<LI><A HREF="#0133" TARGET=body>Well-formed Return Statements</A>
<LI><A HREF="#0134" TARGET=body>Well-formed Retry Statements</A>
<LI><A HREF="#0135" TARGET=body>Well-formed Exit Statements</A>
<LI><A HREF="#0136" TARGET=body>Statement Classes of Statement Sequences</A>
</UL>
<P><HR>
<A NAME="0133">
<A HREF="#0132" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0132" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0134" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Well-formed Return Statements</H4>

<P>annotations Check that the return statement components of the statement sequence are all function return statements and that for each return statement, the return type of the function procedure is assignment-compatible with the type of the expression component of the return statement. 
<P>annotations The return-statements of a statement sequence is the set containing all the return statements contained in the statements of the statement sequence. 
<P><HR>
<A NAME="0134">
<A HREF="#0132" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0133" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0135" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Well-formed Retry Statements</H4>

<P>annotations Check that there are no <TT>RETRY</TT> statements in a block body. 
<P>annotations The retry statements of a statement sequence is the set containing all the retry statements contained in the state- ments of the statement sequence. 
<P><HR>
<A NAME="0135">
<A HREF="#0132" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0134" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0136" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Well-formed Exit Statements</H4>

<P>annotations This function returns true if and only if each exit statement of the statement sequence is textually contained within a loop statement. A free exit statement is one that is not contained within a loop statement, thus the loop statements of a statement sequence are well-formed if the statement sequence contains no free exit statements. 
<P>annotations The free-exit-statements of a statement sequence is the set containing all the exit statements contained in the statements of the statement sequence that are not contained in loop statements. 
<P>annotations The free exit statements of an exit statement is a set containing that statement. The free exit statements of any other statement that is not composed of any parts that are themselves statements is the empty set. The free exit statements of a loop statement is the empty set. The free exit statements of any other statement that is composed of parts that are themselves statements is the free exit statements contained in the statement sequence component parts. 
<P>annotations The free exit statements contained in a with statement are the free exit statements contained in the statement sequence of the with statement. 
<P>annotations The free exit statements contained in an if statement are the free exit statements contained in the statement sequence component of the if statement. 
<P>annotations The free exit statements contained in a case statement are the free exit statements contained in the statement sequence components of the case statement. 
<P>annotations The free exit statements contained in a while statement are the free exit statements contained in the statement sequence component of the while statement. 
<P>annotations The free exit statements contained in a repeat statement are the free exit statements contained in the statement sequence component of the repeat statement. 
<P>annotations The free exit statements contained in a for statement are the free exit statements contained in the statement sequence component of the for statement. 
<P><HR>
<A NAME="0136">
<A HREF="#0132" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0135" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0137" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Statement Classes of Statement Sequences</H4>

<P>annotations This function returns a set containing all the statements contained in the statement sequence that are members of the set defined by the second parameter. 
<P>annotations The statements of a with statement that are members of the set defined by the second parameter are obtained from the statement sequence of the with statement. 
<P>annotations The statements of an if statement that are members of the set defined by the second parameter are obtained from the statement sequences of the if statement. 
<P>annotations The statements of a case statement that are members of the set defined by the second parameter are obtained from the statement sequences of the case statement. 
<P>annotations The statements of a while statement that are members of the set defined by the second parameter are obtained from the statement sequence of the while statement. 
<P>annotations The statements of a repeat statement that are members of the set defined by the second parameter are obtained from the statement sequence of the repeat statement. 
<P>annotations The statements of a loop statement that are members of the set defined by the second parameter are obtained from the statement sequence of the loop statement. 
<P>annotations The statements of a for statement that are members of the set defined by the second parameter are obtained from the statement sequence of the for statement. 
<P>
<P><HR>
<A NAME="0137">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0136" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0138" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Variable Designators</H2>

<P>A variable designator denotes a variable. The denoted variable may be a variable introduced in a variable definition or variable declaration, a formal parameter of a procedure, or a component of such a variable. 
<P><B>Concrete Syntax</B> 
<P><B>variable designator</B>= <BR>
<A HREF="isom2005.html#0432" TARGET=body>entire designator</A> | <A HREF="isom2005.html#0433" TARGET=body>indexed designator</A> | <BR>
<A HREF="isom2005.html#0434" TARGET=body>selected designator</A> | <A HREF="isom2005.html#0435" TARGET=body>dereferenced designator</A> ; 
<P><HR>
<A NAME="0138">
<A HREF="#0132" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0137" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0139" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Entire Designators</H4>

<P>An entire designator is a variable designator that is a qualified identifier; it denotes an entire elementary or structured (composite) variable (which may be a formal parameter), or a field of a record variable within a with statement that applies to that variable. 
<P><B>Concrete Syntax</B> 
<P><B>entire designator</B>= <A HREF="isom2005.html#0381" TARGET=body>qualified identifier</A> ; 
<P><B>Static Semantics</B> 
<P>The qualified identifier of an entire designator shall denote an entire variable (which may be a formal parameter), or a field of a record variable within a with statement that applies to that variable. 
<P>The type of an entire designator shall be the type of the entity that is denoted by the qualified identifier. 
<P>annotations Check that the qualified identifier component is defined or declared as a variable, or is a component of a record if the context is the statement sequence of a with statement, and that any qualification is by a module name. 
<P>annotations Return the type of the variable or, if the context is a with statement and the entire designator designates a field of a record, the type of the field. 
<P><B>Dynamic Semantics</B> 
<P>If the variable designated by an entire designator is a component of a group of variant fields which has an identified tag field, and the value of the tag field is such that the variant containing that component is not active, an exception shall occur (but need not be raised); otherwise, the variable designated by the entire designator shall be the variable or formal parameter associated with the qualified identifier. 
<P>If the designated variable belongs to one or more variants without an identified tag field, the variants shall become active. 
<P>annotations Return the variable denoted by the qualified identifier. If the variable denoted by the identifier is a field of a variant of a group of variant fields and the tag for that variant fields component exists, then check that the value of the tag is such that it selects that field. If there is no explicit tag, set the implicit tag to select the field. 
<P><HR>
<A NAME="0139">
<A HREF="#0137" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0138" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0140" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Indexed Designators</H3>

<P>An indexed designator is a variable designator that is an array variable designator followed by one or more index expressions, and it denotes a component variable of the indexed array variable, or a component of a component of the indexed array variable. 
<P><B>Concrete Syntax</B> 
<P><B>indexed designator</B>= <BR>
<A HREF="isom2005.html#0433" TARGET=body>array variable designator</A>, &quot;[&quot;, <A HREF="isom2005.html#0433" TARGET=body>index expression</A>, { &quot;,&quot;, <A HREF="isom2005.html#0433" TARGET=body>index expression</A> }, &quot;]&quot; ; 
<P><B>array variable designator</B>= <A HREF="isom2005.html#0431" TARGET=body>variable designator</A> ; 
<P><B>index expression</B>= <A HREF="isom2005.html#0437" TARGET=body>ordinal expression</A> ; 
<P>The concrete syntax allows for a full or abbreviated representation of the indexing of an array variable that is itself designated by an indexed designator. In the abbreviated form, a single comma shall replace the sequence &lsquo;<TT>]&nbsp;[</TT>&rsquo; that occurs in the full form. The abbreviated form and the full form shall be equivalent. 
<P><B>Example:</B> Indexing of an indexed designator A variable designator of the form: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;A[E1][E2][E3]
</PRE>

<P>may also be written in the following ways: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;A[E1,E2,E3]&nbsp;&nbsp;A[E1][E2,E3]&nbsp;&nbsp;A[E1,E2][E3]
</PRE>

<P><B>Abstract Syntax</B> 
<P>annotations The abstract syntax only uses the full form. 
<P><B>Static Semantics</B> 
<P>The array variable designator of an indexed designator shall be a variable designator that is of an array type. The type of the index expression shall be assignment-compatible with the index type of the array type. 
<P>The type of an indexed designator shall be the component type of the array type. 
<P>annotations Check the designator and expression components of the indexed designator. Check that the variable denoted by the designator is of an array type, and that the index type given in the definition or declaration of the variable is assignment- compatible with the index expression. 
<P>annotations Return the type of the component of the array as given in the definition or declaration of the variable. 
<P><B>Dynamic Semantics</B> 
<P>The variable designator shall be evaluated to give an array variable. The index expression shall be evaluated to give an ordinal value. Provided that this ordinal value is a value of the index type of the array variable, the variable designated by the indexed designator shall be the component of the array variable indexed by the ordinal value; otherwise an exception shall be raised. 
<P>The order of evaluation of the variable designator and the index expression of an indexed designator shall be implementation-dependent. 
<P><B>Note:</B> If a function call appears in the index expression, the evaluation of the indexed designator could produce a transformation of the program state, i.e. have side-effects. 
<P>annotations The above evaluation order for the array variable and the index expression is one of those permitted; the index expression may instead be evaluated before the array variable, or both may be evaluated in parallel &mdash; see ???. 
<P><HR>
<A NAME="0140">
<A HREF="#0137" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0139" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0141" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Selected Designators</H3>

<P>A selected designator is a variable designator that is a record variable designator followed by a field identifier, and it denotes a component variable of a variable of a record type. 
<P><B>Concrete Syntax</B> 
<P><B>selected designator</B>= <A HREF="isom2005.html#0434" TARGET=body>record variable designator</A>, &quot;.&quot;, <A HREF="isom2005.html#0434" TARGET=body>field identifier</A> ; 
<P><B>record variable designator</B>= <A HREF="isom2005.html#0431" TARGET=body>variable designator</A> ; 
<P><B>field identifier</B>= identifier ; 
<P><B>Static Semantics</B> 
<P>The record variable designator of a selected designator shall be a variable designator that is of a record type. The field identifier shall be one of the identifiers or tag identifiers of the field list of that record type. 
<P>The type of a selected designator shall be the type of the field identifier. 
<P>annotations Check the designator component and that it designates a record structure. Check that identifier component is one of the field list identifiers of the record. 
<P>annotations Return the type of the field corresponding to the field list identifier. 
<P><B>Dynamic Semantics</B> 
<P>The variable designator shall be evaluated to give a record variable. If the field identifier denotes a component of the record variable&rsquo;s type that belongs to a variant of a group of variant fields that has a tag field, and the variant is not active, an exception shall occur (but need not be raised); otherwise the variable designated by the selected designator shall be the component of the record variable selected by the field identifier. 
<P>If the designated variable belongs to one or more variants without an identified tag field, the variants shall become active. 
<P>annotations Evaluate the designator and select the appropriate field of the record. If the field is a variant component of a variant fields and the tag for that variant fields component exists, then check that the value of the tag is such that it selects that field. If there is no explicit tag, set the implicit tag to select the field. 
<P><B>Auxiliaries</B> 
<P>annotations A field of a record may occur in a variant that is nested in several variants. First check that the outer variant is an active variant; this is done by checking that the value of the tag field is consistent with the field component that is referenced. The function is called recursively to check the next (inner) variant. 
<P>annotations A field of a record may occur in a variant that is nested in several variants. The outermost variant is made active by assigning an appropriate value to the tag field associated with this variant. The function is called recursively to make the next innermost variant active. 
<P><HR>
<A NAME="0141">
<A HREF="#0137" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0140" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0142" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Dereferenced Designators</H3>

<P>A dereferenced designator is a variable designator that is a pointer variable designator followed by a dereferencing operator, and it denotes the variable (if any) that is referenced by the value of the pointer variable designator. 
<P><B>Concrete Syntax</B> 
<P><B>dereferenced designator</B>= <A HREF="isom2005.html#0435" TARGET=body>pointer variable designator</A>, &quot; &quot; ; 
<P><B>pointer variable designator</B>= <A HREF="isom2005.html#0431" TARGET=body>variable designator</A> ; 
<P><B>Static Semantics</B> 
<P>The pointer variable designator of a dereferenced designator shall be a variable designator that is of a pointer type. 
<P>The type of a dereferenced designator shall be the bound type specified in the declaration of the pointer type. 
<P>annotations Check the designator and that it designates a variable of a pointer type. Outside of the implementation module in which it is defined, an opaque type is not a pointer type. 
<P><B>Dynamic Semantics</B> 
<P>The variable designator shall be evaluated to give a variable P. Provided that the value of the variable P denotes a variable, the variable designated by the dereferenced designator shall be the value of the variable P. 
<P>An exception shall be raised if the value of the variable P is the value of the pervasive identifier <TT>NIL</TT>. 
<P>An exception shall occur (but need not be raised) if the value of the variable P is a value associated with non-existing storage. 
<P>An exception shall occur (but need not be raised) if the value of the variable P is a pointer to a variable of the wrong type. 
<P><B>Note:</B> Since the address type is assignment compatible with all pointer types, the value of the variable P may be a pointer to a variable of the wrong type if it has been assigned through a variable or parameter of the address type. 
<P>annotations Check that the value of the pointer is such that it denotes a variable that exists, and that the type of the variable it denotes matches the type of the pointer. 
<P>
<P><HR>
<A NAME="0142">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0141" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0143" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Expressions</H2>

<P>An expression is a formula involving operators and operands whose computation produces a value. However, an expression does not define a value if the computation does not terminate, or if an exception is raised during the computation, such as might arise from using an undefined value, or from dividing by zero. 
<P><B>Changes:</B> 
<OL>
 
<LI>This International Standard does not allow arithmetic on values of the address type (except via functions imported from <TT>SYSTEM</TT>). </LI>
<LI>In <I>Programming in Modula-2</I> there are no predefined types for complex values, nor is any provision made for arithmetic on complex values. </LI>
</OL>

<P><B>Concrete Syntax</B> 
<P><B>expression</B>= <A HREF="isom2005.html#0436" TARGET=body>simple expression</A>, [ <A HREF="isom2005.html#0438" TARGET=body>relational operator</A>, <A HREF="isom2005.html#0436" TARGET=body>simple expression</A> ] ; 
<P><B>simple expression</B>= [ sign ], <A HREF="isom2005.html#0436" TARGET=body>term</A>, { <A HREF="isom2005.html#0438" TARGET=body>term operator</A>, <A HREF="isom2005.html#0436" TARGET=body>term</A> } ; 
<P><B>term</B>= <A HREF="isom2005.html#0436" TARGET=body>factor</A>, { <A HREF="isom2005.html#0438" TARGET=body>factor operator</A>, <A HREF="isom2005.html#0436" TARGET=body>factor</A> } ; 
<P><B>factor</B>= <BR>
&quot;(&quot;, <A HREF="isom2005.html#0436" TARGET=body>expression</A>, &quot;)&quot; | <BR>
logical negation operator, <A HREF="isom2005.html#0436" TARGET=body>factor</A> | <BR>
<A HREF="isom2005.html#0439" TARGET=body>value designator</A> | <A HREF="isom2005.html#0444" TARGET=body>function call</A> | <BR>
<A HREF="isom2005.html#0445" TARGET=body>value constructor</A> | <A HREF="isom2005.html#0449" TARGET=body>constant literal</A> ; 
<P>Within one expression, operators shall be applied in decreasing order of precedence. If there are two or more operators of the same precedence within a single expression, simple expression, or term, these operators shall be applied from left to right. 
<P><B>Notes:</B> 
<OL>
 
<LI>The concrete syntax does not permit an expression to have two operators juxtaposed. </LI>
<LI>The concrete syntax defines four levels of operator precedence. From highest to lowest these are: logical negation operator, factor operators, term operators and signs, and relational operators. </LI>
<LI>Parentheses can be used in an expression to nest another expression, and they can be used to override the operator precedence. </LI>
</OL>

<P><B>Abstract Syntax</B> 
<P>annotations An expression in the concrete representation may include simple expressions and/or terms containing more than one operator. Such an expression is an abbreviation of a fully-parenthesized expression whose simple expressions contain at most one operator (a sign or a term operator) and whose terms contain at most one factor operator. The abstract syntax for expressions models fully-parenthesized expressions. For example, the expression <TT>a*b+c</TT> is an abbreviation of the fully-parenthesized expression <TT>(a*b)+c</TT>. It is modelled in the abstract syntax by an <I>Expression</I> that is an <I>InfixExpression</I>. 
<P><UL>
<LI><A HREF="#0143" TARGET=body>Ordinal Expressions</A>
<LI><A HREF="#0144" TARGET=body>Infix Expressions and Operations</A>
<LI><A HREF="#0159" TARGET=body> Prefix Expressions</A>
<LI><A HREF="#0162" TARGET=body>Value Designators</A>
<LI><A HREF="#0167" TARGET=body>Function Calls</A>
<LI><A HREF="#0168" TARGET=body>Value Constructors</A>
<LI><A HREF="#0172" TARGET=body>Constant Literals</A>
<LI><A HREF="#0179" TARGET=body>Constant Expressions</A>
</UL>
<P><HR>
<A NAME="0143">
<A HREF="#0142" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0142" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0144" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Ordinal Expressions</H3>

<P>An ordinal expression is an expression that produces an ordinal result. There are numerous places where this restriction is needed, and the concrete syntax has been designed to make this readily apparent when this occurs. 
<P><B>Concrete Syntax</B> 
<P><B>ordinal expression</B>= <A HREF="isom2005.html#0436" TARGET=body>expression</A> ; 
<P><HR>
<A NAME="0144">
<A HREF="#0142" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0143" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0145" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Infix Expressions and Operations</H3>

<P>An infix expression is an expression whose value is obtained by applying an infix operator to the values of two operands. 
<P><B>Concrete Syntax</B> 
<P><B>relational operator</B>= <BR>
equals operator | inequality operator | <BR>
less than operator | greater than operator | <BR>
less than or equal operator | subset operator | <BR>
greater than or equal operator | superset operator | <BR>
set membership operator ; 
<P><B>term operator</B>= <BR>
plus operator | set union operator | <BR>
minus operator | set difference operator | <BR>
logical disjunction operator | string catenate symbol ; 
<P><B>factor operator</B>= <BR>
multiplication operator | set intersection operator | <BR>
division operator | symmetric set difference operator | <BR>
rem operator | div operator | <BR>
mod operator | logical conjunction operator ; 
<P><B>Note:</B> The syntax for the various forms of infix operators is given in the Lexis &mdash; see Chapter ???.
<P><B>Dynamic Semantics</B> 
<P>If the operator of an infix expression is not a Boolean operator, the two expressions shall be evaluated, and then the infix operator shall be applied. 
<P><B>Note:</B> The evaluation order that applies when the operator is a Boolean operator is given in <A HREF="#0148" TARGET=body>Boolean Infix Operations</A>. 
<P>annotations In the case of an infix operator other than a Boolean operator, the above evaluation order for the left operand and the right operand is one of those permitted; the right operand may instead be evaluated before the left operand, or both may be evaluated in parallel &mdash; see ???.In the case of a Boolean operator, whether or not the right operand is evaluated depends upon the value of the left operand: the left operand is evaluated first, and, if necessary, the right operand is evaluated and the infix operation performed. 
<P><B>Auxiliaries</B> 
<P>annotations For any operand (of an infix expression) that is of the Z-type, the R-type or the C -type, check that its value is within the range of values defined by the type of that infix expression. 
<P><B>Infix Operations</B> 
<P><B>Abstract Syntax</B> 
<P>annotations For convenience of the description, infix operations are divided into seven classes. 
<P><UL>
<LI><A HREF="#0145" TARGET=body>Complex Number Infix Operations</A>
<LI><A HREF="#0146" TARGET=body>Real Number Infix Operations</A>
<LI><A HREF="#0147" TARGET=body>Whole Number Infix Operations</A>
<LI><A HREF="#0148" TARGET=body>Boolean Infix Operations</A>
<LI><A HREF="#0149" TARGET=body>Set Infix Operations</A>
<LI><A HREF="#0150" TARGET=body>String Literal Infix Operations</A>
<LI><A HREF="#0151" TARGET=body>Relational Operations</A>
</UL>
<P><HR>
<A NAME="0145">
<A HREF="#0144" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0144" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0146" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Complex Number Infix Operations</H4>

<P>For operands of a complex number type, there are four arithmetic infix operations: addition, subtraction, multiplica- tion, and division. These operations are denoted lexically by the symbols &lsquo;<TT>+</TT>&rsquo;<TT>,</TT>&rsquo; &lsquo;<TT>-</TT>&rsquo;, &lsquo;<TT>*</TT>&rsquo;, and &lsquo;<TT>/</TT>&rsquo; respectively. The result of a complex number infix operation is an approximation to the result of the corresponding mathematical operation. 
<P><B>Static Semantics</B> 
<P>A complex number infix operation whose operands are both of the C -type has a result that shall be of the C -type; a complex number infix operation with one operand that is of the C -type has a result that shall be of the same type as the other operand, which shall be of a complex number type. Otherwise both operands shall be of the identical complex number type, and the result shall also be of this type. 
<P><B>Note:</B> Given the types of two operands, the following table indicates the type of the result for those combinations that are permitted. 
<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid solid;border-width: 1px 1px 1px 1px">&nbsp;</TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid none solid none;border-width: 1px 0px 1px 0px">complex type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid none solid none;border-width: 1px 0px 1px 0px">long complex type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px">C -type </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px">complex type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">complex type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">error </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">complex type </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px">long complex type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">error </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">long complex type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">long complex type </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px">C -type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">complex type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">long complex type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">C -type </TD>
</TR>
</TABLE>
<P><B>Dynamic Semantics</B> 
<P>A complex number infix operation shall be performed with an accuracy that is determined by the types of its operands. This accuracy shall not decrease from the complex type to the long complex type, or from the long complex type to the C -type. 
<P>An exception shall be raised if a complex number infix operation leads to overflow. The value of a complex number infix operation that leads to underflow shall be an approximation to the mathematically correct result of the operation. 
<P><B>Notes:</B> 
<OL>
 
<LI>Underflow does not cause an exception to be raised. </LI>
<LI>&lsquo;Gradual underflow&rsquo; is different from &lsquo;underflow&rsquo;. It is defined in the Glossary, and discussed in ???.</LI>
</OL>

<P><B>Auxiliaries</B> 
<P>annotations The result of the function is undefined if the two parameters are not the same complex number type (unless at least one of the parameters is the C -type). 
<P>annotations The functions <I>complex-approximation</I> , <I>long-complex-approximation</I> , and <I>complex-constant-approximation</I> are implementation-defined and give approximations to the corresponding mathematical result. The order of non-decreasing accuracy of these functions is: <I>complex-approximation</I> , <I>long-complex-approximation</I> , <I>complex-constant-approximation</I> . 
<P><B>Complex Number Infix Operators</B> 
<P><B>Abstract Syntax</B> 
<P>annotations The above operators correspond to &lsquo;<TT>+</TT>&rsquo;, &lsquo;<TT>-</TT>&rsquo;, &lsquo;<TT>*</TT>&rsquo;, and &lsquo;<TT>/</TT>&rsquo; respectively. 
<P><B>Dynamic Semantics</B> 
<P>The evaluation of the left and right operands of a complex number infix operation shall result in two values, denoted by <TT>lval</TT> and <TT>rval</TT>. 
<P>The value of the complex number infix operation &lsquo;<TT>lval&nbsp;+&nbsp;rval</TT>&rsquo; shall be the value that results from the addition of the two values <TT>lval</TT> and <TT>rval</TT>. 
<P>The value of the complex number infix operation &lsquo;<TT>lval&nbsp;-&nbsp;rval</TT>&rsquo; shall be the value that results from subtracting the value <TT>rval</TT> from the value <TT>lval</TT>. 
<P>The value of the complex number infix operation &lsquo;<TT>lval&nbsp;*&nbsp;rval</TT>&rsquo; shall be the value that results from the multiplication of the two values <TT>lval</TT> and <TT>rval</TT>. 
<P>Provided that the magnitude of <TT>rval</TT> is non-zero, the value of the complex number infix operation &lsquo;<TT>lval&nbsp;/&nbsp;rval</TT>&rsquo; shall be the value that results from the division of the value <TT>lval</TT> by the value <TT>rval</TT>; otherwise an exception shall be raised. 
<P>annotations The operations +, -, *, and / that are used in the above definitions are the mathematical ones, which are of infinite precision. Hence the finite precision of actual implementations is mirrored by infinite precision followed by an approximation operation (performed by <I>get-complex-result</I> ). 
<P><HR>
<A NAME="0146">
<A HREF="#0144" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0145" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0147" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Real Number Infix Operations</H4>

<P>For operands of a real number type, there are four arithmetic infix operations: addition, subtraction, multiplication, and division. These operations are denoted lexically by the symbols &lsquo;<TT>+</TT>&rsquo;, &lsquo;<TT>-</TT>&rsquo;, &lsquo;<TT>*</TT>&rsquo;, and &lsquo;<TT>/</TT>&rsquo; respectively. The result of a real number infix operation is an approximation to the result of the corresponding mathematical operation. 
<P><B>Static Semantics</B> 
<P>A real number infix operation whose operands are both of the R-type has a result that shall be of the R-type; a real number infix operation with one operand that is of the R-type has a result that shall be of the same type as the other operand, which shall be of a real number type. Otherwise both operands shall be of the identical real number type, and the result shall also be of this type. 
<P><B>Note:</B> Given the types of two operands, the following table indicates the type of the result for those combinations that are permitted. 
<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid solid;border-width: 1px 1px 1px 1px">&nbsp;</TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid none solid none;border-width: 1px 0px 1px 0px">real type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid none solid none;border-width: 1px 0px 1px 0px">long real type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px">R-type</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px">real type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">real type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">error </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">real type</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px">long real type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">error </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">long real type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">long real type</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px">R-type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">real type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">long real type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">R-type </TD>
</TR>
</TABLE>
<P><B>Dynamic Semantics</B> 
<P>A real number infix operation shall be performed with an accuracy that is determined by the types of its operands. This accuracy shall not decrease from the real type to the long real type, or from the long real type to the R-type. 
<P>An exception shall be raised if a real number infix operation leads to overflow. The value of a real number infix operation that leads to underflow shall be an approximation to the mathematically correct result of the operation. 
<P><B>Notes:</B> 
<OL>
 
<LI>Underflow does not cause an exception to be raised. </LI>
<LI>&lsquo;Gradual underflow&rsquo; is different from &lsquo;underflow&rsquo;. It is defined in the Glossary, and discussed in ???.</LI>
</OL>

<P><B>Auxiliaries</B> 
<P>annotations The result of the function is undefined if the two parameters are not the same real number type (unless at least one of the parameters is the R-type). 
<P>annotations The functions <I>real-approximation</I> , <I>long-real-approximation</I> , and <I>real-constant-approximation</I> are implementation- defined and give approximations to the corresponding mathematical result. The order of non-decreasing accuracy of these functions is: <I>real-approximation, long-real-approximation , real-constant-approximation</I> . 
<P><B>Real Number Infix Operators</B> 
<P><B>Abstract Syntax</B> 
<P>annotations The above operators correspond to &lsquo;<TT>+</TT>&rsquo;, &lsquo;<TT>-</TT>&rsquo;, &lsquo;<TT>*</TT>&rsquo;, and &lsquo;<TT>/</TT>&rsquo; respectively. 
<P><B>Dynamic Semantics</B> 
<P>The evaluation of the left and right operands of a real number infix operation shall result in two values, denoted by <TT>lval</TT> and <TT>rval</TT>. 
<P>The value of the real number infix operation &lsquo;<TT>lval&nbsp;+&nbsp;rval</TT>&rsquo; shall be the value that results from the addition of the two values <TT>lval</TT> and <TT>rval</TT>. 
<P>The value of the real number infix operation &lsquo;<TT>lval&nbsp;-&nbsp;rval</TT>&rsquo; shall be the value that results from subtracting the value <TT>rval</TT> from the value <TT>lval</TT>. 
<P>The value of the real number infix operation &lsquo;<TT>lval&nbsp;*&nbsp;rval</TT>&rsquo; shall be the value that results from the multiplication of the two values <TT>lval</TT> and <TT>rval</TT>. 
<P>Provided that the value <TT>rval</TT> is non-zero, the value of the real number infix operation &lsquo;<TT>lval&nbsp;/&nbsp;rval</TT>&rsquo; shall be the value that results from the division of the value <TT>lval</TT> by the value <TT>rval</TT>; otherwise an exception shall be raised. 
<P>annotations The operations +, -, *, and / that are used in the above definitions are the mathematical ones, which are of infinite precision. Hence the finite precision of actual implementations is mirrored by infinite precision followed by an approximation operation (performed by <I>get-real-result</I> ). 
<P><HR>
<A NAME="0147">
<A HREF="#0144" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0146" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0148" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Whole Number Infix Operations</H4>

<P>For operands of a whole number type, there are seven arithmetic infix operations: addition, subtraction, multiplication, two forms of division, and two forms of remaindering. These operations are denoted lexically by the symbols &lsquo;<TT>+</TT>&rsquo;, &lsquo;<TT>-</TT>&rsquo;, &lsquo;<TT>*</TT>&rsquo;, &lsquo;<TT>/</TT>&rsquo;, &lsquo;<TT>DIV</TT>&rsquo;, &lsquo;<TT>REM</TT>&rsquo;, and &lsquo;<TT>MOD</TT>&rsquo; respectively. The result of a whole number infix operation is mathematically correct if it is within the range of values defined by the whole number type. 
<P><B>Change:</B> The operators &lsquo;<TT>/</TT>&rsquo; and &lsquo;<TT>REM</TT>&rsquo; are not described in <I>Programming in Modula-2</I> . 
<P><B>Static Semantics</B> 
<P>A whole number infix operation whose operands are both of the Z-type has a result that shall be of the Z-type; a whole number infix operation with one operand that is of the Z-type has a result that shall be of the same type as the other operand, which shall be of a whole number type. Otherwise both operands shall be of the identical whole number type, and the result shall also be of this type. 
<P><B>Note:</B> Given the types of two operands, the following table indicates the type of the result for those combinations that are permitted. 
<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid solid;border-width: 1px 1px 1px 1px">&nbsp;</TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid none solid none;border-width: 1px 0px 1px 0px">signed type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid none solid none;border-width: 1px 0px 1px 0px">unsigned type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px">Z-type</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px">signed type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">signed type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">error </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">signed type</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px">unsigned type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">error </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">unsigned type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">unsigned type</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px">Z-type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">signed type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">unsigned type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">Z-type </TD>
</TR>
</TABLE>
<P><B>Dynamic Semantics</B> 
<P>The value of a whole number infix operation shall be the mathematically correct result of the operation if the result is within the range of values defined by the result type. 
<P>An exception shall occur, and may be raised, if the result is not within the range of values defined by the result type. 
<P><B>Note:</B> If the result of a whole number infix operation is not within the range of values defined by the result type, an implementation for which the result type conforms to the requirements of ISO 10967-1:199x (LIA1) will raise the whole number overflow exception. 
<P><B>Auxiliaries</B> 
<P>annotations The result of the function is undefined if the two parameters are not the same whole number type (unless at least one of the parameters is the Z-type). 
<P><B>Whole Number Infix Operators</B> 
<P><B>Abstract Syntax</B> 
<P>annotations The above operators correspond to &lsquo;<TT>+</TT>&rsquo;, &lsquo;<TT>-</TT>&rsquo;, &lsquo;<TT>*</TT>&rsquo;, &lsquo;<TT>/</TT>&rsquo;, &lsquo;<TT>REM</TT>&rsquo;, &lsquo;<TT>DIV</TT>&rsquo;, and &lsquo;<TT>MOD</TT>&rsquo; respectively. 
<P><B>Dynamic Semantics</B> 
<P>The evaluation of the left and right operands of a whole number infix operation shall result in two values, denoted by <TT>lval</TT> and <TT>rval</TT>. 
<P>The value of the whole number infix operation &lsquo;<TT>lval&nbsp;+&nbsp;rval</TT>&rsquo; shall be the value that results from the addition of the two values <TT>lval</TT> and <TT>rval</TT>. 
<P>The value of the whole number infix operation &lsquo;<TT>lval&nbsp;-&nbsp;rval</TT>&rsquo; shall be the value that results from subtracting the value <TT>rval</TT> from the value <TT>lval</TT>. 
<P>The value of the whole number infix operation &lsquo;<TT>lval&nbsp;*&nbsp;rval</TT>&rsquo; shall be the value that results from the multiplication of the two values <TT>lval</TT> and <TT>rval</TT>. 
<P>The evaluation of the whole number infix operation &lsquo;<TT>lval&nbsp;/&nbsp;rval</TT>&rsquo; shall raise an exception if <TT>rval</TT> is zero; otherwise the value of the whole number infix operation shall be the value <TT>quotient</TT> which is such that the identity 
<P><TT>lval&nbsp;=&nbsp;rval&nbsp;*&nbsp;quotient&nbsp;+&nbsp;remainder</TT> 
<P>is satisfied for a value of <TT>remainder</TT> that is either zero, or an integer of the same sign as <TT>lval</TT> and of smaller absolute value than rval. 
<P><B>Note:</B> If <TT>x</TT> and y are whole numbers and <TT>y</TT> is not equal to zero, then <TT>(-x)/y&nbsp;=&nbsp;x/(-y)&nbsp;=&nbsp;-&nbsp;(x/y)</TT> 
<P>The evaluation of the whole number infix operation &lsquo;<TT>lval&nbsp;REM&nbsp;rval</TT>&rsquo; shall raise an exception if <TT>rval</TT> is zero; otherwise the value of the whole number infix operation shall be the value <TT>remainder</TT> which is such that the identity 
<P><TT>lval&nbsp;=&nbsp;rval&nbsp;*&nbsp;quotient&nbsp;+&nbsp;remainder</TT> 
<P>is satisfied for an integral value of <TT>quotient</TT>, and a value of <TT>remainder</TT> that is either zero, or an integer of the same sign as <TT>lval</TT> and of smaller absolute value than <TT>rval</TT>. 
<P>The evaluation of the whole number infix operation &lsquo;<TT>lval&nbsp;DIV&nbsp;rval</TT>&rsquo; shall raise an exception if <TT>rval</TT> is zero or negative; otherwise the value of the whole number infix operation shall be the value <TT>quotient</TT> which is such that the identity 
<P><TT>lval&nbsp;=&nbsp;rval&nbsp;*&nbsp;quotient&nbsp;+&nbsp;modulus</TT> 
<P>is satisfied for a value of <TT>modulus</TT> that is a non-negative integer less than <TT>rval</TT>. 
<P>The evaluation of the whole number infix operation &lsquo;<TT>lval&nbsp;MOD&nbsp;rval</TT>&rsquo; shall raise an exception if <TT>rval</TT> is zero or negative; otherwise the value of the whole number infix operation shall be the value <TT>modulus</TT> which is such that the identity 
<P><TT>lval&nbsp;=&nbsp;rval&nbsp;*&nbsp;quotient&nbsp;+&nbsp;modulus</TT> 
<P>is satisfied for an integral value of <TT>quotient</TT>, and a value of <TT>modulus</TT> that is a non-negative integer less than <TT>rval</TT>. 
<P><B>Note:</B> These operations are exemplified by the following table. 
<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid solid;border-width: 1px 1px 1px 1px"><I>op</I> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px">31<I>op</I>10 </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px">31<I>op</I>(-10) </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px">(-31)<I>op</I>10 </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px">(-31)<I>op</I>(-10)</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>/</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">3 </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">-3 </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">-3 </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">3</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>REM</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">1 </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">1 </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">-1 </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">-1</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>DIV</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">3 </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">Exception </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">-4 </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">Exception</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>MOD</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">1 </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">Exception </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">9 </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">Exception </TD>
</TR>
</TABLE>
<P><HR>
<A NAME="0148">
<A HREF="#0144" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0147" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0149" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Boolean Infix Operations</H4>

<P>For operands of the Boolean type, there are two Boolean infix operations: logical conjunction and logical disjunction. These operations are denoted lexically by the symbols &lsquo;<TT>AND</TT>&rsquo; and &lsquo;<TT>OR</TT>&rsquo; respectively. 
<P><B>Note:</B> The symbol &lsquo;<TT>&amp;</TT>&rsquo; may be used as a synonym for &lsquo;<TT>AND</TT>&rsquo;. 
<P><B>Static Semantics</B> 
<P>Both operands of a Boolean infix operation shall be of the Boolean type, and the result shall also be of the Boolean type. 
<P><B>Boolean Infix Operators</B> 
<P><B>Abstract Syntax</B> 
<P>annotations The above operators correspond to &lsquo;<TT>AND</TT>&rsquo; (or &lsquo;<TT>&amp;</TT>&rsquo;) and &lsquo;<TT>OR</TT>&rsquo; respectively. 
<P><B>Dynamic Semantics</B> 
<P>If the left operand to a logical conjunction operator has the value <I>false</I> , the value of the Boolean infix operation shall be the value <I>false</I> , and the right operand shall not be evaluated. If the left operand to a logical conjunction operator has the value <I>true</I> , the value of the Boolean infix operation shall be the value of the right operand. 
<P>If the left operand to a logical disjunction operator has the value <I>true</I> , the value of the Boolean infix operation shall be the value <I>true</I> , and the right operand shall not be evaluated. If the left operand to a logical disjunction operator has the value <I>false</I> , the value of the Boolean infix operation shall be the value of the right operand. 
<P><HR>
<A NAME="0149">
<A HREF="#0144" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0148" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0150" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Set Infix Operations</H4>

<P>For operands of a set type or of a packedset type, there are four set infix operations: set union, set difference, set intersection, and symmetric set difference. These operations are denoted lexically by the symbols &lsquo;<TT>+</TT>&rsquo;, &lsquo;<TT>-</TT>&rsquo;, &lsquo;<TT>*</TT>&rsquo;, and &lsquo;<TT>/</TT>&rsquo; respectively. 
<P><B>Note:</B> Set infix operations apply to operands of a set type and to operands of a packedset type. 
<P><B>Static Semantics</B> 
<P>Both operands of a set infix operation shall be of the identical set type, and the result shall also be of this type. 
<P><B>Dynamic Semantics</B> 
<P>annotations For each set, the actual set of values is contained in a composite object; the sets must be extracted in order to apply the operator, and then the result converted back to the appropriate composite type. 
<P><B>Set Infix Operators</B> 
<P><B>Abstract Syntax</B> 
<P>annotations The above operators correspond to &lsquo;<TT>+</TT>&rsquo;, &lsquo;<TT>-</TT>&rsquo;, &lsquo;<TT>*</TT>&rsquo;, and &lsquo;<TT>/</TT>&rsquo; respectively. 
<P><B>Dynamic Semantics</B> 
<P>The evaluation of the left and right operands of a set infix operation shall result in two values, called the &lsquo;left value&rsquo; and the &lsquo;right value&rsquo;. 
<P>The value of a set union operation shall be the set whose elements are elements of either the left value, or of the right value, or of both values. 
<P>The value of a set difference operation shall be the set whose elements are elements of the left value, but are not elements of the right value. 
<P>The value of a set intersection operation shall be the set whose elements are elements of both the left value and the right value. 
<P>The value of a symmetric set difference operation shall be the set whose elements are elements found in only one of the two values, left value and right value. 
<P><HR>
<A NAME="0150">
<A HREF="#0144" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0149" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0151" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>String Literal Infix Operations</H4>

<P>For operands of the string literal type, there is one string literal infix operation: string catenation. This operation is denoted lexically by the symbol &lsquo;<TT>+</TT>&rsquo;. 
<P><B>Change:</B> String catenation is not described in <I>Programming in Modula-2</I> . 
<P><B>Note:</B> String catenation is not applicable to variables of a concrete string type, or to constants of the character type. The examples below show both valid and invalid attempts to perform string catenation. 
<P><B>Example:</B> String catenation. 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;CONST
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CR&nbsp;=&nbsp;15C;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LF&nbsp;=&nbsp;12C;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LineEnd&nbsp;=&nbsp;CR&nbsp;+&nbsp;LF;		&nbsp;(*&nbsp;valid&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoubleLineEnd&nbsp;=&nbsp;LineEnd&nbsp;+&nbsp;LineEnd;&nbsp;(*&nbsp;valid&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greeting&nbsp;=&nbsp;&quot;hello&nbsp;&quot;&nbsp;+&nbsp;&quot;world&quot;;	&nbsp;(*&nbsp;valid,&nbsp;same&nbsp;as&nbsp;&quot;hello&nbsp;world&quot;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reply&nbsp;=&nbsp;&quot;hello&nbsp;&quot;&nbsp;+&nbsp;&quot;&quot;&nbsp;+&nbsp;&quot;world&quot;;	&nbsp;(*&nbsp;valid,&nbsp;same&nbsp;as&nbsp;&quot;hello&nbsp;world&quot;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String1&nbsp;=&nbsp;&quot;I&nbsp;said&nbsp;&quot;&nbsp;+&nbsp;Greeting;	&nbsp;(*&nbsp;valid,&nbsp;same&nbsp;as&nbsp;&quot;I&nbsp;said&nbsp;hello&nbsp;world&quot;&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String2&nbsp;=&nbsp;Greeting&nbsp;+&nbsp;CR;		&nbsp;(*&nbsp;valid&nbsp;*)

&nbsp;&nbsp;&nbsp;&nbsp;CONST
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linefeed&nbsp;=&nbsp;CHR(10);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String3&nbsp;=&nbsp;&quot;hello&quot;&nbsp;+&nbsp;Linefeed;	&nbsp;(*&nbsp;invalid,&nbsp;Linefeed&nbsp;is&nbsp;of&nbsp;type&nbsp;CHAR&nbsp;*)

&nbsp;&nbsp;&nbsp;&nbsp;VAR
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;who:&nbsp;ARRAY&nbsp;[0&nbsp;..&nbsp;79]&nbsp;OF&nbsp;CHAR;

&nbsp;&nbsp;&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;who&nbsp;:=&nbsp;Greeting&nbsp;+&nbsp;CR;		&nbsp;(*&nbsp;valid&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;who&nbsp;:=&nbsp;&quot;I&nbsp;said&nbsp;&quot;&nbsp;+&nbsp;who;		&nbsp;(*&nbsp;invalid,&nbsp;who&nbsp;is&nbsp;of&nbsp;a&nbsp;concrete&nbsp;string&nbsp;type&nbsp;*)
</PRE>

<P><B>Static Semantics</B> 
<P>Both operands of a string literal infix operation shall be of the string literal type, and the result shall also be of this type. 
<P><B>Dynamic Semantics</B> 
<P>The evaluation of the left and right operands of a string literal infix operation shall result in two values, called the &lsquo;left value&rsquo; and the &lsquo;right value&rsquo;. 
<P>The value of a string literal infix operation shall be the string value formed by the catenation of the right value to the end of the left value. 
<P><B>Clarification:</B> This International Standard has not adopted a change to Modula-2 (described in the fourth edition of Programming in Modula-2 ) of always requiring a string terminator for a string value. 
<P><HR>
<A NAME="0151">
<A HREF="#0144" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0150" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0152" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Relational Operations</H4>

<P>For operands of an elementary type, there are relational operations that provide tests for equality and inequality. These operations are denoted lexically by the symbols &lsquo;<TT>=</TT>&rsquo; and &lsquo;<TT>&lt;&gt;</TT>&rsquo; respectively. For operands of a scalar type, there are further relational operations that provide tests for ordering. These operations are denoted lexically by the symbols &lsquo;<TT>&lt;</TT>&rsquo;, &lsquo;<TT>&gt;</TT>&rsquo;, &lsquo;<TT>&lt;=</TT>&rsquo; and &lsquo;<TT>&gt;=</TT>&rsquo;. For operands of a set type or a packedset type, there are relational operations that provide set relationships, and an operation that provides a test for set membership. These operations are denoted lexically by the symbols &lsquo;<TT>&lt;=</TT>&rsquo;, &lsquo;<TT>&gt;=</TT>&rsquo; and &lsquo;<TT>IN</TT>&rsquo; respectively. 
<P><B>Note:</B> The symbol &lsquo;<TT>#</TT>&rsquo; may be used as a synonym for &lsquo;<TT>&lt;&gt;</TT>&rsquo;. 
<P><A NAME="0152">
<A HREF="#0151" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0151" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0153" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Complex Comparison Operations</H5>

<P>Two complex comparison operators are provided for operands of a complex number type. These operators are denoted lexically by the symbols &lsquo;<TT>=</TT>&rsquo; and &lsquo;<TT>&lt;&gt;</TT>&rsquo; (or &lsquo;<TT>#</TT>&rsquo;). 
<P><B>Static Semantics</B> 
<P>Both operands of a complex comparison operation shall be of types that are complex number types, and these types shall be expression-compatible. The result of a complex comparison operation shall be of the Boolean type. 
<P><B>Complex Comparison Operators</B> 
<P><B>Abstract Syntax</B> 
<P>annotations The above operators correspond to &lsquo;<TT>=</TT>&rsquo; and &lsquo;<TT>&lt;&gt;</TT>&rsquo; (or &lsquo;<TT>#</TT>&rsquo;) respectively. 
<P><B>Dynamic Semantics</B> 
<P>The evaluation of the left and right operands of a complex comparison operation shall result in two values. 
<P>The value of a complex equality operation shall be the value <I>true</I> if and only if the two values are the same. 
<P>The value of a complex inequality operation shall be the value <I>true</I> if and only if the two values are different. 
<P><B>Note:</B> A consequence of the approximation inherent in complex number types is that the result of a complex comparison operation will depend upon the nature of the approximation. 
<P><A NAME="0153">
<A HREF="#0151" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0152" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0154" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Scalar Relational Operations</H5>

<P>Six scalar relational operators are provided for operands of a scalar type. These operators are denoted lexically by the symbols &lsquo;<TT>=</TT>&rsquo;, &lsquo;<TT>&lt;&gt;</TT>&rsquo; (or &lsquo;<TT>#</TT>&rsquo;), &lsquo;<TT>&lt;</TT>&rsquo;, &lsquo;<TT>&gt;</TT>&rsquo;, &lsquo;<TT>&lt;=</TT>&rsquo;, and &lsquo;<TT>&gt;=</TT>&rsquo;. 
<P><B>Static Semantics</B> 
<P>Both operands of a scalar relational operation shall be of types that are scalar types, and these types shall be expression-compatible. The result of a scalar relational operation shall be of the Boolean type. 
<P><B>Note:</B> The Boolean type is an ordinal type with the value <I>false</I> being less than the value <I>true</I> . So, if <TT>p</TT> and <TT>q</TT> are operands of the Boolean type, &lsquo;<TT>p&nbsp;=&nbsp;q</TT>&rsquo; denotes their equivalence and &lsquo;<TT>p&nbsp;&lt;=&nbsp;q</TT>&rsquo; means &lsquo;<TT>p</TT> implies <TT>q</TT>&rsquo;. 
<P>Scalar Relational Operators 
<P><B>Abstract Syntax</B> 
<P>annotations The above operators correspond to &lsquo;<TT>=</TT>&rsquo;, &lsquo;<TT>&lt;&gt;</TT>&rsquo; (or &lsquo;<TT>#</TT>&rsquo;), &lsquo;<TT>&lt;</TT>&rsquo;, &lsquo;<TT>&gt;</TT>&rsquo;, &lsquo;<TT>&lt;=</TT>&rsquo; and &lsquo;<TT>&gt;=</TT>&rsquo; respectively. 
<P><B>Dynamic Semantics</B> 
<P>The evaluation of the left and right operands of a scalar relational operation shall result in two values, called the &lsquo;left value&rsquo; and the &lsquo;right value&rsquo;. 
<P>The value of a scalar equality operation shall be the value <I>true</I> if and only if the two values are the same. 
<P>The value of a scalar inequality operation shall be the value <I>true</I> if and only if the two values are different. 
<P>The value of a scalar less than operation shall be the value <I>true</I> if and only if the left value is less than the right value. 
<P>The value of a scalar greater than operation shall be the value <I>true</I> if and only if the left value is greater than the right value. 
<P>The value of a scalar less than or equal operation shall be the value <I>true</I> if and only if the left value is less than or equal to the right value. 
<P>The value of a scalar greater than or equal operation shall be the value <I>true</I> if and only if the left value is greater than or equal to the right value. 
<P><B>Note:</B> A consequence of the approximation inherent in real number types is that, for operands of these types, the result of a scalar relational operation will depend upon the nature of the approximation. 
<P><A NAME="0154">
<A HREF="#0151" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0153" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0155" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Set Relational Operations</H5>

<P>Five set relational operators are provided. These operators are denoted lexically by the symbols &lsquo;<TT>=</TT>&rsquo;, &lsquo;<TT>&lt;&gt;</TT>&rsquo; (or &lsquo;<TT>#</TT>&rsquo;), &lsquo;<TT>&lt;=</TT>&rsquo;, &lsquo;<TT>&gt;=</TT>&rsquo;, and &lsquo;<TT>IN</TT>&rsquo;. 
<P><B>Static Semantics</B> 
<P>Both operands of a set equality, set inequality, subset, or superset operation shall be of types that are set types, and these types shall be identical. 
<P>The right operand of a set membership operation shall be of a set type. The type of the left operand and the base type of the set type shall be assignment-compatible. 
<P>The result of a set relational operation shall be of the Boolean type. 
<P><B>Dynamic Semantics</B> 
<P>annotations The actual set of values is contained in a composite object, so the sets must be extracted in order to apply the operator. 
<P><B>Set Relational Operators</B> 
<P><B>Abstract Syntax</B> 
<P>annotations The above operators correspond to &lsquo;<TT>=</TT>&rsquo;, &lsquo;<TT>&lt;&gt;</TT>&rsquo; (or &lsquo;<TT>#</TT>&rsquo;), &lsquo;<TT>&lt;=</TT>&rsquo;, &lsquo;<TT>&gt;=</TT>&rsquo; and &lsquo;<TT>IN</TT>&rsquo; respectively. 
<P><B>Dynamic Semantics</B> 
<P>The evaluation of the left and right operands of a set relational operation shall result in two values, called the &lsquo;left value&rsquo; and the &lsquo;right value&rsquo;. 
<P>The value of a set equality operation shall be the value <I>true</I> if and only if the two values have the same elements. 
<P>The value of a set inequality operation shall be the value <I>true</I> if and only if the two values do not have the same elements. 
<P>The value of a subset operation shall be the value <I>true</I> if and only if all the elements of the left value are also in the right value. 
<P>The value of a superset operation shall be the value <I>true</I> if and only if all the elements of the right value are also in the left value. 
<P>The value of a set membership operation shall be the value <I>true</I> if and only if the left value is an element of the right value. 
<P><B>Note:</B> A consequence of the above rules is that &lsquo;<TT>1000&nbsp;IN&nbsp;DigitSet{0..9}</TT>&rsquo; produces a result of <I>false</I> , and no exception is raised. 
<P><B>Example:</B> Set complement. Given the declarations: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;TYPE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BaseType&nbsp;=&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetType&nbsp;=&nbsp;SET&nbsp;OF&nbsp;BaseType;
&nbsp;&nbsp;&nbsp;&nbsp;VAR
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s,&nbsp;complement&nbsp;:&nbsp;SetType;
</PRE>

<P>the complement of the set s can be calculated by: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;complement&nbsp;:=&nbsp;SetType{MIN(BaseType)..MAX(BaseType)}&nbsp;-&nbsp;s;
</PRE>

<P><A NAME="0155">
<A HREF="#0151" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0154" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0156" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Procedure Relational Operations</H5>

<P>Two procedure relational operators are provided for operands of a procedure type or a procedure structure. These operators are denoted lexically by the symbols &lsquo;<TT>=</TT>&rsquo; and &lsquo;<TT>&lt;&gt;</TT>&rsquo; (or &lsquo;<TT>#</TT>&rsquo;). 
<P><B>Static Semantics</B> 
<P>If both operands of a procedure relational operation are variables of a procedure type, those variables shall be of identical type. 
<P>If at least one of the operands of a procedure relational operation is a declared procedure, or a procedure constant, the operands shall be of identical structure. 
<P><B>Notes:</B> 
<OL>
 
<LI>The structure of a procedure, procedure constant, or procedure type is given by the number, formal types, and binding of the formal parameters, and by the function return type (in the case of a function procedure, function procedure constant, or function procedure type). </LI>
<LI>Standard procedures and system procedures may not be operands in a procedure relational operation. </LI>
</OL>

<P><B>Example:</B> Procedure relational operations. 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;Relations(fp:&nbsp;INTEGER);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;A(fp:&nbsp;CARDINAL);&nbsp;BEGIN&nbsp;END&nbsp;A;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;B(fp:&nbsp;CARDINAL);&nbsp;BEGIN&nbsp;END&nbsp;B;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;C(fp:&nbsp;INTEGER);&nbsp;BEGIN&nbsp;END&nbsp;C;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE&nbsp;TC1&nbsp;=&nbsp;PROCEDURE(CARDINAL);&nbsp;TC2&nbsp;=&nbsp;PROCEDURE(CARDINAL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONST&nbsp;AA&nbsp;=&nbsp;A;&nbsp;untrue&nbsp;=&nbsp;(A&nbsp;=&nbsp;B);&nbsp;(*&nbsp;valid&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;VC1a,&nbsp;VC1b:&nbsp;TC1;&nbsp;VC2:&nbsp;TC2;
&nbsp;&nbsp;&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VC1a&nbsp;:=&nbsp;A;&nbsp;VC1b&nbsp;:=&nbsp;AA;&nbsp;VC2&nbsp;:=&nbsp;B;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF&nbsp;VC1a&nbsp;=&nbsp;VC1b&nbsp;THEN&nbsp;END&nbsp;;&nbsp;(*&nbsp;valid&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF&nbsp;VC1a&nbsp;=&nbsp;VC2&nbsp;THEN&nbsp;END&nbsp;;&nbsp;(*&nbsp;invalid&nbsp;-&nbsp;different&nbsp;types&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF&nbsp;VC1a&nbsp;=&nbsp;B&nbsp;THEN&nbsp;END&nbsp;;&nbsp;(*&nbsp;valid&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF&nbsp;VC1a&nbsp;=&nbsp;C&nbsp;THEN&nbsp;END&nbsp;;&nbsp;(*&nbsp;invalid&nbsp;-&nbsp;different&nbsp;structure&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF&nbsp;Relations&nbsp;=&nbsp;C&nbsp;THEN&nbsp;END&nbsp;;&nbsp;(*&nbsp;valid&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;Relations;
</PRE>

<P>The result of a procedure relational operation shall be of the Boolean type. 
<P><B>Procedure Relational Operators</B> 
<P><B>Abstract Syntax</B> 
<P>annotations The above operators correspond to &lsquo;<TT>=</TT>&rsquo; and &lsquo;<TT>&lt;&gt;</TT>&rsquo; (or &lsquo;<TT>#</TT>&rsquo;) respectively. 
<P><B>Clarification:</B> <I>Programming in Modula-2</I> does not state whether the equality and inequality operators are applicable to values that are procedures. 
<P><B>Dynamic Semantics</B> 
<P>The value of a procedure equality operation shall be the value <I>true</I> if and only if the values of both operands denote the same procedure text. 
<P>The value of a procedure inequality operation shall be the value <I>true</I> if and only if the values of both operands do not denote the same procedure text. 
<P><A NAME="0156">
<A HREF="#0151" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0155" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0157" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Pointer Relational Operations</H5>

<P>Two pointer relational operators are provided for operands of a pointer type or an opaque type. These operators are denoted lexically by the symbols &lsquo;<TT>=</TT>&rsquo; and &lsquo;<TT>&lt;&gt;</TT>&rsquo; (or &lsquo;<TT>#</TT>&rsquo;). 
<P><B>Static Semantics</B> 
<P>One of the following shall hold for the operands of a pointer relational operation: 
<P>a) both operands are of identical opaque type, 
<P>b) both operands are of identical pointer type, 
<P>c) one operand is of a pointer type and the value of the other is the nil value. 
<P>d) both operands have the nil value. 
<P><B>Note:</B> The nil value is that denoted by the pervasive identifier <TT>NIL</TT> &mdash; see <A HREF="#0205" TARGET=body>The Nil Type</A>. 
<P>The result of a pointer relational operation shall be of the Boolean type. 
<P><B>Clarification:</B> This International Standard agrees with the third edition of <I>Programming in Modula-2</I> , which allows the equality and inequality operators to be applied to values of an opaque type. 
<P>annotations Opaque types are indistinguishable from pointer types with respect to the meaning function. The well-formed conditions forbid the dereferencing of a value of an opaque type outside of the implementation module in which the opaque type is declared &mdash; see <A HREF="#0141" TARGET=body>Dereferenced Designators</A>. 
<P><B>Pointer Relational Operators</B> 
<P><B>Abstract Syntax</B> 
<P>annotations The above operators correspond to &lsquo;<TT>=</TT>&rsquo; and &lsquo;<TT>&lt;&gt;</TT>&rsquo; (or &lsquo;<TT>#</TT>&rsquo;) respectively. 
<P><B>Dynamic Semantics</B> 
<P>The value of a pointer equality operation shall be the value <I>true</I> if and only if the values of both operands denote the same variable, or if they both have the nil value. 
<P>The value of a pointer inequality operation shall be the value <I>true</I> if and only if the values of both operands do not denote the same variable, and if they do not both have the nil value. 
<P><B>Note:</B> Since pointer values can be constructed via <TT>SYSTEM.MAKEADR</TT>, these semantics are defined in terms of the underlying model rather than the objects held in the store. 
<P><A NAME="0157">
<A HREF="#0151" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0156" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0158" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Protection Relational Operations</H5>

<P>Two protection relational operators are provided for operands of the implementation-defined protection type. These operators are denoted lexically by the symbols &lsquo;<TT>&lt;=</TT>&rsquo; and &lsquo;<TT>&gt;=</TT>&rsquo;. The protection relational operators are those that are common both to ordinal types and to set types &mdash; see <A HREF="#0208" TARGET=body>The Protection Type</A>. 
<P><B>Static Semantics</B> 
<P>Both operands of a protection relational operation shall be of the protection type. 
<P>The result of a protection relational operation shall be of the Boolean type. 
<P><B>Protection Relational Operators</B> 
<P><B>Abstract Syntax</B> 
<P>annotations The above operators correspond to &lsquo;<TT>&lt;=</TT>&rsquo; and &lsquo;<TT>&gt;=</TT>&rsquo; respectively. 
<P><B>Dynamic Semantics</B> 
<P>The value of a protection less than or equal operation, or a protection greater than or equal operation, shall depend on the implementation-defined order of the values of the protection type. The ordering shall be such that a value P1 of the protection type shall compare less than or equal to another value P2 if and only if P1 does not prevent any of the interrupts not prevented by P2. 
<P><A NAME="0158">
<A HREF="#0151" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0157" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0159" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>System Basic Types Relational Operations</H5>

<P>Two relational operators are provided for operands of a system basic type, other than the location type. These operators are denoted lexically by the symbols &lsquo;<TT>=</TT>&rsquo; and &lsquo;<TT>&lt;&gt;</TT>&rsquo; (or &lsquo;<TT>#</TT>&rsquo;). 
<P>The system basic type whose values may be compared for equality and inequality is the coroutine type &mdash; see <A HREF="isom2004.html#0327" TARGET=body>The Module COROUTINES</A>. The interrupt source type, which is also defined by the system module <TT>COROUTINES</TT>, is an implementation-defined type that may be identical to a basic type or may be a predefined constructed type; corresponding operations will therefore be applicable to that type. 
<P>The only operation directly defined on the location type is assignment &mdash; see <A HREF="isom2004.html#0306" TARGET=body>The Module SYSTEM</A>. Values of the location type may only be compared if they are first interpreted as a value of another type using <TT>SYSTEM.CAST</TT>. 
<P><B>Static Semantics</B> 
<P>The operands of a system basic type relational operation shall be of identical type. 
<P>The result of a system basic type relational operation shall be of the Boolean type. 
<P><B>System Basic Types Relational Operators</B> 
<P><B>Abstract Syntax</B> 
<P>annotations The above operators correspond to &lsquo;<TT>=</TT>&rsquo; and &lsquo;<TT>&lt;&gt;</TT>&rsquo; (or &lsquo;<TT>#</TT>&rsquo;) respectively. 
<P><B>Dynamic Semantics</B> 
<P>The value of a system basic type equality operation shall be the value <I>true</I> if and only if the values of both operands are the same, and hence identify the same coroutine. 
<P>The value of a system basic type inequality operation shall be the value <I>true</I> if and only if the values of both operands are not the same, and hence do not identify the same coroutine. 
<P><HR>
<A NAME="0159">
<A HREF="#0142" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0158" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0160" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3> Prefix Expressions</H3>

<P>A prefix expression is an expression whose value is obtained by applying a prefix operator to the value of a single operand. 
<P><B>Concrete Syntax</B> 
<P><B>Note:</B> The syntax for the various forms of prefix operators is given in the Lexis &mdash; see Chapter ???.
<P><B>Dynamic Semantics</B> 
<P>The expression shall be evaluated first, and then the prefix operator shall be applied. 
<P><B>Prefix Operations</B> 
<P><B>Abstract Syntax</B> 
<P>annotations For convenience of the description, prefix operations are divided into two classes. 
<P><UL>
<LI><A HREF="#0160" TARGET=body>Arithmetic Prefix Operations</A>
<LI><A HREF="#0161" TARGET=body>Boolean Prefix Operations</A>
</UL>
<P><HR>
<A NAME="0160">
<A HREF="#0159" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0159" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0161" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Arithmetic Prefix Operations</H4>

<P>There are two arithmetic prefix operations: identity and arithmetic negation. These operations are denoted lexically by the symbols &lsquo;<TT>+</TT>&rsquo; and &lsquo;<TT>-</TT>&rsquo; respectively. If the operand of an arithmetic prefix operation is of a complex number type or a real number type, the result of the operation is an approximation to the result of the corresponding mathematical operation. If the operand is of a whole number type, the result of the operation is mathematically correct if it is within the range of values defined by the whole number type. 
<P><B>Static Semantics</B> 
<P>The operand of an arithmetic prefix operation shall be of a complex number type, a real number type or a whole number type, except that the arithmetic negation operator shall not be applied to an operand of an unsigned type. 
<P><B>Note:</B> The semantics disallow the use of the arithmetic negation operator in an expression such as <TT>(-a+b)</TT> when the type of the expression is the unsigned type. 
<P><B>Dynamic Semantics</B> 
<P>The value of an arithmetic prefix operation shall be the mathematically correct result of the operation if the result is within the range of values defined by the type of the operand. 
<P>An exception shall be raised if the result is not within the range of values defined by the type of the operand. 
<P><B>Note:</B> An exception may be raised if the arithmetic negation operator is applied to an operand of a numeric type that has a non-symmetric range. 
<P><B>Auxiliaries</B> 
<P>annotations Return the type of an arithmetic prefix operation. The result is undefined if the arithmetic negation operator is applied to a value of an unsigned type or if it is applied to a value of a non-numeric type. 
<P><B>Arithmetic Prefix Operators</B> 
<P><B>Abstract Syntax</B> 
<P>annotations The above operators correspond to &lsquo;<TT>+</TT>&rsquo; and &lsquo;<TT>-</TT>&rsquo; respectively. 
<P><B>Dynamic Semantics</B> 
<P>The value of an identity operation shall be the value of its operand. 
<P>The value of an arithmetic negation operation shall be the additive inverse of the value of its operand. 
<P><HR>
<A NAME="0161">
<A HREF="#0159" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0160" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0162" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Boolean Prefix Operations</H4>

<P>There is one Boolean prefix operation: logical negation. This operation is denoted lexically by the symbol &lsquo;<TT>NOT</TT>&rsquo;. 
<P><B>Note:</B> The symbol &lsquo;<TT>~</TT>&rsquo; may be used as a synonym for &lsquo;<TT>NOT</TT>&rsquo;. 
<P><B>Static Semantics</B> 
<P>The operand of a Boolean prefix operation shall be of the Boolean type. 
<P><B>Boolean Prefix Operators</B> 
<P><B>Abstract Syntax</B> 
<P>annotations The above operator corresponds to &lsquo;<TT>NOT</TT>&rsquo; or &lsquo;<TT>~</TT>&rsquo;. 
<P><B>Dynamic Semantics</B> 
<P>The value of a Boolean prefix operation shall be the value <I>true</I> if its operand has the value <I>false</I> , or <I>false</I> if its operand has the value <I>true</I> . 
<P><HR>
<A NAME="0162">
<A HREF="#0142" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0161" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0163" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Value Designators</H3>

<P>A value designator is an expression denoting a constant, a variable (including a formal parameter of a procedure), a component of a constant or variable, or a procedure. 
<P><B>Concrete Syntax</B> 
<P><B>value designator</B>= <BR>
<A HREF="isom2005.html#0440" TARGET=body>entire value</A> | <A HREF="isom2005.html#0441" TARGET=body>indexed value</A> | <BR>
<A HREF="isom2005.html#0442" TARGET=body>selected value</A> | <A HREF="isom2005.html#0443" TARGET=body>dereferenced value</A> ; 
<P><UL>
<LI><A HREF="#0163" TARGET=body>Entire Values</A>
<LI><A HREF="#0164" TARGET=body>Indexed Values</A>
<LI><A HREF="#0165" TARGET=body>Selected Values</A>
<LI><A HREF="#0166" TARGET=body>Dereferenced Values</A>
</UL>
<P><HR>
<A NAME="0163">
<A HREF="#0162" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0162" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0164" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Entire Values</H4>

<P>An entire value is a value designator that is a qualified identifier; it denotes a constant, a variable (which may be a formal parameter), a field of a record within a with statement that applies to that record, or a declared procedure. 
<P><B>Concrete Syntax</B> 
<P><B>entire value</B>= <A HREF="isom2005.html#0381" TARGET=body>qualified identifier</A> ; 
<P><B>Abstract Syntax</B> 
<P>annotations Within the body of a with statement, an entire value may also be the field identifier of a record that has been specified in the designator component of the with statement. 
<P><B>Static Semantics</B> 
<P>The qualified identifier of an entire value shall denote a constant, a variable (which may be a formal parameter), a field of a record within a with statement that applies to that record, or a procedure. 
<P>If the type of the entity denoted by the qualified identifier is a subrange type, the type of the entire value shall be the host type of that subrange type; otherwise it shall be the type of the entity denoted by the qualified identifier. 
<P>annotations The type information for a procedure or procedure constant includes its structure and its declaration level. 
<P><B>Dynamic Semantics</B> 
<P>The value of an entire value shall be the value of the entity denoted by the qualified identifier. 
<P>An exception shall occur (but need not be raised) if the entity denoted by the qualified identifier is a variable of an elementary type whose value is undefined. 
<P><B>Note:</B> The value of a variable might be undefined because no value has been assigned to that variable, or because the variable is a component of a variant and either that variant is not active or no value has been assigned to that component since the variant was made active. 
<P><HR>
<A NAME="0164">
<A HREF="#0162" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0163" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0165" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Indexed Values</H4>

<P>An indexed value is an expression that is an array value followed by one or more index expressions, and it denotes a component of the indexed array value, or a component of a component of the indexed array value. 
<P><B>Concrete Syntax</B> 
<P><B>indexed value</B>= <A HREF="isom2005.html#0441" TARGET=body>array value</A>, &quot;[&quot;, <A HREF="isom2005.html#0433" TARGET=body>index expression</A>, { &quot;,&quot;, <A HREF="isom2005.html#0433" TARGET=body>index expression</A> }, &quot;]&quot; ; 
<P><B>array value</B>= <A HREF="isom2005.html#0439" TARGET=body>value designator</A> ; 
<P>The concrete syntax allows for a full or abbreviated representation of the indexing of an array value that is itself an indexed value. In the abbreviated form, a single comma shall replace the sequence &lsquo;<TT>]&nbsp;[</TT>&rsquo; that occurs in the full form. The abbreviated form and the full form shall be equivalent. 
<P><B>Example:</B> Indexing of an indexed value. A value designator of the form: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;A[E1][E2][E3]
</PRE>

<P>may also be written in the following ways: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;A[E1,E2,E3]&nbsp;A[E1][E2,E3]&nbsp;A[E1,E2][E3]
</PRE>

<P><B>Abstract Syntax</B> 
<P>annotations The abstract syntax only uses the full form. 
<P><B>Static Semantics</B> 
<P>The array value of an indexed value shall be a value designator that is of an array type. The type of the index expression shall be assignment-compatible with the index type of the array type. 
<P>If the component type of the array type is a subrange type, the type of an indexed value shall be the host type of that component type; otherwise it shall be the component type of the array type. 
<P><B>Note:</B> An indexed value cannot be formed by indexing a string constant. 
<P><B>Dynamic Semantics</B> 
<P>The value designator shall be evaluated to give an array value. The index expression shall be evaluated to give an ordinal value. Provided that this ordinal value is a value of the index type of the array value, the value of the indexed value shall be the value of the component of the array value indexed by the ordinal value; otherwise an exception shall be raised. 
<P>The order of evaluation of the value designator and the index expression of an indexed value shall be implementation- dependent. 
<P><B>Note:</B> If a function call appears in the index expression, the evaluation of the indexed value could produce a transfor- mation of the program state, i.e. have side-effects. 
<P>annotations The above evaluation order for the array value and the index expression is one of those permitted; the index expression may instead be evaluated before the array value, or both may be evaluated in parallel | see 4.1. 
<P><HR>
<A NAME="0165">
<A HREF="#0162" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0164" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0166" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Selected Values</H4>

<P>A selected value is an expression that is a record value followed by a field identifier, and it denotes the value of the identified field of the record value. 
<P><B>Concrete Syntax</B> 
<P><B>selected value</B>= <A HREF="isom2005.html#0442" TARGET=body>record value</A>, &quot;.&quot;, <A HREF="isom2005.html#0434" TARGET=body>field identifier</A> ; 
<P><B>record value</B>= <A HREF="isom2005.html#0439" TARGET=body>value designator</A> ; 
<P><B>Static Semantics</B> 
<P>The record value of a selected value shall be a value designator that is of a record type. The field identifier shall be one of the identifiers or tag identifiers of the field list of that record type. 
<P>If the the type of the field denoted by the field identifier is a subrange type, the type of a selected value shall be the host type of the type of the denoted field; otherwise it shall be the type of that field. 
<P><B>Dynamic Semantics</B> 
<P>The value designator shall be evaluated to give a record value. Provided that the field identifier denotes a component of a variant of the record type that is a component of the record value, the value of the selected value shall be the value of the component of the record value selected by the field identifier; otherwise an exception shall occur (but need not be raised). 
<P><HR>
<A NAME="0166">
<A HREF="#0162" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0165" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0167" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Dereferenced Values</H4>

<P>A dereferenced value is an expression that is a pointer value followed by a dereferencing operator, and it denotes the value of the variable (if any) that is referenced by the pointer value. 
<P><B>Concrete Syntax</B> 
<P><B>dereferenced value</B>= <A HREF="isom2005.html#0443" TARGET=body>pointer value</A>, dereferencing operator ; 
<P><B>pointer value</B>= <A HREF="isom2005.html#0439" TARGET=body>value designator</A> ; 
<P><B>Static Semantics</B> 
<P>The pointer value of a dereferenced value shall be a value designator that is of a pointer type. 
<P>If the the type of the bound type specified in the declaration of the pointer type is a subrange type, the type of a dereferenced value shall be the host type of the bound type; otherwise it shall be the bound type. 
<P><B>Dynamic Semantics</B> 
<P>The value designator shall be evaluated to give a pointer value. Provided that this pointer value denotes a variable, the value of the dereferenced value shall be the value of that variable. 
<P>An exception shall be raised if the pointer value is the nil value. 
<P>An exception shall occur (but need not be raised) if the pointer value is undefined. 
<P>An exception shall occur (but need not be raised) if the value is a pointer to a variable of the wrong type. 
<P><B>Note:</B> Since the address type is assignment compatible with all pointer types, the value may be a pointer to a variable of the wrong type if it has been assigned through a variable or parameter of the address type. 
<P><HR>
<A NAME="0167">
<A HREF="#0142" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0166" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0168" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Function Calls</H3>

<P>A function call specifies the evaluation of any actual parameters and the activation and execution of the block associated with the function designator of the function call. The value of a function call is the value returned by the execution of this block. 
<P><B>Concrete Syntax</B> 
<P><B>function call</B>= <A HREF="isom2005.html#0444" TARGET=body>function designator</A>, <A HREF="isom2005.html#0452" TARGET=body>actual parameters</A> ; 
<P><B>function designator</B>= <A HREF="isom2005.html#0439" TARGET=body>value designator</A> ; 
<P><B>Abstract Syntax</B> 
<P>annotations The identifiers of predefined procedures are distinguished since these do not denote values (that can be assigned or compared in expressions). 
<P><B>Static Semantics</B> 
<P>The function designator of a function call shall be a value designator that denotes a function procedure or the identifier of a predefined function procedure. 
<P><B>Notes:</B> 
<OL>
 
<LI>A value designator that denotes a function procedure is either a procedure identifier of a function procedure heading (possibly qualified by the name or names of modules from which the procedure identifier is exported), a value designator that denotes a constant that has a function procedure value, or a value designator that denotes a variable that has a function procedure type. </LI>
<LI>The identifiers of predefined procedures are not value designators since predefined procedures are not values that can be assigned, compared in expressions, or passed as procedure parameters. </LI>
</OL>

<P>In the case of a call of a predefined function procedure, the actual parameters shall correspond in number and in type to those required for that predefined function; otherwise, each actual parameter shall be parameter compatible with the corresponding formal parameter of the designated function procedure. 
<P>If the return type of the designated function procedure is a subrange type, then the type of the function call shall be the host type of that subrange type; otherwise it shall be the return type of the designated function procedure. 
<P><B>Dynamic Semantics</B> 
<P>The execution of a function call shall be the evaluation of any actual parameters to give corresponding arguments, the binding of the results of this evaluation to the corresponding formal parameters, and the execution of the actions associated with the function designator. In the case of a call of a predefined function, the actions are as specified for that predefined function; otherwise, the actions are as specified by the block of the function procedure declaration. 
<P>The order of evaluation, the order of accessing and the order of binding of the actual parameters shall be implementation-dependent. The order of evaluation of the function designator and the actual parameters shall be implementation-dependent. 
<P>The actual parameters shall be evaluated before the execution of the actions associated with the function procedure designator. 
<P>The value of a function call shall be the value returned by the execution of the associated actions. 
<P>annotations The above evaluation order for the function designator and the actual parameters is one of those permitted; the actual parameters may instead be evaluated before the function designator, or both may be evaluated in parallel | see 4.1. 
<P><HR>
<A NAME="0168">
<A HREF="#0142" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0167" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0169" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Value Constructors</H3>

<P>A value constructor is an expression denoting a value of an array type, a record type, or a set type. In the case of array constructors and record constructors a list of values, known as &lsquo;structure components&rsquo;, is specified to define the values of the components of the array value or the fields of the record value. In the case of a set constructor a list of &lsquo;members&rsquo; is specified, whose elements define the elements of the set value. 
<P><B>Change:</B> Array constructors and record constructors are not described in <I>Programming in Modula-2</I> . 
<P><B>Note:</B> The syntax of each form of value constructor requires a type identifier, and so a value constructor cannot be used to denote a value for a variable or a constant of an anonymous type. 
<P><B>Concrete Syntax</B> 
<P><B>value constructor</B>= <A HREF="isom2005.html#0446" TARGET=body>array constructor</A> | <A HREF="isom2005.html#0447" TARGET=body>record constructor</A> | <A HREF="isom2005.html#0448" TARGET=body>set constructor</A> ; 
<P><UL>
<LI><A HREF="#0169" TARGET=body>Array Constructors</A>
<LI><A HREF="#0170" TARGET=body>Record Constructors</A>
<LI><A HREF="#0171" TARGET=body>Set Constructors</A>
</UL>
<P><HR>
<A NAME="0169">
<A HREF="#0168" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0168" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0170" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Array Constructors</H4>

<P>An array constructor is an expression that denotes a value of a specified array type. The array type is specified by an array type identifier. The array value is specified by an array constructed value that has a structure component for each component of the array. The repetition of a structure component may be specified by giving an optional repetition factor. 
<P><B>Note:</B> An array constructor cannot denote a value for a formal parameter that is an open array parameter. 
<P><B>Concrete Syntax</B> 
<P><B>array constructor</B>= <A HREF="isom2005.html#0446" TARGET=body>array type identifier</A>, <A HREF="isom2005.html#0446" TARGET=body>array constructed value</A> ; 
<P><B>array type identifier</B>= <A HREF="isom2005.html#0396" TARGET=body>type identifier</A> ; 
<P>array type identifier = type identifier ; <B>Example:</B> Array constructors. Given the declarations: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;TYPE&nbsp;StringType&nbsp;=&nbsp;ARRAY&nbsp;[0..24]&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;	&nbsp;RowType&nbsp;=&nbsp;ARRAY&nbsp;[1..3]&nbsp;OF&nbsp;REAL;
&nbsp;&nbsp;	&nbsp;Array1Type&nbsp;=&nbsp;ARRAY&nbsp;[1..2]&nbsp;OF&nbsp;RowType;
&nbsp;	&nbsp;Array2Type&nbsp;=&nbsp;ARRAY&nbsp;[1..2],&nbsp;[1..3]&nbsp;OF&nbsp;REAL;
&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;&nbsp;filler:&nbsp;CHAR;
&nbsp;&nbsp;	&nbsp;string:&nbsp;StringType;
&nbsp;	&nbsp;row:&nbsp;RowType;
&nbsp;&nbsp;	&nbsp;array1:&nbsp;Array1Type;
&nbsp;&nbsp;	&nbsp;array2:&nbsp;Array2Type;
</PRE>

<P>the following statements are possible: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;string:=&nbsp;StringType{'&nbsp;'&nbsp;BY&nbsp;25};
&nbsp;&nbsp;&nbsp;&nbsp;string:=&nbsp;StringType{filler&nbsp;BY&nbsp;25};
&nbsp;&nbsp;&nbsp;&nbsp;string:=&nbsp;StringType{filler,&nbsp;'&nbsp;'&nbsp;BY&nbsp;23,&nbsp;filler};
&nbsp;&nbsp;&nbsp;&nbsp;row:=&nbsp;RowType{1.0,&nbsp;1.0,&nbsp;1.0};
&nbsp;&nbsp;&nbsp;&nbsp;row:=&nbsp;RowType{1.0&nbsp;BY&nbsp;3};
&nbsp;&nbsp;&nbsp;&nbsp;array1:=&nbsp;Array1Type{row,&nbsp;row};
&nbsp;&nbsp;&nbsp;&nbsp;array1:=&nbsp;Array1Type{row&nbsp;BY&nbsp;2};
&nbsp;&nbsp;&nbsp;&nbsp;array1:=&nbsp;Array1Type{RowType{1.0,&nbsp;1.0,&nbsp;1.0},
&nbsp;&nbsp;			RowType{1.0,&nbsp;1.0,&nbsp;1.0}};
&nbsp;&nbsp;&nbsp;&nbsp;array1:=&nbsp;Array1Type{RowType{1.0,&nbsp;1.0,&nbsp;1.0}&nbsp;BY&nbsp;2};
&nbsp;&nbsp;&nbsp;&nbsp;array1:=&nbsp;Array1Type{{1.0,&nbsp;1.0,&nbsp;1.0},&nbsp;{1.0,&nbsp;1.0,&nbsp;1.0}};
&nbsp;&nbsp;&nbsp;&nbsp;array1:=&nbsp;Array1Type{{1.0,&nbsp;1.0,&nbsp;1.0}&nbsp;BY&nbsp;2};
&nbsp;&nbsp;&nbsp;&nbsp;array1:=&nbsp;Array1Type{{1.0&nbsp;BY&nbsp;3}&nbsp;BY&nbsp;2};
&nbsp;&nbsp;&nbsp;&nbsp;array2:=&nbsp;Array2Type{{1.0,&nbsp;1.0,&nbsp;1.0},&nbsp;{1.0,&nbsp;1.0,&nbsp;1.0}};
&nbsp;&nbsp;&nbsp;&nbsp;array2:=&nbsp;Array2Type{{1.0,&nbsp;1.0,&nbsp;1.0}&nbsp;BY&nbsp;2};
&nbsp;&nbsp;&nbsp;&nbsp;array2:=&nbsp;Array2Type{{1.0&nbsp;BY&nbsp;3}&nbsp;BY&nbsp;2};
</PRE>

<P><B>Static Semantics</B> 
<P>The array type identifier of an array constructor shall be a type identifier that denotes an array type. The type of the array constructor shall be that array type. 
<P>The array constructed value of an array constructor shall be well-formed with respect to a given array type that is the type of the array constructor. 
<P><B>Dynamic Semantics</B> 
<P>The value of an array constructor shall be the value of the array constructed value evaluated as a value of the type of the array constructor. 
<P>annotations Note that an exception may be detected as each individual component is evaluated. 
<P><B>Array Constructed Values</B> 
<P>An array constructed value denotes a value of an array type by specifying a structure component for each component of the array. It can either form part of an array constructor, or it can be used as a structure component of an array constructor or a record constructor. 
<P>Array constructed values are evaluated as a value of a given type. This type is specified explicitly by the type identifier in the case of array constructors. For structure components, the type is implicitly the component type of an array type or the corresponding field type of a record type. 
<P><B>Concrete Syntax</B> 
<P><B>array constructed value</B>= <BR>
&quot;{&quot;, <A HREF="isom2005.html#0446" TARGET=body>repeated structure component</A>, { &quot;,&quot;, <A HREF="isom2005.html#0446" TARGET=body>repeated structure component</A> }, &quot;}&quot; ; 
<P><B>Static Semantics</B> 
<P>The sequence of repeated structure components of an array constructed value of a given array type shall be taken, one at a time, in the order that the repeated structure components appear in the sequence of repeated structure components. Each repeated structure component having a repetition factor of N shall lead to N consecutive occurrences of its structure component in a sequence of structure components. The length of this sequence of structure components shall be equal to the number of values of the range of values defined by the index type of the given array type. 
<P>The structure components shall be well-formed with respect to a structure component type that is the component type of the given array type. 
<P>annotations Check that the number of structure components of an array definition is the same as the number of values of the range of values defined by the index type of the array type. 
<P><B>Dynamic Semantics</B> 
<P>The value of an array constructed value, evaluated as a value of a given array type, shall be the value of that type for which the value of the Nresults of the evaluation of the repeated structure components as sequences of values of the component type of the given array type. 
<P>The order of evaluation of the expressions of an array constructed value shall be implementation-dependent. 
<P><B>Note:</B> The evaluation of the expressions of an array constructed value could produce a transformation of the program state, i.e. have side-effects. 
<P><B>Auxiliaries</B> 
<P>annotations Return the number of structure components in an array definition. 
<P>annotations Return the number of structure components in an array definition after expanding any repetitions. 
<P>annotations Construct an array value from an evaluated array definition. 
<P>annotations Evaluate the structure components of an array definition. 
<P><B>Repeated Structure Components</B> 
<P>Repeated structure components are structure components that can be followed by a repetition factor. 
<P><B>Concrete Syntax</B> 
<P><B>repeated structure component</B>=<BR>
<A HREF="isom2005.html#0446" TARGET=body>structure component</A>, [ &quot;BY&quot;, <A HREF="isom2005.html#0446" TARGET=body>repetition factor</A> ] ; 
<P><B>repetition factor</B>= <A HREF="isom2005.html#0450" TARGET=body>constant expression</A> ; 
<P><B>Abstract Syntax</B> 
<P>annotations If the repetition factor is not present in the concrete representation, the translation process (from concrete to abstract syntax) will supply a <I>by</I> component in the abstract representation equal to 1. 
<P><B>Static Semantics</B> 
<P>If a repeated structure component contains a repetition factor, the repetition factor shall be a constant expression of a whole number type and shall not have a value less than 0. 
<P><B>Note:</B> A repetition factor of 0 is allowed for parameterized source code. 
<P><B>Example:</B> Parameterized repetion factors. 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;CONST
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mayChangeToZeroOneDay&nbsp;=&nbsp;6;
&nbsp;&nbsp;&nbsp;&nbsp;TYPE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T&nbsp;=&nbsp;ARRAY&nbsp;[0&nbsp;..&nbsp;mayChangeToZeroOneDay]&nbsp;OF&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;VAR
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v:&nbsp;T;
&nbsp;&nbsp;&nbsp;&nbsp;BEGIN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;:=&nbsp;T{0,&nbsp;1&nbsp;BY&nbsp;mayChangeToZeroOneDay};
</PRE>

<P><B>Dynamic Semantics</B> 
<P>The structure component shall be evaluated to give a value of the given type. The value of a repeated structure component shall be the sequence of N occurrences of that value, where N is the value of the repetition factor, if given, or is the value 1, if a repetition factor is not given. 
<P><B>Structure Components</B> 
<P>Structure components define the values of the components of an array constructed value or the fields of a record constructed value. 
<P><B>Concrete Syntax</B> 
<P><B>structure component</B>= <BR>
<A HREF="isom2005.html#0436" TARGET=body>expression</A> | <A HREF="isom2005.html#0446" TARGET=body>array constructed value</A> | <BR>
<A HREF="isom2005.html#0447" TARGET=body>record constructed value</A> | <A HREF="isom2005.html#0448" TARGET=body>set constructed value</A> ; 
<P><B>Static Semantics</B> 
<P>If a structure component is an expression, the structure component type shall be assignment-compatible with the type of the expression. 
<P>If a structure component is an array, record, or set constructed value, the constructed value shall be well-formed with respect to a given type that is the structure component type. 
<P><B>Dynamic Semantics</B> 
<P>The value of a structure component that is an expression shall be the value of the expression. An exception shall be raised if the value is not within the range of values defined by the structure component type. 
<P>The value of a structure component that is an array constructed value, a record constructed value, or a set constructed value shall be the value of the constructed value evaluated as a value of the structure component type. 
<P><HR>
<A NAME="0170">
<A HREF="#0168" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0169" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0171" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Record Constructors</H4>

<P>A record constructor is an expression that denotes a value of a specified record type. The record type is specified by a record type identifier. The record value is specified by a record constructed value that has a structure component for each field of the record. 
<P><B>Concrete Syntax</B> 
<P><B>record constructor</B>= <A HREF="isom2005.html#0447" TARGET=body>record type identifier</A>, <A HREF="isom2005.html#0447" TARGET=body>record constructed value</A> ; 
<P><B>record type identifier</B>= <A HREF="isom2005.html#0396" TARGET=body>type identifier</A> ; 
<P><B>Example:</B> Record constructors. Given the declarations: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;TYPE&nbsp;NameType&nbsp;=&nbsp;ARRAY&nbsp;[0..24]&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;	&nbsp;DateType&nbsp;=&nbsp;RECORD
&nbsp;		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;year,&nbsp;month,&nbsp;day:&nbsp;CARDINAL
&nbsp;&nbsp;		&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;;
&nbsp;	&nbsp;PersonType&nbsp;=&nbsp;RECORD
&nbsp;	&nbsp;		&nbsp;&nbsp;name:&nbsp;NameType;
&nbsp;		&nbsp;&nbsp;&nbsp;DateOfBirth:&nbsp;DateType
&nbsp;&nbsp;		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;;
&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;&nbsp;day,&nbsp;month,&nbsp;year:&nbsp;CARDINAL;
&nbsp;&nbsp;	&nbsp;date:&nbsp;DateType;&nbsp;person:&nbsp;PersonType;
</PRE>

<P>the following statements are possible: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;SWholeIO.ReadCard(year);
&nbsp;&nbsp;&nbsp;&nbsp;SWholeIO.ReadCard(month);
&nbsp;&nbsp;&nbsp;&nbsp;SWholeIO.ReadCard(day);
&nbsp;&nbsp;&nbsp;&nbsp;date:=&nbsp;DateType{year,&nbsp;month,&nbsp;day};
&nbsp;&nbsp;&nbsp;&nbsp;date:=&nbsp;DateType{1623,&nbsp;6,&nbsp;19};
&nbsp;&nbsp;&nbsp;&nbsp;person:=&nbsp;PersonType{&quot;Blaise&nbsp;Pascal&quot;,&nbsp;date};
&nbsp;&nbsp;&nbsp;&nbsp;person:=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PersonType{&quot;Blaise&nbsp;Pascal&quot;,&nbsp;DateType{1623,&nbsp;6,&nbsp;19}};
&nbsp;&nbsp;&nbsp;&nbsp;nobody:=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PersonType{NameType{&quot;&quot;&nbsp;BY&nbsp;25},&nbsp;DateType{0,&nbsp;0,&nbsp;0}};
&nbsp;&nbsp;&nbsp;&nbsp;nobody:=&nbsp;PersonType{{&quot;&quot;&nbsp;BY&nbsp;25},&nbsp;{0,&nbsp;0,&nbsp;0}};
</PRE>

<P><B>Static Semantics</B> 
<P>The record type identifier of a record constructor shall be a type identifier that denotes a record type. The type of the record constructor shall be that record type. 
<P>The record constructed value of a record constructor shall be well-formed with respect to a given record type that is the type of the record constructor. 
<P><B>Dynamic Semantics</B> 
<P>The value of a record constructor shall be the value of the record constructed value evaluated as a value of the type of the record constructor. 
<P>annotations Note that an exception may be detected as each individual component is evaluated. 
<P><B>Record Constructed Values</B> 
<P>A record constructed value denotes a value of a record type by specifying a structure component for each field of the record. It can either form part of a record constructor, or it can be used as a structure component of an array constructor or a record constructor. 
<P>Record constructed values are evaluated as a value of a given type. This type is specified explicitly by the type identifier in the case of record constructors. For structure components, the type is implicitly the component type of an array type or the corresponding field type of a record type. 
<P><B>Concrete Syntax</B> 
<P><B>record constructed value</B>= <BR>
&quot;{&quot;, [ <A HREF="isom2005.html#0446" TARGET=body>structure component</A>, { &quot;,&quot;, <A HREF="isom2005.html#0446" TARGET=body>structure component</A> } ], &quot;}&quot; ; 
<P><B>Static Semantics</B> 
<P>A sequence of fields shall be formed from the fields of the given record type taken, one at a time, in the order that the fields textually appear in the declaration of the type denoted by the given record type. If the Nsequence of fields is a tag field, then the Nconstructed value shall be an expression that is a constant expression. If there is no else variant part associated with the tag field, then the value of the constant expression shall be such that there is a variant associated with the value of the constant expression. The fields of any variant that is not associated with the value of the constant expression shall be excluded from the sequence of fields. If no variant is associated with the value of the constant expression, then the fields of the else variant part shall be included in the sequence of fields. 
<P><B>Note:</B> A constant expression must be supplied for a tag field even if the tag field is an implicit tag field. 
<P>The length of the sequence of structure components of the record constructed value shall be equal to the length of the sequence of fields. 
<P>The Ncomponent type that is the type of the N
<P>annotations Check that the number of structure components of a record definition is the same as the number of fields of the record type, taking into account tag field variant selection. 
<P><B>Dynamic Semantics</B> 
<P>The value of a record constructed value, evaluated as a value of a given record type, shall be the value of that type for which the value of the Ncomponents as values of the corresponding field type of the given record type. 
<P>The order of evaluation of the expressions of a record constructed value shall be implementation-dependent. 
<P><B>Note:</B> The evaluation of the expressions of a record constructed value could produce a transformation of the program state, i.e. have side-effects. 
<P><B>Auxiliaries</B> 
<P>annotations Calculate the number of components in a fields-list. 
<P>annotations Calculate the number of components in a fields. 
<P>annotations Calculate the number of components in a fixed-fields. 
<P>annotations Calculate the number of components in a variant component of a record structure, selected by the value of the tag field. 
<P>annotations Calculate the number of components in a variant component of a record structure. 
<P>annotations Check that the structure defined by a fields-list matches the structure given by an expression sequence component of a structured record value. 
<P>annotations Check that the structure defined by a fields matches the structure given by an expression sequence component of a structured record value. 
<P>annotations Check that the type of each expression in the record constructor is assignment-compatible with the type of the corresponding component of a record type. 
<P>annotations Check that the type of each expression in the record constructor is assignment-compatible with the type of the corresponding component of the record type; also check that the expression that corresponds to any tag field is a constant expression. The result is undefined if the structured value does not match the type. 
<P>annotations Check the expressions in the record constructor that correspond to a variant component. 
<P>annotations Build a record value corresponding to a fields-list component of a record from an expression sequence. 
<P>annotations Build a record value corresponding to a fixed-fields component of a record from an expression sequence. construct-variant-fields-value : Variant-fields-structure ? Elements ! Environment 
<P>annotations Build a record value corresponding to a variant-fields component of a record from an expression sequence. 
<P>annotations Build a record value corresponding to a variant component of a record from an expression sequence. 
<P><HR>
<A NAME="0171">
<A HREF="#0168" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0170" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0172" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Set Constructors</H4>

<P>A set constructor is an expression that denotes a value of a specified set type or packedset type. The type is specified by a set type or packedset type identifier. The set or packedset value is specified by a set constructed value that specifies each of the elements of the set. An individual element can be specified by using an expression, and several elements can be specified by using an interval. 
<P><B>Concrete Syntax</B> 
<P><B>set constructor</B>= <A HREF="isom2005.html#0448" TARGET=body>set type identifier</A>, <A HREF="isom2005.html#0448" TARGET=body>set constructed value</A> ; 
<P><B>set type identifier</B>= <A HREF="isom2005.html#0396" TARGET=body>type identifier</A> ; 
<P><B>Change:</B> In <I>Programming in Modula-2</I> the set type identifier of a set constructor may be omitted, in which case it implicitly denotes the standard type <TT>BITSET</TT>. 
<P><B>Example:</B> Set constructors. Given the declarations: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;TYPE&nbsp;YearType&nbsp;=&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;	&nbsp;PeriodType&nbsp;=&nbsp;SET&nbsp;OF&nbsp;YearType;
&nbsp;&nbsp;&nbsp;	&nbsp;EntryType&nbsp;=&nbsp;RECORD
&nbsp;&nbsp;&nbsp;			name:&nbsp;NameType;
&nbsp;&nbsp;&nbsp;			lifetime:&nbsp;PeriodType
&nbsp;&nbsp;		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;;
&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;year:&nbsp;CARDINAL;
&nbsp;&nbsp;	period:&nbsp;PeriodType;&nbsp;entry:&nbsp;EntryType;
</PRE>

<P>the following statements are possible: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;period:=&nbsp;PeriodType{1982,&nbsp;1983,&nbsp;1985,&nbsp;1988};
&nbsp;&nbsp;&nbsp;&nbsp;SWholeIO.ReadCard(year);
&nbsp;&nbsp;&nbsp;&nbsp;period:=&nbsp;PeriodType{year-4..year+4};
&nbsp;&nbsp;&nbsp;&nbsp;period:=&nbsp;PeriodType{1623..1662};
&nbsp;&nbsp;&nbsp;&nbsp;entry:=&nbsp;EntryType{&quot;Blaise&nbsp;Pascal&quot;,&nbsp;period};
&nbsp;&nbsp;&nbsp;&nbsp;entry:=&nbsp;EntryType{&quot;Blaise&nbsp;Pascal&quot;,
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PeriodType{1623..1662}};
&nbsp;&nbsp;&nbsp;&nbsp;entry:=&nbsp;EntryType{&quot;Blaise&nbsp;Pascal&quot;,&nbsp;{1623..1662}};
</PRE>

<P><B>Static Semantics</B> 
<P>The set type identifier of a set constructor shall be a type identifier that denotes a set type or a packedset type. The type of the set constructor shall be that set type or packedset type. 
<P>The set constructed value of a set constructor shall be well-formed with respect to a given set type that is the type of the set constructor. 
<P><B>Dynamic Semantics</B> 
<P>The value of a set constructor shall be the value of its set constructed value evaluated as a value of the type of the set constructor. 
<P><B>Set Constructed Values</B> 
<P>A set constructed value denotes a value of a set type, by specifying each of the elements of the set. It can either form part of a set constructor, or it can be used as a structure component of an array constructor or a record constructor. An individual element of the set can be specified by using an expression, and several elements can be specified by using an interval. 
<P>Set constructed values are evaluated as a value of a given type. This type is specified explicitly by the type identifier in the case of set constructors. For structure components, the type is implicitly the component type of an array type or the corresponding field type of a record type. 
<P><B>Notes:</B> 
<OL>
 
<LI>The construct &rsquo;<TT>{}</TT>&rsquo; denotes the empty set of the given set type. An empty set is a value of every set type. </LI>
<LI>Since the base type of a set type contains at least one value, there are at least two values of a set type. </LI>
</OL>

<P><B>Concrete Syntax</B> 
<P><B>set constructed value</B>= &quot;{&quot;, [ <A HREF="isom2005.html#0448" TARGET=body>member</A>, { &quot;,&quot;, <A HREF="isom2005.html#0448" TARGET=body>member</A> } ], &quot;}&quot; ; 
<P><B>Static Semantics</B> 
<P>For each element of the set constructed value, the base type of the given set type shall be assignment-compatible with the type of the element. 
<P><B>Clarification:</B> In <I>Programming in Modula-2</I> it is not stated that, for each element of the set constructed value, the base type of the given set type has to be assignment-compatible with the type of the element. 
<P>annotations In the VDM-SL modelling of a Modula-2 set, the <I>Set-constructed-value</I> is given a type according to the types of the elements of the set. The given type is tested for assignment-compatibility with the type of the <I>Set-constructed-value</I>. 
<P><B>Dynamic Semantics</B> 
<P>Each member of a set constructed value shall be evaluated to give a value. The value of the set constructed value shall be the union of these values. 
<P>An exception shall be raised if at least one element of this value is not within the range of values defined by the base type of the given set type. 
<P>The order of evaluation of the expressions of a set constructed value shall be implementation-dependent. 
<P><B>Note:</B> The evaluation of the expressions of a set constructor could produce a transformation of the program state, i.e. have side-effects. 
<P><B>Members</B> 
<P>A member denotes a set value that either contains values from a range of values or contains a single value. 
<P><B>Concrete Syntax</B> 
<P><B>member</B>= <A HREF="isom2005.html#0448" TARGET=body>interval</A> | <A HREF="isom2005.html#0448" TARGET=body>singleton</A> ; 
<P><B>Static Semantics</B> 
<P>If a member is an interval, then the type of the member shall be the type of the interval; otherwise it shall be the type of the singleton. 
<P><B>Dynamic Semantics</B> 
<P>If a member is an interval, then the value of the member shall be the value of the interval; otherwise it shall be the value of the singleton. 
<P><B>Intervals</B> 
<P>An interval denotes a set value whose elements are defined by a range of values. 
<P><B>Concrete Syntax</B> 
<P><B>interval</B>= <A HREF="isom2005.html#0437" TARGET=body>ordinal expression</A>, &quot;..&quot;, <A HREF="isom2005.html#0437" TARGET=body>ordinal expression</A> ; 
<P><B>Static Semantics</B> 
<P>Each ordinal expression of an interval shall be an expression that is of an ordinal type. The types of the ordinal expressions shall be expression-compatible. 
<P>The base type of the interval shall be the type of each ordinal expression, if they are of the same type. If the type of one ordinal expression is the Z-type, and the type of the other ordinal expression is the signed type, the base type of the interval shall be the signed type. If the type of one ordinal expression is the Z-type, and the type of the other ordinal expression is the unsigned type, the base type of the interval shall be the unsigned type. 
<P><B>Dynamic Semantics</B> 
<P>The value of an interval of the form &lsquo;<TT>x..y</TT>&rsquo;, where x and y are ordinal expressions, shall be an empty set if the value of <TT>x</TT> is greater than the value of <TT>y</TT>; otherwise it shall be a set whose elements have the values in the closed interval from the value of <TT>x</TT> to the value of <TT>y</TT>. 
<P>annotations The above evaluation order for the minimum expression and the maximum expression is one of those permitted; the maximum expression may instead be evaluated before the minimum expression, or both may be evaluated in parallel &mdash; see ???.
<P><B>Singletons</B> 
<P>A singleton denotes a set value with one element, defined by a expression. 
<P><B>Concrete Syntax</B> 
<P><B>singleton</B>= <A HREF="isom2005.html#0437" TARGET=body>ordinal expression</A> ; 
<P><B>Static Semantics</B> 
<P>The ordinal expression of a singleton shall be an expression that is of an ordinal type. 
<P>The base type of a singleton shall be the type of the ordinal expression. 
<P><B>Dynamic Semantics</B> 
<P>The value of a singleton shall be a set of one element that has the value of the ordinal expression. 
<P><HR>
<A NAME="0172">
<A HREF="#0142" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0171" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0173" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Constant Literals</H3>

<P>A constant literal denotes a constant value. 
<P><B>Concrete Syntax</B> 
<P><B>constant literal</B>= whole number literal | real literal | string literal ; 
<P><B>Note:</B> There is no denotation for a complex literal. However, a value of the C -type can be formed by applying the standard function <TT>CMPLX</TT> to two real literals; for example &lsquo;<TT>CMPLX(0.0,&nbsp;1.0)</TT>&rsquo; &mdash; see <A HREF="#0222" TARGET=body>The Function CMPLX</A>. 
<P><UL>
<LI><A HREF="#0173" TARGET=body>Whole Number Literals</A>
<LI><A HREF="#0174" TARGET=body>Real Literals</A>
<LI><A HREF="#0175" TARGET=body>String Literals</A>
</UL>
<P><HR>
<A NAME="0173">
<A HREF="#0172" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0172" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0174" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Whole Number Literals</H4>

<P>A whole number literal denotes a constant value of a whole number type. It can be denoted by means of decimal, octal, or hexadecimal notation. 
<P><B>Concrete Syntax</B> 
<P><B>Note:</B> The syntax for whole number literals is given in the Lexis &mdash; see Chapter ???.
<P>The radix of a decimal number shall be ten; the radix of an octal number shall be eight; and the radix of a hexadecimal number shall be sixteen. 
<P>No separators shall appear within a whole number literal. 
<P><B>Notes:</B> 
<OL>
 
<LI>The additional requirement of no separators must be made since this is not a consequence of the concrete syntax. </LI>
<LI>A whole number literal has a non-negative value. The syntax does not permit a whole number literal that has a negative value. A whole number literal preceded by an arithmetic negation operator is a prefix expression &mdash; see <A HREF="#0159" TARGET=body> Prefix Expressions</A>. Such an expression has a non-positive value of the Z-type. </LI>
</OL>

<P><B>Static Semantics</B> 
<P>The value denoted by a whole number literal shall be less than or equal to the implementation-defined maximum value for values of the Z-type. 
<P>The type of a whole number literal shall be the Z-type. 
<P><B>Notes:</B> 
<OL>
 
<LI>There is no identifier that denotes the maximum value for values of the Z-type. </LI>
<LI>This maximum value is at least as large as the maximum value of any whole number type. &mdash; see <A HREF="#0203" TARGET=body>Ranges of the Predefined Numeric Types</A>. </LI>
</OL>

<P><B>Dynamic Semantics</B> 
<P>The value of a whole number literal shall be the numerical value denoted by the whole number literal. 
<P><HR>
<A NAME="0174">
<A HREF="#0172" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0173" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0175" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Real Literals</H4>

<P>A real literal denotes a constant value of a real number type. It is denoted by means of a decimal notation, using an optional scale factor. 
<P><B>Concrete Syntax</B> 
<P><B>Note:</B> The syntax for real literals is given in the Lexis &mdash; see Chapter ???.
<P>A real literal shall be written in decimal notation with an optional scale factor. The scale factor shall give the power of ten by which the remaining part of the real literal is multiplied to produce the value of the real literal. 
<P>No separators shall appear within a real literal. 
<P><B>Notes:</B> 
<OL>
 
<LI>The additional requirement of no separators must be made since this is not a consequence of the concrete syntax. </LI>
<LI>A real literal has a non-negative value. The syntax does not permit a real literal that has a negative value. A real literal preceded by an arithmetic negation operator is a prefix expression &mdash; see <A HREF="#0159" TARGET=body> Prefix Expressions</A>. Such an expression has a non-positive value of the R-type. </LI>
<LI>A real literal always contains a decimal point. </LI>
</OL>

<P><B>Static Semantics</B> 
<P>The value denoted by a real literal shall be less than or equal to the implementation-defined maximum value for values of the R-type. 
<P>The type of a real literal shall be the R-type. 
<P><B>Notes:</B> 
<OL>
 
<LI>There is no identifier that denotes the maximum value for values of the R-type. </LI>
<LI>This maximum value is at least as large as the maximum value of any real number type. &mdash; see <A HREF="#0203" TARGET=body>Ranges of the Predefined Numeric Types</A>. </LI>
</OL>

<P><B>Dynamic Semantics</B> 
<P>The value of a real literal shall be an implementation-defined approximation to the numerical value denoted by the real literal. 
<P><HR>
<A NAME="0175">
<A HREF="#0172" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0174" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0176" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>String Literals</H4>

<P>There are two forms of string literal, namely quoted strings and character number literals. A quoted string denotes a constant value of the string literal type which is a sequence of zero or more characters. A character number literal denotes a constant value of the string literal type of length one. String literals of length zero or length one are also known as character literals. 
<P><B>Concrete Syntax</B> 
<P><B>Notes:</B> 
<OL>
 
<LI>The syntax for string literals is given in the Lexis &mdash; see ???.</LI>
<LI>A string literal is not equivalent to a concrete string constant constructed with an array constructor. For example, values of the string literal type cannot be indexed, concrete string constants cannot be concatenated using the catenation symbol, and the compatibility rules for string literals are more relaxed than those for concrete string constants. </LI>
</OL>

<P><A NAME="0176">
<A HREF="#0175" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0175" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0177" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Quoted Strings</H5>

<P>A quoted string denotes a constant value of the string literal type which is a sequence of zero or more characters. 
<P><B>Concrete Syntax</B> 
<P><B>Note:</B> The syntax for quoted strings is given in the Lexis &mdash; see ???.
<P><B>Static Semantics</B> 
<P>The type of a quoted string shall be the string literal type with length given by the number of quoted characters &mdash; see <A HREF="#0204" TARGET=body>The String Literal Type</A>. 
<P><B>Dynamic Semantics</B> 
<P>The value of a quoted string shall be the string literal value denoted by the characters, if any, between the pair of single quotes or double quotes. 
<P><B>Note:</B> A quoted string containing an empty sequence of characters is called the &lsquo;empty string literal&rsquo; and is a denotation both for the empty string and the character that is the string terminator &mdash; see <A HREF="#0178" TARGET=body>Character Literals</A>. 
<P><A NAME="0177">
<A HREF="#0175" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0176" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0178" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Character Number Literals</H5>

<P>A character number literal denotes a constant value of the string literal type of length 1. 
<P><B>Concrete Syntax</B> 
<P><B>Note:</B> The syntax for character number literals is given in the Lexis &mdash; see ???.
<P><B>Static Semantics</B> 
<P>The value of the sequence of octal digits that precede the &lsquo;<TT>C</TT>&rsquo; shall be the ordinal number of a value of the character type. 
<P>The type of a character number literal shall be the string literal type of length one. 
<P><B>Change:</B> In <I>Programming in Modula-2</I> a character number literal is of the character type. 
<P><B>Notes:</B> 
<OL>
 
<LI>The character type is expression-compatible and assignment-compatible with the string literal type of length one. </LI>
<LI>Concrete string types are assignment-compatible with the string literal type of length one. </LI>
</OL>

<P><B>Dynamic Semantics</B> 
<P>The value of a character number literal shall be the string literal value denoted by the character whose ordinal value is given by the value of the sequence of octal digits that precede the &lsquo;<TT>C</TT>&rsquo;. 
<P><B>Note:</B> The ordinal number of a character need not be the same as the internal code used to represent the character &mdash; see <A HREF="#0200" TARGET=body>The Character Type</A>. 
<P><A NAME="0178">
<A HREF="#0175" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0177" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0179" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Character Literals</H5>

<P>In contexts where a value of an ordinal type is required, values of the string literal type of length 0 or length 1 are interpreted as values of the character type. 
<P><HR>
<A NAME="0179">
<A HREF="#0142" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0178" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0180" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Constant Expressions</H3>

<P>A constant expression is an expression whose constituents are constants. It can therefore be evaluated by a mere textual scan of the program without having to execute it. 
<P><B>Concrete Syntax</B> 
<P><B>constant expression</B>= <A HREF="isom2005.html#0436" TARGET=body>expression</A> ; 
<P><B>Abstract Syntax</B> 
<P>annotations The abstract syntax for <I>constant-expression</I> is the same as the abstract syntax for <I>expression</I> . 
<P><B>Static Semantics</B> 
<P>An infix expression is constant if and only if its two operands are both constant expressions. 
<P><B>Note:</B> The constant expression &lsquo;<TT>TRUE&nbsp;OR&nbsp;(1/0=1)</TT>&rsquo; is permitted and has the value <I>true</I> since the right operand is not evaluated. 
<P>A prefix expression is constant if and only if its operand is a constant expression. 
<P>A constant expression shall not contain a function call, unless the actual parameters of the function call are constant expressions, and the function designator of the function call denotes a standard function, or is one of the functions <TT>CAST,&nbsp;MAKEADR,&nbsp;ROTATE,&nbsp;SHIFT</TT> and <TT>TSIZE</TT> from the module <TT>SYSTEM</TT>. 
<P>A constant expression shall not contain a reference to a variable, unless that variable is contained in an actual parameter to the standard function <TT>SIZE</TT>. 
<P>A constant expression shall not contain a value constructor, unless the expressions of the value constructor are constant expressions. 
<P>The value of a constant expression that is of the Z-type shall be within the range of values defined by the Z-type. 
<P>The value of a constant expression that is of the R-type shall be within the range of values defined by the R-type. 
<P><B>Clarification:</B> A constant expression may contain values of procedure types, or structured values whose components are values of procedure types. 
<P>annotations The function checks whether an expression is a constant expression. Any constant literal is a constant expression. 
<P>annotations Check that both expression components are constant expressions. 
<P>annotations Check that the expression component is a constant expression. 
<P>annotations Check that the qualified identifier denotes a constant or a proper procedure or a function procedure. 
<P>annotations Check that the designator denotes a constant and that the index expression is a constant expression. 
<P>annotations Check that the designator denotes a constant. 
<P>annotations A dereferenced value cannot be a constant expression. 
<P>annotations Check that the function call is to a standard function or a system function that is defined to be a constant function. 
<P>annotations Check that the array definition is a constant expression. Check that each of the repeated element components of an array definition is a constant expression. Check that element and repetition factor are constant expressions. 
<P>annotations Check that a record constructor is a constant expression by checking that the record definition component is a constant expression. A record definition is a constant expression if each of the elements is a constant expression. 
<P>annotations Check that the set definition is a constant expression by checking that each of the members of the set is a constant expression. A singleton member is constant if it is a constant expression, and an interval is constant if each of its component expressions are constant expressions. 
<P><UL>
<LI><A HREF="#0180" TARGET=body>Constant Expression Evaluation</A>
</UL>
<P><HR>
<A NAME="0180">
<A HREF="#0179" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0179" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0181" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Constant Expression Evaluation</H4>

<P>annotations As a constant expression can be evaluated with just a textual scan, the evaluation of a constant expression is defined to be the meaning of an expression with an empty state. 
<P>
<P><HR>
<A NAME="0181">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0180" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0182" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Parameter Compatibility and Argument Binding</H2>

<P>If a proper procedure or function procedure is of a structure that has formal parameters, a call of that procedure has a corresponding actual parameter list. The actual parameters and the formal parameters must match. The execution of a proper procedure call or function procedure call involves the evaluation of any actual parameters to give corresponding arguments, the binding of the results of this evaluation to the corresponding formal parameters, and the execution of the actions associated with the procedure designator. 
<P>In the case of a declared procedure, the correspondence between actual parameters and formal parameters is established by the positions of the parameters in the lists of actual and formal parameters respectively; the actions are as specified by the block of the procedure declaration. 
<P>In the case of a call of a predefined procedure, parameter correspondence, argument binding, and procedure actions are as specified for that predefined procedure. 
<P><UL>
<LI><A HREF="#0182" TARGET=body>Actual Parameters</A>
<LI><A HREF="#0186" TARGET=body>Parameter Matching</A>
<LI><A HREF="#0187" TARGET=body>Parameter Compatibility</A>
<LI><A HREF="#0191" TARGET=body>Argument Binding</A>
</UL>
<P><HR>
<A NAME="0182">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0181" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0183" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Actual Parameters</H3>

<P>Actual parameters of declared procedures are either variable designators (if the corresponding formal parameter is a variable parameter), or expressions (if the corresponding formal parameter is a value parameter). In the case of calls of predefined procedures, there are special cases of actual parameters that are type identifiers. 
<P><B>Concrete Syntax</B> 
<P><B>actual parameters</B>= &quot;(&quot;, [ <A HREF="isom2005.html#0452" TARGET=body>actual parameter list</A> ], &quot;)&quot; ; 
<P><B>actual parameter list</B>= <A HREF="isom2005.html#0452" TARGET=body>actual parameter</A>, { &quot;,&quot;, <A HREF="isom2005.html#0452" TARGET=body>actual parameter</A> } ; 
<P><B>actual parameter</B>= <A HREF="isom2005.html#0431" TARGET=body>variable designator</A> | <A HREF="isom2005.html#0436" TARGET=body>expression</A> | <A HREF="isom2005.html#0453" TARGET=body>type parameter</A> ; 
<P><B>Static Semantics</B> 
<P>An actual parameter shall be a variable designator, an expression, or a type parameter. 
<P>annotations Check that each of the actual parameters is well-formed. 
<P><B>Dynamic Semantics</B> 
<P>Each of the actual parameters shall be evaluated. The order of evaluation, the order of accessing and the order of binding of the actual parameters shall be implementation-dependent. 
<P>annotations The above evaluation order for the the actual parameters is one of those permitted | see 4.1. 
<P><UL>
<LI><A HREF="#0183" TARGET=body>Variable Actual Parameters</A>
<LI><A HREF="#0184" TARGET=body>Expression Actual Parameters</A>
<LI><A HREF="#0185" TARGET=body>Type Parameters</A>
</UL>
<P><HR>
<A NAME="0183">
<A HREF="#0182" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0182" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0184" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Variable Actual Parameters</H4>

<P>Actual parameters are variable designators if the corresponding formal parameter is a variable parameter. 
<P><B>Abstract Syntax</B> 
<P>annotations Type information is supplied with argument variables for the effect of binding with system storage formal parameters to be specified and for calls of the predefined procedures <TT>DEC,&nbsp;DISPOSE,&nbsp;EXCL,&nbsp;INC,&nbsp;INCL,&nbsp;NEW,&nbsp;SIZE</TT>, and <TT>SYSTEM.ADR</TT>. 
<P><HR>
<A NAME="0184">
<A HREF="#0182" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0183" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0185" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Expression Actual Parameters</H4>

<P>Actual parameters are expressions if the corresponding formal parameter is a value parameter. 
<P><B>Abstract Syntax</B> 
<P>annotations Type information is supplied with argument values for the effect of binding with system storage formal parameters to be specified and for calls of the predefined procedures <TT>ABS,&nbsp;CMPLX,&nbsp;IM,&nbsp;RE,&nbsp;SYSTEM.ROTATE</TT> and <TT>SYSTEM.SHIFT</TT>. 
<P><HR>
<A NAME="0185">
<A HREF="#0182" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0184" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0186" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Type Parameters</H4>

<P>Some predefined function procedures (<TT>MAX,&nbsp;MIN,&nbsp;SIZE</TT> and <TT>VAL</TT>) and the function procedures <TT>SYSTEM.CAST</TT> and <TT>SYSTEM.TSIZE</TT> take a type identifier as an actual parameter. 
<P><B>Concrete Syntax</B> 
<P><B>type parameter</B>= <A HREF="isom2005.html#0396" TARGET=body>type identifier</A> ; 
<P><HR>
<A NAME="0186">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0185" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0187" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Parameter Matching</H3>

<P>Calls of a declared procedure must supply actual parameters that match the formal parameters given in the procedure heading of that declared procedure. 
<P>The requirements for parameter matching for a call of a predefined proper procedure, a predefined function procedure, or a proper procedure or a function procedure exported from a system module are given separately for each proper procedure and function procedure in <A HREF="#0209" TARGET=body>Standard Procedures</A>, <A HREF="#0217" TARGET=body>Standard Functions</A> and in Chapter <A HREF="isom2004.html#0305" TARGET=body>System Modules</A>. 
<P><B>Static Semantics</B> 
<P>The formal parameters of a proper procedure or a function procedure shall match the actual parameters specified in any call of that proper procedure or function procedure. The formal parameters match the actual parameters if and only if the number of formal parameters is equal to the number of actual parameters, and each formal parameter is parameter-compatible with the corresponding actual parameter &mdash; see <A HREF="#0187" TARGET=body>Parameter Compatibility</A>. This correspondence shall be established by the positions of the parameters in the lists of formal and actual parameters respectively. 
<P>annotations Check that the number of formal parameters is equal to the number of actual parameters, and that each of the formal parameters is parameter-compatible with the actual parameter. 
<P><HR>
<A NAME="0187">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0186" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0188" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Parameter Compatibility</H3>

<P>There are two cases of parameter-compatibility, depending on whether the formal parameter is a value parameter or a variable parameter. There are special rules common to both cases if the formal type is a system storage formal type &mdash; see <A HREF="#0190" TARGET=body>System Storage Parameter Compatibility</A>. 
<P><B>Static Semantics</B> 
<P>A formal parameter shall be parameter-compatible with an actual parameter if either of the following statements is true: 
<P>a) The formal parameter is a value parameter, the actual parameter is an expression, and the formal type of the formal parameter is value parameter compatible with the type of the expression. 
<P>b) The formal parameter is a variable parameter, the actual parameter is a variable designator, and the formal type of the formal parameter is variable parameter compatible with the type of the expression. 
<P><UL>
<LI><A HREF="#0188" TARGET=body>Value Parameter Compatibility</A>
<LI><A HREF="#0189" TARGET=body>Variable Parameter Compatibility</A>
<LI><A HREF="#0190" TARGET=body>System Storage Parameter Compatibility</A>
</UL>
<P><HR>
<A NAME="0188">
<A HREF="#0187" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0187" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0189" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Value Parameter Compatibility</H4>

<P><B>Static Semantics</B> 
<P>The formal type of a value parameter shall be compatible with the type of an actual expression if any of the following statements is true: 
<P>a) The formal type is a system storage formal type, or a one-dimensional open array of a system storage formal type, and is compatible with the actual type as the type of a system storage formal parameter &mdash; see <A HREF="#0190" TARGET=body>System Storage Parameter Compatibility</A>. 
<P>b) The formal type is an open array, the actual type is the string literal type of any length, and the component type of the formal type is the character type. 
<P>c) The formal type is an open array (other than a one-dimensional open array of a system storage formal type), the actual type is an array type, and the component type of the formal type is compatible with the component type of the actual type as an open array component type. 
<P>d) The formal type is a single identified type that is assignment-compatible with the actual type. 
<P>The component type of an open array value parameter shall be compatible with the component type of an actual array if the component types are system storage parameter compatible, are of the identical identified type, or themselves have component types that are compatible in one or other of these ways. 
<P><B>Example:</B> Value parameter compatibility. Given the declaration 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;TYPE&nbsp;Colour&nbsp;=&nbsp;(red,&nbsp;yellow,&nbsp;green);
</PRE>

<P>The following formal types are compatible, as the types of value parameters, with the given actual types. Formal types denoted by		 	 Actual types denoted by 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;CARDINAL&nbsp;					&nbsp;INTEGER&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;ARRAY&nbsp;OF&nbsp;ARRAY&nbsp;OF&nbsp;ARRAY&nbsp;OF&nbsp;CARDINAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ARRAY&nbsp;[-7..-2]&nbsp;OF&nbsp;ARRAY&nbsp;BOOLEAN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OF&nbsp;ARRAY&nbsp;Colour&nbsp;OF&nbsp;CARDINAL
&nbsp;&nbsp;&nbsp;&nbsp;ARRAY&nbsp;OF&nbsp;ARRAY&nbsp;OF&nbsp;SYSTEM.LOC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ARRAY&nbsp;Colour&nbsp;OF&nbsp;REAL
&nbsp;&nbsp;&nbsp;&nbsp;ADDRESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POINTER&nbsp;TO&nbsp;LONGREAL
</PRE>

<P><B>Clarification:</B> A formal open array parameter with the component type T is not parameter-compatible with an actual parameter of the type T; e.g. a formal parameter of the open array structure <TT>ARRAY&nbsp;OF&nbsp;CHAR</TT> is not compatible with an actual parameter of the character type. Note, however, that a string literal such as &quot;<TT>!</TT>&quot; is of the string literal type of length 1, with which the character type is assignment-compatible, and can therefore be passed as a parameter in this case. 
<P><HR>
<A NAME="0189">
<A HREF="#0187" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0188" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0190" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Variable Parameter Compatibility</H4>

<P><B>Static Semantics</B> 
<P>The formal type of a variable parameter shall be compatible with the type of an actual variable if any of the following statements is true: 
<P>a) The formal type is the address type and the actual type is any pointer type. 
<P>b) The formal type is a system storage formal type, or a one-dimensional open array of a system storage formal type, and is compatible with the actual type as the type of a system storage formal parameter &mdash; see <A HREF="#0190" TARGET=body>System Storage Parameter Compatibility</A>. 
<P>c) The formal type is an open array (other than a one-dimensional open array of a system storage formal type), the actual type is an array type, and the component type of the formal type is compatible, as the formal type of a variable parameter, with the component type of the actual type. 
<P>d) The formal type is a single identified type that is identical to the actual type. 
<P><B>Example:</B> Variable parameter compatibility. Given the declaration 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;TYPE&nbsp;Colour&nbsp;=&nbsp;(red,&nbsp;yellow,&nbsp;green);
</PRE>

<P>The following formal types are compatible, as the types of variable parameters, with the given actual types. Formal types denoted by 			Actual types denoted by 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CARDINAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CARDINAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ARRAY&nbsp;[-7..-2]&nbsp;OF&nbsp;ARRAY&nbsp;BOOLEAN
&nbsp;&nbsp;&nbsp;&nbsp;ARRAY&nbsp;OF&nbsp;ARRAY&nbsp;OF&nbsp;ARRAY&nbsp;OF&nbsp;CARDINAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OF&nbsp;ARRAY&nbsp;Colour&nbsp;OF&nbsp;CARDINAL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ARRAY&nbsp;Colour&nbsp;OF&nbsp;REAL
&nbsp;&nbsp;&nbsp;&nbsp;ARRAY&nbsp;OF&nbsp;ARRAY&nbsp;OF&nbsp;SYSTEM.LOC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POINTER&nbsp;TO&nbsp;LONGREAL
&nbsp;&nbsp;&nbsp;&nbsp;ADDRESS
</PRE>

<P><HR>
<A NAME="0190">
<A HREF="#0187" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0189" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0191" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>System Storage Parameter Compatibility</H4>

<P>There are special parameter compatibility rules for formal types that are system storage formal types or open arrays of a system storage formal type. 
<P>A formal type is a system storage formal type if it is a system storage type or a zero-based array of a system storage type. 
<P>The system storage types are the location type <TT>SYSTEM.LOC</TT>, the word type <TT>SYSTEM.WORD</TT>, and the byte type <TT>SYSTEM.BYTE</TT> &mdash; see <A HREF="isom2004.html#0310" TARGET=body>System Storage Types</A>. Not all implementations are required to provide the byte type &mdash; see ???.
<P><B>Static Semantics</B> 
<P>A formal type shall be system storage parameter compatible with the type of an actual parameter, other than a numeric literal, if any of the following statements is true: 
<P>a) The formal type <TT>F</TT> is a system storage formal type, and the actual parameter is of any data type <TT>T</TT> such that <TT>SIZE(T)</TT> is equal to <TT>SIZE(F)</TT>. 
<P>b) The formal type is a one-dimensional open array of a system storage formal type <TT>F</TT>, and the actual parameter is of any data type <TT>T</TT> such that <TT>SIZE(T)</TT> is a multiple of <TT>SIZE(F)</TT>. 
<P><B>Clarification:</B> A system storage formal type is not system storage parameter compatible with numeric literal types since such types do not have a defined storage size. 
<P><B>Change:</B> In <I>Programming in Modula-2</I> , a zero-based array of a system storage type is not treated as a system storage formal type. This case has been added for consistency with the definition of <TT>SYSTEM.WORD</TT> which has the structure <TT>ARRAY&nbsp;[0..SYSTEM.LOCSPERWORD]&nbsp;OF&nbsp;SYSTEM.LOC</TT>. 
<P><B>Note:</B> It follows from the specification of value parameter compatibility and variable parameter compatibility that a formal parameter that is an <I>n</I> dimensional open array of a system-storage formal type, where <I>n</I> &gt; 1, is parameter compatible with an actual parameter that is an <I>n</I> - 1 dimensional array of any component type. The upper bounds of the first <I>n</I> - 1 dimensions of the formal variable is determined by the index types of the first <I>n</I> - 1 dimensions of the actual parameter; the upper bound of the remaining dimension is determined by rule ???. 
<P><B>Auxiliaries</B> 
<P>annotations The formal type is a system storage formal type, or is an open array whose components are a system storage formal type. 
<P>annotations A system storage formal type is either a storage type exported from the module <TT>SYSTEM</TT>, or an array whose index type is a whole number type with a lower bound of zero, and whose component type is a storage type exported from the module <TT>SYSTEM</TT>. 
<P><HR>
<A NAME="0191">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0190" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0192" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Argument Binding</H3>

<P>On a call of a declared procedure, the arguments resulting from the evaluation of the actual parameters are bound to the formal parameters given in the procedure heading of that declared procedure. The form of this binding is different for value formal parameters and for variable formal parameters, and takes account of both open array formal parameters and formal parameters constucted from system storage types. 
<P>The binding of arguments for a call of a predefined proper procedure, a predefined function procedure, or a proper procedure or a function procedure exported from a system module is given explicitly for each proper procedure and function procedure in <A HREF="#0209" TARGET=body>Standard Procedures</A>, <A HREF="#0217" TARGET=body>Standard Functions</A> and in Chapter <A HREF="isom2004.html#0305" TARGET=body>System Modules</A>. 
<P><B>Dynamic Semantics</B> 
<P>The arguments arising from the evaluation of each actual parameter shall be bound to the corresponding formal parameter. This correspondence shall be established by the positions of the parameters in the lists of actual and formal parameters respectively. 
<P>The order of evaluation, the order of accessing and the order of binding of the actual parameters shall be implementation-dependent. 
<P><B>Notes:</B> 
<OL>
 
<LI>The binding of the arguments might involve storage allocation and so might lead to the raising of a workspace overflow exception. </LI>
<LI>The binding of the arguments involves the assignment of the arguments to storage allocated for value parameters and so might lead to the raising of a range exception. </LI>
<LI>Exceptions raised during argument binding will be handled by any exception handler that is currently selected for the caller of the procedure for which the arguments are being bound. </LI>
<LI>Since the evaluation of the actual parameters may have side-effects, and the order of evaluation, the order of accessing and the order of binding of the actual parameters is implementation-dependent, this International Standard gives no meaning to a program that relies upon a definition of which actual parameters have been evaluated if an exception is raised during the binding of the arguments. </LI>
<LI>A workspace overflow exception resulting from the elaboration of the declarations of the called procedure will also be handled by any exception handler that is currently selected for the caller of the procedure &mdash; see <A HREF="#0109" TARGET=body>Block Bodies and Exception Handling</A>. </LI>
</OL>

<P>annotations The argument is bound to the parameter according to whether the formal parameter is a value parameter or a variable parameter. 
<P><UL>
<LI><A HREF="#0192" TARGET=body>Argument Binding to Value Parameters</A>
<LI><A HREF="#0193" TARGET=body>Argument Binding to Variable Parameters</A>
</UL>
<P><HR>
<A NAME="0192">
<A HREF="#0191" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0191" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0193" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Argument Binding to Value Parameters</H4>

<P>If the formal parameter is a value parameter, and the formal type is not a system storage formal type or an open array of a system storage formal type (see <A HREF="isom2004.html#0310" TARGET=body>System Storage Types</A> and <A HREF="#0190" TARGET=body>System Storage Parameter Compatibility</A>), then, on a call of the procedure, the corresponding argument shall be assigned to a formal variable allocated for the call. During the execution of the procedure block, the formal parameter identifier shall designate the formal variable. The structure of the formal variable shall be determined by the formal type of the formal parameter, and by the structure of the actual value given in the corresponding argument of the call. 
<P><B>Note:</B> Since a formal parameter identifier of a value parameter designates a formal variable that is allocated for the call, the formal variable is a local variable of the block that is additional to any local variables declared in the procedure block. 
<P>If a formal type is an open array formal type, then the formal variable shall be an array variable; the index type of the formal variable shall have the structure of a subrange type whose lower bound is 0 and whose upper bound is one less than the number of components of the corresponding actual value. The component type of the formal variable shall be determined recursively by the open array component type of the formal type, and by the structure of components of the corresponding actual value. 
<P><B>Note:</B> The upper bound of the index type may be ascertained using the predefined function procedure HIGH &mdash; see <A HREF="#0224" TARGET=body>The Function HIGH</A>. 
<P>If a formal type is a single identified type, the allocated variable shall be a single variable of that identified type; storage shall be allocated for the variable and the corresponding argument value shall be assigned to the allocated variable. 
<P><B>Example:</B> Binding of an open array value parameter. Given: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;TYPE&nbsp;colour&nbsp;=&nbsp;(red,&nbsp;yellow,&nbsp;green);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;a:&nbsp;ARRAY&nbsp;[-7..-2]&nbsp;OF&nbsp;ARRAY&nbsp;BOOLEAN
&nbsp;&nbsp;&nbsp;			&nbsp;&nbsp;OF&nbsp;ARRAY&nbsp;colour&nbsp;OF&nbsp;CARDINAL;

&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p(f:&nbsp;ARRAY&nbsp;OF&nbsp;ARRAY&nbsp;OF&nbsp;ARRAY&nbsp;OF&nbsp;CARDINAL);
</PRE>

<P>then, during activation by &lsquo;p(a)&rsquo;, within the body of p the structure of f will correspond to the local declaration 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;f:&nbsp;ARRAY&nbsp;[0..5]&nbsp;OF&nbsp;ARRAY&nbsp;[0..1]
&nbsp;&nbsp;&nbsp;			OF&nbsp;ARRAY&nbsp;[0..2]&nbsp;OF&nbsp;CARDINAL;
</PRE>

<P>and the initial value of the variable designated by 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;f[0][0][0]&nbsp;will&nbsp;be&nbsp;the&nbsp;value&nbsp;of&nbsp;a[-7][false][red].
</PRE>

<P><B>System storage formal types</B> 
<P>If the formal parameter is a value parameter, and the formal type is a system storage formal type, or an open array of a system storage formal type, the effect shall be for the value of the argument to be cast to a target type constructed from one or more storage locations, and for the the formal parameter to be bound to the resulting value. The target type shall be determined as follows: 
<P>a) If the formal type is a system storage formal type, the target type shall be that system storage formal type. 
<P>b) If the formal type is an open array of a system storage formal type <TT>F</TT>, and the actual parameter is of a data type <TT>T</TT>, the target type shall be of the structure <TT>ARRAY&nbsp;[0..n-1]&nbsp;OF&nbsp;F</TT> where <TT>n&nbsp;=&nbsp;SIZE(T)/SIZE(F)</TT>. 
<P><B>Note:</B> A formal type is a system storage formal type if it is a system storage type or a zero-based array of a system storage type. 
<P><HR>
<A NAME="0193">
<A HREF="#0191" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0192" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0194" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Argument Binding to Variable Parameters</H4>

<P>If the formal parameter is a variable parameter, and the formal type is not a system storage formal type or an open array of a system storage formal type (see <A HREF="isom2004.html#0310" TARGET=body>System Storage Types</A> and <A HREF="#0190" TARGET=body>System Storage Parameter Compatibility</A>), then, during the execution of the procedure block, the formal parameter identifier shall designate a formal variable that is the actual variable given in the corresponding argument of the call. 
<P><B>Note:</B> Since a formal parameter identifier of a variable parameter designates the actual variable given in the corre- sponding argument of the call, the formal parameter identifier of a variable parameter stands as an alias for the actual variable during execution of the procedure body; however, the scope of the declared identifier for the actual variable does not necessarily include that procedure body. 
<P>If a formal type is an open array formal type, the index type of the formal variable shall have the structure of a subrange type whose lower bound is 0 and whose upper bound is one less than the number of components of the corresponding actual variable. The component type of the formal variable shall be determined recursively by the open array component type of the formal type, and by the structure of components of the corresponding actual variable. 
<P><B>Note:</B> The upper bound of the index type may be ascertained using the predefined function procedure HIGH &mdash; see <A HREF="#0224" TARGET=body>The Function HIGH</A>. 
<P><B>Example:</B> Binding of an open array variable parameter. Given: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;TYPE&nbsp;colour&nbsp;=&nbsp;(red,&nbsp;yellow,&nbsp;green);

&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;a:&nbsp;ARRAY&nbsp;[-7..-2]&nbsp;OF&nbsp;ARRAY&nbsp;BOOLEAN
&nbsp;&nbsp;			&nbsp;&nbsp;OF&nbsp;ARRAY&nbsp;colour&nbsp;OF&nbsp;INTEGER;

&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p(VAR&nbsp;f:&nbsp;ARRAY&nbsp;OF&nbsp;ARRAY&nbsp;OF&nbsp;ARRAY&nbsp;OF&nbsp;INTEGER);
</PRE>

<P>then, during activation by &lsquo;<TT>p(a)</TT>&rsquo;, within the body of <TT>p</TT> the identifier <TT>f</TT> will be an alias for <TT>a</TT>, the structure of <TT>f</TT> will correspond to the declaration 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;f:&nbsp;ARRAY&nbsp;[0..5]&nbsp;OF&nbsp;ARRAY&nbsp;[0..1]
&nbsp;&nbsp;			OF&nbsp;ARRAY&nbsp;[0..2]&nbsp;OF&nbsp;INTEGER;
</PRE>

<P>and the variable designated by <TT>f[0][0][0]</TT> will be vari- able designated by a <TT>[-7][false][red]</TT>. 
<P><B>System storage formal types</B> 
<P>If the formal parameter is a variable parameter, and the formal type is a system storage formal type <TT>F</TT>, the effect shall be for the storage for the actual variable to appear as uninterpreted storage locations when accessed through the formal variable which will have the same structure as the structure of <TT>F</TT>. 
<P>If the formal parameter is a variable parameter, and the formal type is an open array of a system storage formal type <TT>F</TT>, the effect shall be for the storage for the actual variable of type <TT>T</TT> to appear as an array of uninterpreted storage locations when accessed through the formal variable which will have the structure <TT>ARRAY&nbsp;[0..n-1]&nbsp;OF&nbsp;F</TT> where <TT>n&nbsp;=&nbsp;SIZE(T)/SIZE(F)</TT>. 
<P>annotations If the formal parameter is a system storage parameter, the actual variable is aliased to storage that consists of one or more storage locations and gives an alternative representation to the value(s) found in the actual variable; the identifier of the formal parameter is bound to this variable. If the formal parameter is not a sytem storage parameter, the identifier of the formal parameter is bound to the actual variable. 
<P><B>Auxiliaries</B> 
<P>annotations Allocate storage for the structure of the formal variable and initialize it to the value of the actual variable. 
<P>
<P><HR>
<A NAME="0194">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0193" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0195" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Predefined Types, Standard Procedures and Standard Functions</H2>

<P>The language provides some predefined entities; these include predefined constants, elementary types, proper proce- dures and function procedures. Besides the entities described in this clause, there are other predefined entities that are denoted by identifiers exported from system modules &mdash; see Chapter <A HREF="isom2004.html#0305" TARGET=body>System Modules</A>. 
<P><UL>
<LI><A HREF="#0195" TARGET=body>Predefined Types</A>
<LI><A HREF="#0209" TARGET=body>Standard Procedures</A>
<LI><A HREF="#0217" TARGET=body>Standard Functions</A>
</UL>
<P><HR>
<A NAME="0195">
<A HREF="#0194" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0194" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0196" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Predefined Types</H3>

<P>There are 16 required types other than those with identifiers exported from system modules: three whole number types, three real number types, three complex number types, the Boolean type, the character type, the string literal type, the nil type, the bitset type, the proc type, and the protection type. 
<P>The predefined types are all elementary types. The bitset type is a predefined packedset type and the proc type is a predefined procedure type, whereas the number, Boolean, character, string literal, and nil types constitute the basic types of the language. 
<P>The protection type is an implementation-defined type and may either be a basic type or a predefined constructed type, as appropriate to the underlying interrupt structure of the implementation. 
<P>The number types include types for numeric literals. The string literal type includes the character literal type as a special case. No corresponding type identifiers are provided for the literal types or for the nil type and so it is not possible to declare variables of these anonymous types; they can only appear as the value of an expression. 
<P>Of the basic types, the whole number types, the Boolean type, and the character type are ordinal types. These basic ordinal types, together with the real number types, constitute the basic scalar types. The character literal type is interpreted as a value of the character type in situations where a value of an ordinal type is expected. 
<P><UL>
<LI><A HREF="#0196" TARGET=body>Predefined Whole Number Types</A>
<LI><A HREF="#0197" TARGET=body>Predfined Real Number Types</A>
<LI><A HREF="#0198" TARGET=body>Predefined Complex Number Types</A>
<LI><A HREF="#0199" TARGET=body>The Boolean Type</A>
<LI><A HREF="#0200" TARGET=body>The Character Type</A>
<LI><A HREF="#0201" TARGET=body>Values of the Basic Types</A>
<LI><A HREF="#0204" TARGET=body>The String Literal Type</A>
<LI><A HREF="#0205" TARGET=body>The Nil Type</A>
<LI><A HREF="#0206" TARGET=body>The Bitset Type</A>
<LI><A HREF="#0207" TARGET=body>The Proc Type</A>
<LI><A HREF="#0208" TARGET=body>The Protection Type</A>
</UL>
<P><HR>
<A NAME="0196">
<A HREF="#0195" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0195" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0197" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Predefined Whole Number Types</H4>

<P>Three predefined types are whole number types: the unsigned type, the signed type and the Z-type. The unsigned type can be used to represent non-negative whole numbers, and the signed type can be used to represent whole numbers that are possibly less than zero. The Z-type is the type of a whole number literal value, and of any expression all of whose factors are whole number constants. 
<P><B>Declaration Semantics</B> 
<P>The unsigned type shall be a whole number type that is denoted by the pervasive type identifier <TT>CARDINAL</TT>. A value of the unsigned type shall be an element of an implementation-defined finite subset of the non-negative whole numbers &mdash; see <A HREF="#0201" TARGET=body>Values of the Basic Types</A>. 
<P>The ordinal number of a value of the unsigned type shall be the value itself. 
<P><B>Notes:</B> 
<OL>
 
<LI>If x is a value of the unsigned type, then x satisfies the condition: 
<P>x </LI>
<LI>When choosing the range of the unsigned type, an implementor should consider the need to represent results returned by calls of the predefined functions <TT>HIGH</TT> and <TT>SIZE</TT>. </LI>
</OL>

<P>The signed type shall be a whole number type that is denoted by the pervasive type identifier <TT>INTEGER</TT>. A value of the signed type shall be an element of an implementation-defined finite subset of the whole numbers &mdash; see <A HREF="#0201" TARGET=body>Values of the Basic Types</A>. 
<P>The ordinal number of a non-negative value of the signed type shall be the value itself. 
<P><B>Notes:</B> 
<OL>
 
<LI>If x is a value of the signed type, then x satisfies the condition: 
<P>x </LI>
<LI>There are no ordinal numbers associated with values of the signed type that are less than zero. </LI>
</OL>

<P>The Z-type shall be a whole number type that is the type of constant expressions all of whose factors are whole number constants. A value of the Z-type shall be an element of an implementation-defined finite subset of the whole numbers. &mdash; see <A HREF="#0201" TARGET=body>Values of the Basic Types</A>. 
<P><B>Notes:</B> 
<OL>
 
<LI>There is no pervasive type identifier that denotes the Z-type. </LI>
<LI>A whole number literal can be used to denote a value of the Z-type &mdash; see <A HREF="#0173" TARGET=body>Whole Number Literals</A>. </LI>
<LI>If x is a value of the Z-type, then x satisfies the condition: 
<P><I>min-zz-value ??? x ??? max-zz-value</I> </LI>
<LI>All numeric subrange types have a host type that is either the signed type or the unsigned type; it is not possible to construct a numeric type by using values of the Z-type for the lower and upper bounds of a subrange type that are not both within the range of either the signed type or the unsigned type &mdash; see <A HREF="#0074" TARGET=body>Subrange Types</A>. </LI>
</OL>

<P><HR>
<A NAME="0197">
<A HREF="#0195" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0196" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0198" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Predfined Real Number Types</H4>

<P>Three predefined types are real number types: the real type, the long real type and the R-type. Both the real type and the long real type can be used to represent real numbers. These types may differ with respect to the range and the precision with which real numbers are represented. The R-type is the type of a real number literal value, and of any expression all of whose factors are real constants. 
<P><B>Declaration Semantics</B> 
<P>The real type shall be a real number type that is denoted by the pervasive type identifier <TT>REAL</TT>. A value of the real type shall be an element of an implementation-defined finite subset of the real numbers &mdash; see <A HREF="#0201" TARGET=body>Values of the Basic Types</A>. 
<P><B>Note:</B> If x is a value of the real type, then x satisfies the condition: 
<P><TT>MIN(REAL)</TT> 
<P>The long real type shall be a real number type that is denoted by the pervasive type identifier <TT>LONGREAL</TT>. A value of the long real type shall be an element of an implementation-defined finite subset of the real numbers &mdash; see <A HREF="#0201" TARGET=body>Values of the Basic Types</A>. 
<P><B>Note:</B> If x is a value of the long real type, then x satisfies the condition: 
<P><TT>MIN(LONGREAL)</TT> 
<P>The R-type shall be a real number type that is the type of constant expressions all of whose factors are real constants. A value of the R-type shall be an element of an implementation-defined finite subset of the real numbers &mdash; see <A HREF="#0201" TARGET=body>Values of the Basic Types</A>. 
<P><B>Notes:</B> 
<OL>
 
<LI>There is no pervasive type identifier that denotes the R-type. </LI>
<LI>A real literal can be used to denote a value of the R-type &mdash; see <A HREF="#0174" TARGET=body>Real Literals</A>. </LI>
<LI>If <I>x</I> is a value of the R-type, then <I>x</I> satisfies the condition: 
<P><I>min-rr-value</I> </LI>
</OL>

<P>The precision with which real number values are represented shall not decrease from the real type to the long real type, or from the long real type to the R-type. 
<P><HR>
<A NAME="0198">
<A HREF="#0195" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0197" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0199" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Predefined Complex Number Types</H4>

<P>Three predefined types are complex number types: the complex type, the long complex type and the C -type. Both the complex type and the long complex type can be used to represent complex numbers. These types may differ with respect to the range and the precision with which complex numbers are represented. The C -type is the type of a complex number literal value, and of any expression all of whose factors are complex constants. 
<P><B>Change:</B> The complex number types are not described in <I>Programming in Modula-2</I> . 
<P><B>Declaration Semantics</B> 
<P>The complex type shall be a complex number type that is denoted by the pervasive type identifier <TT>COMPLEX</TT>. A value of the complex type shall be an element of an implementation-defined finite subset of the complex numbers &mdash; see <A HREF="#0201" TARGET=body>Values of the Basic Types</A>. 
<P><B>Note:</B> If <I>z</I> is a value of the complex type, then <I>z</I> satisfies the condition: 
<P><TT>MIN(REAL)</TT> 
<P>The long complex type shall be a complex number type that is denoted by the pervasive type identifier <TT>LONGCOMPLEX</TT> . A value of the long complex type shall be an element of an implementation-defined finite subset of the complex numbers &mdash; see <A HREF="#0201" TARGET=body>Values of the Basic Types</A>. 
<P><B>Note:</B> If <I>z</I> is a value of the long complex type, then <I>z</I> satisfies the condition: 
<P><TT>MIN(LONGREAL)</TT> 
<P>The C -type shall be a complex number type that is the type of constant expressions all of whose factors are complex constants. A value of the C -type shall be an element of an implementation-defined finite subset of the complex numbers &mdash; see <A HREF="#0201" TARGET=body>Values of the Basic Types</A>. 
<P><B>Notes:</B> 
<OL>
 
<LI>There is no pervasive type identifier that denotes the C -type. </LI>
<LI>Although there is no denotation for a complex literal, a value of the C -type can be formed by applying the pervasive standard function <TT>CMPLX</TT> to two real literals; for example &lsquo;<TT>CMPLX(0.0,&nbsp;1.0)</TT>&rsquo; &mdash; see <A HREF="#0222" TARGET=body>The Function CMPLX</A>. </LI>
<LI>If <I>z</I> is a value of the C -type, then <I>z</I> satisfies the condition: 
<P><I>min-rr-value</I> </LI>
</OL>

<P>The precision with which complex number values are represented shall not decrease from the complex type to the long complex type, or from the long complex type to the C -type. 
<P><HR>
<A NAME="0199">
<A HREF="#0195" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0198" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0200" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Boolean Type</H4>

<P>The Boolean type can be used to represent truth values. 
<P><B>Declaration Semantics</B> 
<P>The Boolean type shall be an ordinal type that is denoted by the pervasive type identifier <TT>BOOLEAN</TT>. A value of the Boolean type shall be one of the logical truth values <I>false</I> or <I>true</I> . The values <I>false</I> and <I>true</I> shall be denoted by the pervasive constant identifiers <TT>FALSE</TT> and <TT>TRUE</TT> respectively . 
<P>The ordinal numbers of the values <I>false</I> and <I>true</I> shall be the values 0 and 1 respectively. 
<P><HR>
<A NAME="0200">
<A HREF="#0195" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0199" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0201" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Character Type</H4>

<P>The character type can be used to represent single characters. 
<P><B>Declaration Semantics</B> 
<P>The character type shall be an ordinal type that is denoted by the pervasive type identifier <TT>CHAR</TT>. A value of the character type shall be an element of a finite set of characters. This set shall contain unique values representing the minus character, the period character, the plus character, the space character, the string terminator, the lower-case letters, the upper-case letters, and the digits. Any other values of this set of characters shall be implementation-defined. 
<P><B>Change:</B> There is no requirement that the value of the string terminator be the same as the value denoted by the character number literal &lsquo;<TT>0C</TT>&rsquo;, as is specified in <I>Programming in Modula-2</I> . 
<P><B>Notes:</B> 
<OL>
 
<LI>If c is a value of the character type, then c satisfies the condition: 
<P><I>c</I> </LI>
<LI>A value of the character type may represent a character that does not have a graphic representation. </LI>
<LI>The character type is assignment-compatible and expression-compatible with the character literal type, which is the string literal type of length 1 or of length 0 &mdash; see <A HREF="#0178" TARGET=body>Character Literals</A>. </LI>
<LI>The string terminator character can be denoted by either of the character literals &lsquo;<TT>''</TT>&rsquo; or &lsquo;<TT>&quot;&quot;</TT>&rsquo;. Both literals represent the same value of the string literal type. </LI>
</OL>

<P><B>Domains</B> 
<P>annotations The type <I>Char</I> is used to model the character type. 
<P>The ordinal numbers of the character values shall be implementation-defined values of the unsigned type that satisfy the conditions: 
<UL>
 
<LI>the ordinal number of each character in the set of characters shall be different from the ordinal number of any other character in the set; </LI>
<LI>the ordinal number associated with the (<I>i</I> + 1)th lower-case letter shall be greater than that associated with the i th lower-case letter; </LI>
<LI>the ordinal number associated with the (<I>i</I> + 1)th upper-case letter shall be greater than that associated with the i th upper-case letter; </LI>
<LI>the ordinal number associated with the (<I>i</I> + 1)th decimal digit shall be one more than that associated with the <I>i</I>th decimal digit. </LI>
</UL>

<P>annotations The collation map associated with the type <I>Char</I> maps from values of the character type to the ordinal numbers of those values. 
<P><B>Notes:</B> 
<OL>
 
<LI>The ordering relationship between any two character values is the same as that between their ordinal numbers &mdash; see <A HREF="#0153" TARGET=body>Scalar Relational Operations</A>. Thus if <TT>x</TT> and <TT>y</TT> are any two character values, then: 
<P><TT>x</TT> &lt; <TT>y</TT> </LI>
<LI>The ordinal number of a character need not be the same as the internal code used to represent the character. For example, if <TT>ch</TT> is a variable of type <TT>CHAR</TT>, whose current value is <TT>5C</TT>, then, although &lsquo;<TT>VAL(CARDINAL,ch)</TT>&rsquo; has the value 5, this need not be the value of &lsquo;<TT>SYSTEM.CAST(CARDINAL,ch)</TT>&rsquo;. </LI>
</OL>

<P><HR>
<A NAME="0201">
<A HREF="#0195" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0200" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0202" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Values of the Basic Types</H4>

<P><A NAME="0202">
<A HREF="#0201" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0201" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0203" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Ranges of the Basic Types</H5>

<P>annotations Return the largest value of a basic scalar type. 
<P>annotations Return the smallest value of a basic scalar type. 
<P>annotations Return the set of values associated with a basic ordinal type. 
<P><A NAME="0203">
<A HREF="#0201" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0202" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0204" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Ranges of the Predefined Numeric Types</H5>

<P>The implementation-defined values specifying the ranges of the predefined numeric types shall have the following properties. 
<P><HR>
<A NAME="0204">
<A HREF="#0195" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0203" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0205" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The String Literal Type</H4>

<P>The string literal type is the type of string literals, of string literal constants, and of the result of string literal catenation. 
<P>The string literal type has an associated length. If the length associated with the string literal type is zero or one, the type is also known as the character literal type. 
<P><B>Declaration Semantics</B> 
<P>The string literal type shall be an elementary type that is the type of constant expressions all of whose factors are string literals or string literal constants. 
<P>A value of the string literal type shall be a sequence of zero or more characters. The string literal type shall have an associated length equal to the number of characters in a value of that type. 
<P><B>Notes:</B> 
<OL>
 
<LI>The only operation allowed in string literal expressions is catenation &mdash; see <A HREF="#0150" TARGET=body>String Literal Infix Operations</A>. </LI>
<LI>There is no pervasive type identifier that denotes the string literal type. </LI>
<LI>A quoted string can be used to denote a value of the string literal type of length zero or more &mdash; see <A HREF="#0176" TARGET=body>Quoted Strings</A>. </LI>
<LI>A character number literal can be used to denote a value of the string literal type of length one that has a particular ordinal number &mdash; see <A HREF="#0177" TARGET=body>Character Number Literals</A>. </LI>
<LI>A concrete string type of capacity <I>n</I> , which is an array type with <I>n</I> components of the character type, is assignment- compatible with the string literal type of length <I>l</I> provided <I>l</I> </LI>
<LI>An open array of the character type is value parameter compatible with the string literal type &mdash; see <A HREF="#0188" TARGET=body>Value Parameter Compatibility</A>. </LI>
<LI>If the length associated with the string literal type is zero or one, the type is also known as the character literal type. </LI>
<LI>Values of the character literal type are interpreted as values of the character type in contexts where a value of an ordinal type is required &mdash; see <A HREF="#0178" TARGET=body>Character Literals</A>. </LI>
<LI>The character type is expression-compatible and assignment-compatible with the character literal type &mdash; see <A HREF="#0099" TARGET=body>Expression Compatibility</A> and <A HREF="#0100" TARGET=body>Assignment Compatibility</A>. </LI>
<LI>An implementation may choose different representations for the elements of a string literal and the values of the character type. </LI>
</OL>

<P><HR>
<A NAME="0205">
<A HREF="#0195" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0204" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0206" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Nil Type</H4>

<P>The nil type is the type of the nil value. 
<P><B>Declaration Semantics</B> 
<P>The nil type shall be the type of the nil value. 
<P>The nil value shall be denoted by the pervasive constant identifier <TT>NIL</TT>. 
<P><B>Note:</B> All pointer types are assignment-compatible and expression-compatible with the nil type. 
<P><HR>
<A NAME="0206">
<A HREF="#0195" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0205" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0207" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Bitset Type</H4>

<P>The bitset type is a packedset type whose base type is a subrange from zero to one less than the number of bits in a machine word of the underlying computer system. The bitset type may therefore be used to represent small sets in an efficient manner, or to manipulate the bits in a machine word &mdash; see <A HREF="#0076" TARGET=body>Packedset Types</A> and <A HREF="isom2004.html#0322" TARGET=body>Packedset mapping</A>. 
<P><B>Declaration Semantics</B> 
<P>The bitset type shall be a packedset type that is denoted by the pervasive type identifier <TT>BITSET</TT>. The base type of the bitset type shall be a subrange of the unsigned type. The lower bound of this base type shall be the value 0, and the upper bound shall be the value denoted by the constant expression <TT>SYSTEM.BITSPERLOC*SYSTEM.LOCSPERWORD-1</TT>. 
<P><B>Note:</B> Although there is no denotation for a literal of the bitset type, a value of the bitset type can be formed by using a set constructor; for example &lsquo;<TT>BITSET{1,&nbsp;4..6,&nbsp;9}</TT>&rsquo; &mdash; see <A HREF="#0171" TARGET=body>Set Constructors</A>. 
<P><HR>
<A NAME="0207">
<A HREF="#0195" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0206" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0208" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Proc Type</H4>

<P>The proc type is a procedure type that can be used to represent the type of parameterless proper procedures that are declared at level 0. 
<P><B>Declaration Semantics</B> 
<P>The proc type shall be a proper procedure type that is denoted by the pervasive type identifier <TT>PROC</TT>. A value of the proc type shall denote a parameterless proper procedure that has been declared at level 0. 
<P><B>Note:</B> The proc type is effectively defined by the implicit declaration: 
<P><TT>TYPE</TT> <TT>PROC&nbsp;=&nbsp;PROCEDURE;</TT> 
<P><HR>
<A NAME="0208">
<A HREF="#0195" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0207" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0209" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Protection Type</H4>

<P>The protection type can be used to represent an extent of protection from interrupts. 
<P><B>Change:</B> The treatment of protection differs from that described (as &quot;) in <I>Programming in Modula-2</I> , which was modelled on the PDP-11 interrupt structure. 
<P>Declaration Semantics 
<P>The protection type shall be an implementation-defined elementary type that is denoted by the pervasive type identifier <TT>PROTECTION</TT>. A value of the protection type shall be one of an implementation-defined set of values that shall include the values interruptible and uninterruptible; these values shall be denoted by the pervasive constant identifiers <TT>INTERRUPTIBLE</TT> and <TT>UNINTERRUPTIBLE</TT> respectively. 
<P><B>Notes:</B> 
<OL>
 
<LI>An implementation may define the protection type as a basic type, distinct from the other basic types of the language, as identical to another basic type, or as a predefined constructed type, as appropriate to the interrupt structure of the underlying system. </LI>
<LI>It is likely that the interrupt structure of the system underlying an implementation will be richer than the two protection values defined here. An implementation may reflect this richer structure by defining the protection type so that it includes other appropriate values. The underlying interrupt structure might be totally or partially ordered: an ordinal type or a set type would then result for the protection type. The protection relational operators (see <A HREF="#0157" TARGET=body>Protection Relational Operations</A>) are those that are common both to ordinal types and to set types. If the protection type is defined to be identical to a basic ordinal type, or is defined as a constructed ordinal type, other corresponding operations will be applicable to protection values. </LI>
<LI>If <TT>P</TT> is a value of the protection type, then <TT>P</TT> satisfies the condition: 
<P><TT>INTERRUPTIBLE&nbsp;&lt;=&nbsp;P&nbsp;AND&nbsp;P&nbsp;&lt;=&nbsp;UNINTERRUPTIBLE</TT> 
<P>&mdash; see <A HREF="#0157" TARGET=body>Protection Relational Operations</A>. </LI>
<LI>A value P1 of the protection type is less restrictive than another value P2 if and only if P1 does not prevent all the interrupts prevented by P2, but P2 prevents all the interrupts prevented by P1 &mdash; see <A HREF="#0157" TARGET=body>Protection Relational Operations</A>. </LI>
</OL>

<P><HR>
<A NAME="0209">
<A HREF="#0194" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0208" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0210" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Standard Procedures</H3>

<P>The standard procedures are denoted by the pervasive identifiers <TT>DEC,&nbsp;DISPOSE,&nbsp;EXCL,&nbsp;HALT,&nbsp;INC,&nbsp;INCL</TT> and <TT>NEW</TT>. 
<P><UL>
<LI><A HREF="#0210" TARGET=body>The Procedure DEC</A>
<LI><A HREF="#0211" TARGET=body>The Procedure DISPOSE</A>
<LI><A HREF="#0212" TARGET=body>The Procedure EXCL</A>
<LI><A HREF="#0213" TARGET=body>The Procedure HALT</A>
<LI><A HREF="#0214" TARGET=body>The Procedure INC</A>
<LI><A HREF="#0215" TARGET=body>The Procedure INCL</A>
<LI><A HREF="#0216" TARGET=body>The Procedure NEW</A>
</UL>
<P><HR>
<A NAME="0210">
<A HREF="#0209" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0209" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0211" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Procedure DEC</H4>

<P>The procedure <TT>DEC</TT> can be used to decrement the value of a variable that is of an ordinal type. 
<P><B>Static Semantics</B> 
<P>A call of <TT>DEC</TT> shall have one or two actual parameters. The first parameter shall be a variable that is of an ordinal type. If there is a second parameter, it shall be an expression that is of a whole number type. 
<P>If the second parameter is of the Z-type, its value shall be subject to a constraint that depends on the type of the first parameter: if the first parameter is of the signed type (or is of a subrange type whose host type is the signed type), the value of the second parameter shall be less than or equal to the maximum value of the signed type; otherwise it shall be greater than or equal to zero. 
<P><B>Note:</B> These constraints are present because signed arithmetic will be used if the first parameter is of the signed type, and unsigned arithmetic will be used in all other cases. 
<P><B>Clarification:</B> In <I>Programming in Modula-2</I> the types of the parameters of <TT>DEC</TT> are not specified. 
<P><B>Dynamic Semantics</B> 
<P>The call <TT>DEC(x)</TT> shall assign to the variable <TT>x</TT> the predecessor of its current value. An exception shall be raised if the predecessor lies outside the range of the type of <TT>x</TT>, or if there is no predecessor. 
<P>The call <TT>DEC(x,N)</TT> shall assign to the variable <TT>x</TT> the Nif the N
<P><B>Auxiliaries</B> 
<P>annotations Check whether the first parameter of a call of <TT>DEC</TT> or <TT>INC</TT> is valid. 
<P>annotations Check whether the two parameters of a call of <TT>DEC</TT> or <TT>INC</TT> are valid. This includes checking that the second parameter is within range when it is of the Z-type. 
<P><HR>
<A NAME="0211">
<A HREF="#0209" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0210" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0212" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Procedure DISPOSE</H4>

<P>The procedure <TT>DISPOSE</TT> can often be used to release an area of dynamically allocated storage that was earlier claimed by a call to the procedure <TT>NEW</TT>. 
<P><B>Note:</B> The word <I>often</I> appears because there is no requirement that the procedure <TT>DEALLOCATE</TT> that is associated with <TT>DISPOSE</TT> necessarily be the procedure <TT>Storage.DEALLOCATE</TT>, or a procedure that performs a similar task. 
<P><B>Static Semantics</B> 
<P>A call of <TT>DISPOSE</TT> shall have one or more actual parameters. The first parameter shall be a variable that is of a pointer type. 
<P>If the second and subsequent parameters are present, they shall be constant expressions, and the bound type of the first parameter shall be a record type. 
<P>The identifier <TT>DEALLOCATE</TT> shall be visible at the point of the call of <TT>DISPOSE</TT> and shall designate a procedure, procedure constant, or procedure variable with the structure of a proper procedure that has two formal parameters. The first formal parameter of this proper procedure structure shall be a variable parameter that is of the address type, and the second formal parameter shall be a value parameter that is of the unsigned type. 
<P><B>Note:</B> The separate module Storage exports a procedure called <TT>DEALLOCATE</TT> of the correct structure for a call of <TT>DISPOSE</TT>. The requirement that the identifier <TT>DEALLOCATE</TT> is visible at the point of the call of <TT>DISPOSE</TT> is often satisfied by including the import list: 
<P><TT>FROM&nbsp;Storage&nbsp;IMPORT&nbsp;DEALLOCATE;</TT> 
<P>in the module containing the call of <TT>DISPOSE</TT>. 
<P><B>Dynamic Semantics</B> 
<P>The call <TT>DISPOSE(P)</TT> shall have the same effect as the call <TT>DEALLOCATE(P,SIZE(B))</TT>, where the variable <TT>P</TT> is of a pointer type <TT>T</TT>, and <TT>B</TT> is the bound type given in the declaration of <TT>T</TT>. 
<P>The call <TT>DISPOSE(P,</TT> &lt; <I>expression-list</I> &gt;<TT>)</TT> shall have the same effect as the call 
<P><TT>DEALLOCATE(P,SYSTEM.TSIZE(B,</TT> &lt; <I>expression-list</I> &gt;<TT>))</TT>, 
<P>where the variable <TT>P</TT> is of a pointer type <TT>T</TT>, and <TT>B</TT> is the bound type given in the declaration of <TT>T</TT>. 
<P><HR>
<A NAME="0212">
<A HREF="#0209" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0211" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0213" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Procedure EXCL</H4>

<P>The procedure <TT>EXCL</TT> can be used to remove an element from a variable that is of a set type or a packedset type. 
<P><B>Static Semantics</B> 
<P>A call of <TT>EXCL</TT> shall have two actual parameters. The first parameter shall be a variable that is of a set type or a packedset type, and the second parameter shall be an expression with which the the host type of the base type of the set type or packedset type is assignment-compatible. 
<P><B>Dynamic Semantics</B> 
<P>The call <TT>EXCL(s,x)</TT> shall assign to the set variable <TT>s</TT> the value that is obtained by removing the value of <TT>x</TT> from the current value of <TT>s</TT>. An exception shall be raised if the value of <TT>x</TT> is not a value of the base type of <TT>s</TT>. 
<P><HR>
<A NAME="0213">
<A HREF="#0209" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0212" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0214" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Procedure HALT</H4>

<P>The procedure <TT>HALT</TT> can be used to terminate the execution of a program at a point other than the end of the program block. 
<P><B>Static Semantics</B> 
<P>A call of <TT>HALT</TT> shall have no actual parameters. 
<P><B>Dynamic Semantics</B> 
<P>The call <TT>HALT</TT> shall be a program termination event &mdash; see <A HREF="#0028" TARGET=body>Program Termination</A> 
<P><HR>
<A NAME="0214">
<A HREF="#0209" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0213" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0215" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Procedure INC</H4>

<P>The procedure <TT>INC</TT> can be used to increment the value of a variable that is of an ordinal type. 
<P><B>Static Semantics</B> 
<P>A call of <TT>INC</TT> shall have one or two actual parameters. The first parameter shall be a variable that is of an ordinal type. If there is a second parameter, it shall be an expression that is of a whole number type. 
<P>If the second parameter is of the Z-type, its value shall be subject to a constraint that depends on the type of the first parameter: if the first parameter is of the signed type (or is of a subrange type whose host type is the signed type), the value of the second parameter shall be less than or equal to the maximum value of the signed type; otherwise it shall be greater than or equal to zero. 
<P><B>Note:</B> These constraints are present because signed arithmetic will be used if the first parameter is of the signed type, and unsigned arithmetic will be used in all other cases. 
<P><B>Clarification:</B> In <I>Programming in Modula-2</I> the types of the parameters of <TT>INC</TT> are not specified. 
<P><B>Dynamic Semantics</B> 
<P>The call <TT>INC(x)</TT> shall assign to the variable <TT>x</TT> the successor of its current value. An exception shall be raised if the successor lies outside the range of the type of <TT>x</TT>, or if there is no successor. 
<P>The call <TT>INC(x,N)</TT> shall assign to the variable <TT>x</TT> the Nthe N
<P><HR>
<A NAME="0215">
<A HREF="#0209" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0214" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0216" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Procedure INCL</H4>

<P>The procedure <TT>INCL</TT> can be used to add an element to a variable that is of a set type or a packedset type. 
<P><B>Static Semantics</B> 
<P>A call of <TT>INCL</TT> shall have two actual parameters. The first parameter shall be a variable that is of a set type or a packedset type, and the second parameter shall be an expression with which the the host type of the base type of the set type or packedset type is assignment-compatible. 
<P><B>Dynamic Semantics</B> 
<P>The call <TT>INCL(s,x)</TT> shall assign to the set variable <TT>s</TT> the value that is obtained by including the value of <TT>x</TT> in the current value of <TT>s</TT>. An exception shall be raised if the value of <TT>x</TT> is not a value of the base type of <TT>s</TT>. 
<P><HR>
<A NAME="0216">
<A HREF="#0209" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0215" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0217" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Procedure NEW</H4>

<P>The procedure <TT>NEW</TT> can often be used to obtain an area of dynamically allocated storage that is to be bound to a variable that is of a pointer type. 
<P><B>Note:</B> The word <I>often</I> appears because there is no requirement that the procedure <TT>ALLOCATE</TT> that is associated with <TT>NEW</TT> necessarily be the procedure <TT>Storage.ALLOCATE</TT>, or a procedure that performs a similar task. 
<P><B>Static Semantics</B> 
<P>A call of <TT>NEW</TT> shall have one or more actual parameters. The first parameter shall be a variable that is of a pointer type. 
<P>If the second and subsequent parameters are present, they shall be constant expressions and the bound type of the first parameter shall be a record type. 
<P>The identifier <TT>ALLOCATE</TT> shall be visible at the point of the call of <TT>NEW</TT> and shall designate a procedure, procedure constant, or procedure variable with the structure of a proper procedure that has two formal parameters. The first formal parameter of this proper procedure structure shall be a variable parameter that is of the address type, and the second formal parameter shall be a value parameter that is of the unsigned type. 
<P><B>Note:</B> The separate module <TT>Storage</TT> exports a procedure called <TT>ALLOCATE</TT> of the correct structure for a call of <TT>NEW</TT>. The requirement that the identifier <TT>ALLOCATE</TT> is visible at the point of the call of <TT>NEW</TT> is often satisfied by including the import list: 
<P><TT>FROM&nbsp;Storage&nbsp;IMPORT&nbsp;ALLOCATE;</TT> 
<P>in the module containing the call of <TT>NEW</TT>. 
<P><B>Dynamic Semantics</B> 
<P>The call <TT>NEW(P)</TT> shall have the same effect as the call <TT>ALLOCATE(P,SIZE(B))</TT>, where the variable <TT>P</TT> is of a pointer type <TT>T</TT>, and <TT>B</TT> is the bound type given in the declaration of <TT>T</TT>. 
<P>The call <TT>NEW(P,</TT> &lt; <I>expression-list</I> &gt;<TT>)</TT> shall have the same effect as the call 
<P><TT>ALLOCATE(P,SYSTEM.TSIZE(B,</TT> &lt; <I>expression-list</I> &gt;<TT>))</TT>, 
<P>where the variable <TT>P</TT> is of a pointer type <TT>T</TT>, and <TT>B</TT> is the bound type given in the declaration of <TT>T</TT>. 
<P><HR>
<A NAME="0217">
<A HREF="#0194" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0216" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0218" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Standard Functions</H3>

<P>The standard functions are denoted by the pervasive identifiers <TT>ABS</TT>, <TT>CAP</TT>, <TT>CHR</TT>, <TT>CMPLX</TT>, <TT>FLOAT</TT>, <TT>HIGH</TT>, <TT>IM</TT>, <TT>INT</TT>, <TT>LENGTH</TT>, <TT>LFLOAT</TT>, <TT>MAX</TT>, <TT>MIN</TT>, <TT>ODD</TT>, <TT>ORD</TT>, <TT>RE</TT>, <TT>SIZE</TT>, <TT>TRUNC</TT> and <TT>VAL</TT>. 
<P><B>Change:</B> The functions <TT>CMPLX</TT>, <TT>IM</TT>, <TT>INT</TT>, <TT>LENGTH</TT>, <TT>LFLOAT</TT> and <TT>RE</TT>are not described in <I>Programming in Modula-2</I>. 
<P><UL>
<LI><A HREF="#0218" TARGET=body>Standard Function Designators</A>
<LI><A HREF="#0219" TARGET=body>The Function ABS</A>
<LI><A HREF="#0220" TARGET=body>The Function CAP</A>
<LI><A HREF="#0221" TARGET=body>The Function CHR</A>
<LI><A HREF="#0222" TARGET=body>The Function CMPLX</A>
<LI><A HREF="#0223" TARGET=body>The Function FLOAT</A>
<LI><A HREF="#0224" TARGET=body>The Function HIGH</A>
<LI><A HREF="#0225" TARGET=body>The Function IM</A>
<LI><A HREF="#0226" TARGET=body>The Function INT</A>
<LI><A HREF="#0227" TARGET=body>The Function LENGTH</A>
<LI><A HREF="#0228" TARGET=body>The Function LFLOAT</A>
<LI><A HREF="#0229" TARGET=body>The Function MAX</A>
<LI><A HREF="#0230" TARGET=body>The Function MIN</A>
<LI><A HREF="#0231" TARGET=body>The Function ODD</A>
<LI><A HREF="#0232" TARGET=body>The Function ORD</A>
<LI><A HREF="#0233" TARGET=body>The Function RE</A>
<LI><A HREF="#0234" TARGET=body>The Function SIZE</A>
<LI><A HREF="#0235" TARGET=body>The Function TRUNC</A>
<LI><A HREF="#0236" TARGET=body>The Function VAL</A>
<LI><A HREF="#0237" TARGET=body>Auxiliary Definitions</A>
</UL>
<P><HR>
<A NAME="0218">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0217" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0219" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Standard Function Designators</H4>

<P><HR>
<A NAME="0219">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0218" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0220" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function ABS</H4>

<P>The function <TT>ABS</TT> can be used to obtain the absolute value of a value of a real number type or a whole number type. 
<P><B>Static Semantics</B> 
<P>A call of <TT>ABS</TT> shall have one actual parameter, which shall be an expression that is of a real number type or a whole number type, except that the expression shall not be of the unsigned type. 
<P>The type of a call of <TT>ABS</TT> shall be the same type as the expression. 
<P><B>Clarification:</B> In <I>Programming in Modula-2</I> the type of the parameter of <TT>ABS</TT> is not specified. 
<P><B>Note:</B> An expression that is a value designator that is of a subrange type is regarded as being of the host type of the subrange type. A call of <TT>ABS</TT> applied to such an expression returns a value of the host type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the <TT>call&nbsp;ABS(x)</TT> shall be the absolute value of <TT>x</TT>. An exception shall be raised if this value lies outside the range of the type of <TT>x</TT>. 
<P><B>Note:</B> An exception occurs if the value of <TT>x</TT> is less than zero and the corresponding positive value does not belong to the type of <TT>x</TT> &mdash; this can only occur if this type has a non-symmetric range. 
<P><HR>
<A NAME="0220">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0219" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0221" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function CAP</H4>

<P>The function <TT>CAP</TT> can be used to obtain the upper-case equivalent of a lower-case character for those characters that have such equivalents. 
<P><B>Static Semantics</B> 
<P>A call of <TT>CAP</TT> shall have one actual parameter, which shall be an expression that is of the character type. 
<P>The type of a call of <TT>CAP</TT> shall be the character type. 
<P><B>Dynamic Semantics</B> 
<P>If the value of <TT>c</TT> is a lower-case letter, the value of the call <TT>CAP(c)</TT> shall be the implementation-defined upper-case letter corresponding to the value of <TT>c</TT>; otherwise it shall be the value of <TT>c</TT>. 
<P><B>Clarification:</B> In <I>Programming in Modula-2</I> the behaviour of <TT>CAP</TT> is only specified when the parameter is a letter. However, some examples in <I>Programming in Modula-2</I> assume that <TT>CAP</TT> is defined for all values of the character type. This International Standard defines <TT>CAP</TT> for all values of the character type. 
<P><B>Auxiliaries</B> 
<P>annotations Defining <I>capitalizations</I> in this way avoids a dependency on the collating sequence of the character values. <I>implementation-capitalizations</I> is a means by which implementations may have extra capitalization rules (e.g.
<P><HR>
<A NAME="0221">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0220" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0222" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function CHR</H4>

<P>The function <TT>CHR</TT> can be used to obtain the value of the character type that has a specified ordinal number. 
<P><B>Static Semantics</B> 
<P>A call of <TT>CHR</TT> shall have one actual parameter, which shall be an expression that is of a whole number type. 
<P>The type of a call of <TT>CHR</TT> shall be the character type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>CHR(x)</TT> shall be the same as the value of the call <TT>VAL(CHAR,x)</TT> (see <A HREF="#0236" TARGET=body>The Function VAL</A>). 
<P><B>Note:</B> An exception occurs if the value of <TT>x</TT> is less than zero, or if it lies outside the range of the ordinal numbers of the character type. 
<P><HR>
<A NAME="0222">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0221" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0223" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function CMPLX</H4>

<P>The function <TT>CMPLX</TT> can be used to obtain a value of a complex number type from a pair of expressions specifying its real and imaginary parts. 
<P><B>Static Semantics</B> 
<P>A call of <TT>CMPLX</TT> shall have two actual parameters. Each parameter shall be an expression, which shall be of a real number type. 
<P>If both expressions are of the real type, or if one is of the real type and the other is of the R-type, the type of a call of <TT>CMPLX</TT> shall be the complex type. If both expressions are of the long real type, or if one is of the long real type and the other is of the R-type, the type of the call shall be the long complex type. If both expressions are of the R-type, the type of the call shall be the C -type. 
<P><B>Note:</B> The following table gives the permitted types and the type of the call. 
<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid solid;border-width: 1px 1px 1px 1px">&nbsp;</TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid none solid none;border-width: 1px 0px 1px 0px">real type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid none solid none;border-width: 1px 0px 1px 0px">long real type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px">R-type</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px">real type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">complex type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">error </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">complex type</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px">long real type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">error </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">long complex type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">long complex type</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px">R-type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">complex type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;">long complex type </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">C -type </TD>
</TR>
</TABLE>
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>CMPLX(x,y)</TT> shall be an implementation-defined approximation to the complex number whose real part is the value of <TT>x</TT> and whose imaginary part is the value of <TT>y</TT>. 
<P><B>Note:</B> An exception occurs if this approximation lies outside the range of the type of the call. 
<P><HR>
<A NAME="0223">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0222" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0224" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function FLOAT</H4>

<P>The function <TT>FLOAT</TT> can be used to obtain a value of the real type from a value of a real number type or a whole number type. 
<P><B>Static Semantics</B> 
<P>A call of <TT>FLOAT</TT> shall have one actual parameter, which shall be an expression that is of a real number type or a whole number type. 
<P>The type of a call of <TT>FLOAT</TT> shall be the real type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>FLOAT(x)</TT> shall be the same as the value of the call <TT>VAL(REAL,x)</TT> (see <A HREF="#0236" TARGET=body>The Function VAL</A>). 
<P><B>Note:</B> An exception occurs if the value of <TT>x</TT> lies outside the range of the real type. 
<P><HR>
<A NAME="0224">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0223" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0225" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function HIGH</H4>

<P>The function <TT>HIGH</TT> can be used to obtain the upper bound of the index type of a one-dimensional open array formal parameter, or the upper bound of an index type of a multi-dimensional open array formal parameter. 
<P><B>Change:</B> Multi-dimensional open array parameters are not described in <I>Programming in Modula-2</I> . 
<P><B>Clarification:</B> This International Standard permits <TT>HIGH</TT> to be applied only to an open array parameter; it does not permit <TT>HIGH</TT> to be applied to an ordinary array variable. 
<P><B>Static Semantics</B> 
<P>A call of <TT>HIGH</TT> shall have one actual parameter, which shall be a designator of a variable that is of an open array formal type. 
<P><B>Note:</B> A variable that is of an open array formal type is either an open array formal parameter or a component of an open array formal parameter that has an open array component type. 
<P>The type of a call of <TT>HIGH</TT> shall be the unsigned type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>HIGH(x)</TT> shall be the upper bound of the index type of an array type that has the same number of components of the same component type as <TT>x</TT>, but has an index type declared as a subrange of the unsigned type with a lower bound of zero. 
<P>An exception shall be raised if the value to be returned lies outside the range of the unsigned type. 
<P><B>Example:</B> Result of <TT>HIGH</TT>. Given: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;TYPE&nbsp;colour&nbsp;=&nbsp;(red,&nbsp;yellow,&nbsp;green);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;a:&nbsp;ARRAY&nbsp;[-7..-2]&nbsp;OF&nbsp;ARRAY&nbsp;BOOLEAN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OF&nbsp;ARRAY&nbsp;colour&nbsp;OF&nbsp;REAL;

&nbsp;&nbsp;&nbsp;&nbsp;PROCEDURE&nbsp;p&nbsp;(f:&nbsp;ARRAY&nbsp;OF&nbsp;ARRAY&nbsp;OF&nbsp;ARRAY&nbsp;OF&nbsp;REAL);
</PRE>

<P>then, for a call of <TT>HIGH</TT> from within the body of <TT>p</TT> that was activated by &lsquo;<TT>p(a)</TT>&rsquo; 
<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid solid;border-width: 1px 1px 1px 1px">expression </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px">result</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>HIGH(f)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>5</TT></TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>HIGH(f[0])</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>1</TT></TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>HIGH(f[0,0])</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>2</TT></TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>HIGH(f[0,0,0])</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">error </TD>
</TR>
</TABLE>
<P><HR>
<A NAME="0225">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0224" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0226" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function IM</H4>

<P>The function <TT>IM</TT> can be used to obtain the imaginary part of a value of a complex number type. 
<P><B>Static Semantics</B> 
<P>A call of <TT>IM</TT> shall have one actual parameter, which shall be an expression that is of a complex number type. 
<P>If the expression is of the complex type, the type of a call of <TT>IM</TT> shall be the real type; if the expression is of the long complex type, the type of the call shall be the long real type; otherwise the expression shall be of the C -type, and the type of the call shall be the R-type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>IM(z)</TT> shall be an implementation-defined approximation to the imaginary part of <TT>z</TT>. 
<P><HR>
<A NAME="0226">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0225" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0227" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function INT</H4>

<P>The function <TT>INT</TT> can be used to obtain a value of the signed type from a value of an ordinal type or a real number type. 
<P><B>Static Semantics</B> 
<P>A call of <TT>INT</TT> shall have one actual parameter, which shall be an expression that is of an ordinal type or a real number type. 
<P>The type of a call of <TT>INT</TT> shall be the signed type. 
<P>Dynamic Semantics 
<P>The value of the call INT(x) shall be the same as the value of the call VAL(INTEGER,x) (see <A HREF="#0236" TARGET=body>The Function VAL</A>). 
<P><B>Note:</B> An exception occurs if the value to be returned lies outside the range of the signed type. 
<P><HR>
<A NAME="0227">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0226" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0228" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function LENGTH</H4>

<P>The function <TT>LENGTH</TT> can be used to obtain the length of a string value. 
<P><B>Static Semantics</B> 
<P>A call of <TT>LENGTH</TT> shall have one actual parameter, which shall be an expression that is of a string literal type or is an array that contains a string value. 
<P>The type of a call of <TT>LENGTH</TT> shall be the unsigned type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>LENGTH(s)</TT> shall be the number of characters in the string value <TT>s</TT>. 
<P><HR>
<A NAME="0228">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0227" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0229" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function LFLOAT</H4>

<P>The function <TT>LFLOAT</TT> can be used to obtain a value of the long real type from a value of a real number type or a whole number type. 
<P><B>Static Semantics</B> 
<P>A call of <TT>LFLOAT</TT> shall have one actual parameter, which shall be an expression that is of a real number type or a whole number type. 
<P>The type of a call of <TT>LFLOAT</TT> shall be the long real type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>LFLOAT(x)</TT> shall be the same as the value of the call <TT>VAL(LONGREAL,x)</TT> (see <A HREF="#0236" TARGET=body>The Function VAL</A>). 
<P><B>Note:</B> An exception occurs if the value of <TT>x</TT> lies outside the range of the long real type. 
<P><HR>
<A NAME="0229">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0228" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0230" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function MAX</H4>

<P>The function <TT>MAX</TT> can be used to obtain the maximum value of a scalar type. 
<P><B>Static Semantics</B> 
<P>A call of <TT>MAX</TT> shall have one actual parameter, which shall be a type parameter that denotes a scalar type. 
<P>If the type denoted by the type parameter is a real number type or a whole number type, or the host type of the denoted type is a whole number type (in the case where the denoted type is a subrange type), the type of a call of <TT>MAX</TT> shall be the type of a literal value of that number type; otherwise the type of the call shall be the host type of the type denoted by the type parameter. 
<P><B>Clarification:</B> The function <TT>MAX</TT> may be applied to any scalar type (including the real number types denoted by <TT>REAL</TT> and <TT>LONGREAL</TT>). 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>MAX(T)</TT> shall be the largest value of the type denoted by <TT>T</TT>. 
<P><B>Example:</B> Result of <TT>MAX</TT>. Given: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;TYPE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;percentage&nbsp;=&nbsp;CARDINAL[0..100];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;countdown&nbsp;=&nbsp;INTEGER[-9..-1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colours&nbsp;=&nbsp;(red,&nbsp;yellow,&nbsp;green);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coward&nbsp;=&nbsp;colours[yellow..yellow];
</PRE>

<P>then: 
<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid solid;border-width: 1px 1px 1px 1px">expression </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px">value </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px">type </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>MAX(percentage)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>100</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">Z-type </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>MAX(countdown)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>-1</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">Z-type </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>MAX(colours)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>green</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>colours</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid solid solid;border-width: 0px 1px 1px 1px"><TT>MAX(coward)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px"><TT>yellow</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px"><TT>colours</TT> </TD>
</TR>
</TABLE>&lsquo;<TT>MAX(CARDINAL)</TT>&rsquo; and &lsquo;<TT>MAX(INTEGER)</TT>&rsquo; are also of the Z-type. 
<P><HR>
<A NAME="0230">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0229" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0231" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function MIN</H4>

<P>The function <TT>MIN</TT> can be used to obtain the minimum value of a scalar type. 
<P><B>Static Semantics</B> 
<P>A call of <TT>MIN</TT> shall have one actual parameter, which shall be a type parameter that denotes a scalar type. 
<P>If the type denoted by the type parameter is a real number type or a whole number type, or the host type of the denoted type is a whole number type (in the case where the denoted type is a subrange type), the type of a call of <TT>MIN</TT> shall be the type of a literal value of that number type; otherwise the type of the call shall be the host type of the type denoted by the type parameter. 
<P><B>Clarification:</B> The function <TT>MIN</TT> may be applied to any scalar type (including the real number types denoted by <TT>REAL</TT> and <TT>LONGREAL</TT>). 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>MIN(T)</TT> shall be the smallest value of the type denoted by <TT>T</TT>. 
<P><B>Note:</B> The value of the call <TT>MIN(R)</TT>, where R denotes a real number type, is the largest negative value of that type, and not the smallest non-zero positive value of that type. The smallest non-zero positive values of the real type and the long real type are defined by the values of the constants <TT>LowReal.small</TT> and <TT>LowLong.small</TT> respectively &mdash; see ???.
<P><B>Example:</B> Result of <TT>MIN</TT>. Given: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;TYPE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;percentage&nbsp;=&nbsp;CARDINAL[0..100];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;countdown&nbsp;=&nbsp;INTEGER[-9..-1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;colours&nbsp;=&nbsp;(red,&nbsp;yellow,&nbsp;green);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coward&nbsp;=&nbsp;colours[yellow..yellow];
</PRE>

<P>then: 
<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid solid;border-width: 1px 1px 1px 1px">expression </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px">value </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px">type </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>MIN(percentage)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>0</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">Z-type </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>MIN(countdown)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>-9</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">Z-type </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>MIN(colours)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>red</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>colours</TT> </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid solid solid;border-width: 0px 1px 1px 1px"><TT>MIN(coward)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px"><TT>yellow</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px"><TT>colours</TT> </TD>
</TR>
</TABLE>&lsquo;<TT>MIN(CARDINAL)</TT>&rsquo; and &lsquo;<TT>MIN(INTEGER)</TT>&rsquo; are also of the Z-type. 
<P><HR>
<A NAME="0231">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0230" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0232" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function ODD</H4>

<P>The function <TT>ODD</TT> can be used to determine whether a value of a whole number type is even or odd. 
<P><B>Static Semantics</B> 
<P>A call of <TT>ODD</TT> shall have one actual parameter, which shall be an expression that is of a whole number type. 
<P>The type of a call of <TT>ODD</TT> shall be the Boolean type. 
<P><B>Dynamic Semantics</B> 
<P>If the absolute value of <TT>x</TT> is odd, the value of the call <TT>ODD(x)</TT> shall be the value <I>true</I> ; otherwise it shall be the value <I>false</I> . 
<P><HR>
<A NAME="0232">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0231" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0233" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function ORD</H4>

<P>The function <TT>ORD</TT> can be used to obtain the ordinal number of a value of an ordinal type. 
<P><B>Static Semantics</B> 
<P>A call of <TT>ORD</TT> shall have one actual parameter, which shall be an expression that is of an ordinal type. 
<P>The type of a call of <TT>ORD</TT> shall be the unsigned type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>ORD(x)</TT> shall be the same as the value of the call <TT>VAL(CARDINAL,x)</TT> (see <A HREF="#0236" TARGET=body>The Function VAL</A>). 
<P><B>Note:</B> An exception occurs if the value to be returned lies outside the range of the unsigned type. 
<P><HR>
<A NAME="0233">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0232" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0234" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function RE</H4>

<P>The function <TT>RE</TT> can be used to obtain the real part of a value of a complex number type. 
<P><B>Static Semantics</B> 
<P>A call of <TT>RE</TT> shall have one actual parameter, which shall be an expression that is of a complex number type. 
<P>If the expression is of the complex type, the type of a call of <TT>RE</TT> shall be the real type; if the expression is of the long complex type, the type of the call shall be the long real type; otherwise the expression shall be of the C -type, and the type of the call shall be the R-type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>RE(z)</TT> shall be an implementation-defined approximation to the real part of <TT>z</TT>. 
<P><HR>
<A NAME="0234">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0233" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0235" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function SIZE</H4>

<P>The function <TT>SIZE</TT> can be used to ascertain the amount of storage that is used for a variable of a particular type. 
<P><B>Static Semantics</B> 
<P>A call of <TT>SIZE</TT> shall have one actual parameter, which shall either be a type parameter, or an entire designator that does not denote an open array parameter. 
<P>The type of a call of <TT>SIZE</TT> shall be the Z-type. 
<P><B>Change:</B> In <I>Programming in Modula-2</I> the parameter may be the identifier of a type or a variable. There is no constraint that the variable is an entire designator that does not denote an open array parameter. 
<P><B>Notes:</B> 
<OL>
 
<LI>If the parameter to <TT>SIZE</TT> is a variable designator, it must be an entire designator: it cannot be a component of an array, a field of a record, or the variable referenced by a pointer variable. </LI>
<LI>The constraints on the parameter ensure that a call of <TT>SIZE</TT> is always permitted in a constant expression. </LI>
</OL>

<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>SIZE(T)</TT>, where <TT>T</TT> denotes any identified type, shall be the number of storage locations (see <A HREF="isom2004.html#0310" TARGET=body>System Storage Types</A>) that would be occupied by a variable that is of type <TT>T</TT>. If <TT>T</TT> denotes a record type with a group or groups of variant fields, the value of the call shall be the maximum number of storage locations that could be occupied. An exception shall be raised if this number lies outside the range of the Z-type. 
<P>The value of the call <TT>SIZE(v)</TT>, where <TT>v</TT> is an entire designator of any type, shall be the same as the value of a call SIZE(T) with an actual parameter <TT>T</TT> that is a qualified identifier denoting the type of <TT>v</TT>. 
<P><B>Note:</B> In calls of the form <TT>SIZE(v)</TT>, <TT>v</TT> may designate a variable of an anonymous type. 
<P><HR>
<A NAME="0235">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0234" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0236" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function TRUNC</H4>

<P>The function <TT>TRUNC</TT> can be used to obtain a value of the unsigned type from a value of a real number type. 
<P><B>Static Semantics</B> 
<P>A call of <TT>TRUNC</TT> shall have one actual parameter, which shall be an expression that is of a real number type. 
<P>The type of a call of <TT>TRUNC</TT> shall be the unsigned type. 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>TRUNC(x)</TT> shall be the same as the value of the call <TT>VAL(CARDINAL,x)</TT> (see <A HREF="#0236" TARGET=body>The Function VAL</A>). 
<P><B>Note:</B> An exception occurs if the integral part of <TT>x</TT> lies outside the range of the unsigned type. 
<P><HR>
<A NAME="0236">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0235" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0237" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Function VAL</H4>

<P>The function <TT>VAL</TT> can be used to obtain a value of a specified scalar type from an expression of a scalar type. 
<P><B>Change:</B> The definition of <TT>VAL</TT> given in <I>Programming in Modula-2</I> has been extended. 
<P><B>Static Semantics</B> 
<P>A call of <TT>VAL</TT> shall have two actual parameters. The first parameter shall be a type parameter that denotes a scalar type. If the type denoted by the type parameter is a subrange type, the type of a call of <TT>VAL</TT> shall be the host type of the subrange type; otherwise it shall be the type denoted by the type parameter. The type of the call is called the final-type. 
<P>The second parameter shall be an expression that is of a scalar type, subject to the restriction that at least one of the following shall hold: 
<P>a) The final-type and the type of the expression are identical. 
<P>b) The final-type is a whole number type or a real number type, and the type of the expression is a whole number type or a real number type. 
<P>c) The final-type is a whole number type. 
<P>d) The type of the expression is a whole number type. 
<P><B>Note:</B> In the following table,enumeration type. 
<P>the type of the type denoted by the type parameter the expression CARDINAL* INTEGER* REAL LONGREAL CHAR* BOOLEAN* the type T* CARDINAL p p p p p p p INTEGER p p p p p p p Z-type p p p p p p p REAL p p p p ? ? ? LONGREAL p p p p ? ? ? R-type p p p p ? ? ? CHARy p p ? ? p ? ? BOOLEAN p p ? ? ? p ? the type T p p ? ? ? ? p 
<P>* or a subrange of this type y or string literal type of length 0 or 1 
<P><B>Dynamic Semantics</B> 
<P>The value of the call <TT>VAL(R,x)</TT>, where the type <TT>R</TT> is a real number type, shall be a value of the type <TT>R</TT> that is an implementation-defined approximation to the value of <TT>x</TT>. An exception shall be raised if the value of <TT>x</TT> lies outside the range of the type <TT>R</TT>. 
<P>The value of the call <TT>VAL(T,x)</TT>, where the type <TT>T</TT> is an ordinal type, the host type of this type is a whole number type, and the type of the expression <TT>x</TT> is a whole number type or a real number type, shall be the integral part of the value of <TT>x</TT>. An exception shall be raised if the integral part of <TT>x</TT> lies outside the range of the type <TT>T</TT>. 
<P>The value of the call <TT>VAL(T,x)</TT>, where the type <TT>T</TT> or the type of <TT>x</TT> (or both of these types) are not whole number types or real number types, shall be the value of the type <TT>T</TT> that has an ordinal number equal to the ordinal number of the value of <TT>x</TT>. An exception shall be raised if the value of <TT>x</TT> is a numerical value that is less than zero, or if the ordinal number of the value of <TT>x</TT> lies outside the range of the ordinal numbers of the type <TT>T</TT>. 
<P><B>Note:</B> <TT>VAL</TT> does not round. If <TT>x</TT> is of a real number type, the expressions <TT>VAL(INTEGER,x)</TT> and <TT>VAL(CARDINAL,x)</TT> both have the value of <TT>x</TT> truncated. 
<P><B>Example:</B> Result of <TT>VAL</TT>. Given: 
<P><PRE>&nbsp;&nbsp;&nbsp;&nbsp;TYPE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Days&nbsp;=&nbsp;(Sun,&nbsp;Mon,&nbsp;Tue,&nbsp;Wed,&nbsp;Thu,&nbsp;Fri,&nbsp;Sat);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WeekDays&nbsp;=&nbsp;[Mon..Fri];
&nbsp;&nbsp;&nbsp;&nbsp;VAR
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i,&nbsp;j,&nbsp;z:&nbsp;INTEGER;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r:&nbsp;REAL;
&nbsp;&nbsp;&nbsp;&nbsp;and:
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;42;&nbsp;j&nbsp;:=&nbsp;-1;&nbsp;z&nbsp;:=&nbsp;0;&nbsp;r&nbsp;:=&nbsp;-2.7;
</PRE>

<P>then: 
<P><TABLE CELLSPACING=0>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid solid;border-width: 1px 1px 1px 1px">expression </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px">value </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px">type</TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>VAL(CARDINAL,i)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>42</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>CARDINAL</TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>VAL(CARDINAL,j)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">Exception </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">&nbsp;</TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid solid;border-width: 0px 1px 1px 1px"><TT>VAL(CARDINAL,r)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px">Exception </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px">&nbsp;</TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>VAL(INTEGER,i)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>42</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>INTEGER</TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid solid;border-width: 0px 1px 1px 1px"><TT>VAL(INTEGER,r)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px"><TT>-2</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px"><TT>INTEGER</TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>VAL(REAL,i)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>42.0</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>REAL</TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>VAL(REAL,TRUE)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">Error </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">&nbsp;</TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid solid;border-width: 0px 1px 1px 1px"><TT>VAL(LONGREAL,r)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px"><TT>-2.7</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px"><TT>LONGREAL</TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>VAL(CHAR,z)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>0C</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>CHAR</TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid solid;border-width: 0px 1px 1px 1px"><TT>VAL(CHAR,r)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px">Error </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px">&nbsp;</TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>VAL(BOOLEAN,0)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>FALSE</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>BOOLEAN</TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>VAL(Days,5)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>Fri</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">Days</TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>VAL(WeekDays,5)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px"><TT>Fri</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">Days</TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>VAL(WeekDays,z)</TT> </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">Exception </TD>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">&nbsp;</TD>
</TR>
</TABLE>
<P><HR>
<A NAME="0237">
<A HREF="#0217" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0236" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0238" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Auxiliary Definitions</H4>

<P>annotations Carry out type conversion; convert the argument to a corresponding value of another type. 
<P>annotations Return the integral part of a given numerical value. 
<P>
<P><HR>
<A NAME="0238">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0237" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0239" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>The Environment and Auxiliary Formal Definitions</H2>

<P><UL>
<LI><A HREF="#0239" TARGET=body>Environments</A>
<LI><A HREF="#0244" TARGET=body>Operations on the Environment</A>
<LI><A HREF="#0256" TARGET=body>Types</A>
<LI><A HREF="#0266" TARGET=body>Unit Types</A>
<LI><A HREF="#0273" TARGET=body>Other Type Functions</A>
<LI><A HREF="#0279" TARGET=body>Values Associated with a Type</A>
</UL>
<P><HR>
<A NAME="0239">
<A HREF="#0238" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0238" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0240" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Environments</H3>

<P>An environment associates an identifier with an entity, and with the properties of that entity. This association involves at most one of the following: 
<P>&mdash; For an identifier that denotes a constant entity, the property is its type. 
<P>&mdash; For an identifier that denotes a type, the entity is either a basic type or a unique type name. For an entity that is of a constructed type the environment associates the type name with the structure of that type including, for a structured (composite) type, the component type names. 
<P>&mdash; For an identifier that denotes a variable, when checking the well-formed properties of a program, the property of the entity is its type; when giving a meaning to the program, the entity is the associated variable. 
<P>&mdash; For an identifier that denotes a declared procedure, when checking the well-formed properties of a program, the properties of the entity are its structure and its declaration level; when giving a meaning to the program, the entity incorporates the elaborated formal parameters, and the identity of the procedure denotation (as constructed from the elaboration of the procedure declaration). 
<P>&mdash; For an identifier that denotes a module, the entity is the environment defined by the declarations contained in the module, as restricted by any exports. 
<P>An environment contains the declaration level of the block to which it applies; the static continuations for return, exception, loopexit, and retry. and information on the protection domain, if any, that applies. 
<P><UL>
<LI><A HREF="#0240" TARGET=body>Structures</A>
<LI><A HREF="#0241" TARGET=body>Expression Types</A>
<LI><A HREF="#0242" TARGET=body>Types for Declared Procedures</A>
<LI><A HREF="#0243" TARGET=body>Variables</A>
</UL>
<P><HR>
<A NAME="0240">
<A HREF="#0239" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0239" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0241" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Structures</H4>

<P>annotations The structure of an enumeration type is the sequence of identifiers defined by the type. The order of the identifiers in the sequence is identical to their order in the type definition. 
<P>annotations The structure of a subrange type is the range type and a set of values defined by the lower and upper bounds of the type definition. 
<P>annotations The structure of a set type is the type name or basic type of the base type. 
<P>annotations The structure of a packedset type is the type name or basic type of the base type. 
<P>annotations The structure of a pointer type is the the type name or basic type of the bound type. The bound type is optional because forward use of a type name is allowed in the context of a pointer type. 
<P>annotations The structure of a proper procedure or proper procedure type is the type names (or basic types) of the formal parameters of the procedure. 
<P>annotations The structure of a function procedure or function procedure type is the type names (or basic types) of the formal parameters of the procedure, together with the the type names or basic types of the result. The return type is optional because forward use of a type name is allowed in the context of a procedure type. 
<P>annotations A variable can either be introduced in a variable declaration or it can be a parameter of a procedure. Thus it will either be associated with its type name or its basic type, or it can be an open array parameter. The type is optional here because forward use of a type name is allowed in the context of a procedure type. 
<P>annotations The structure of an array type is the type names (or basic types) of the index and component types. 
<P>annotations The structure of a record type is the type names (or basic types) of the components of the record. 
<P>annotations The <I>String-type</I> is an basic type with a structure that allows the length of a literal string to be represented. Since it is an anonymous type, it can only be the type of an expression. 
<P><HR>
<A NAME="0241">
<A HREF="#0239" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0240" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0242" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Expression Types</H4>

<P>annotations The result of an expression can be: &mdash; a value of a basic type, or a value whose type has been defined in a declaration; &mdash; a string literal; &mdash; the nil value; &mdash; a procedure; or &mdash; an open array. 
<P>annotations The structure of the result of an expression can be: &mdash; the structure of a type that has been defined in a declaration; &mdash; the structure of a string literal; &mdash; the structure of a procedure (which is the same as the structure of a procedure type under <I>Structure</I> ; or &mdash; the structure of an open array. 
<P><HR>
<A NAME="0242">
<A HREF="#0239" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0241" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0243" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Types for Declared Procedures</H4>

<P>annotations <I>ptyped</I> is the type structure and declaration level information from the elaboration of the procedure declaration. <I>value</I> is the value that is assigned to procedure variables and the value that is used in procedure calls to retrieve the procedure denotation from the state; it is optional because procedure headings can appear separately from procedure declarations in definitions and in forward declarations. 
<P>annotations <I>type</I> corresponds to the type structure for procedure types and is used for procedure calls and for checking compat- ibility. <I>level</I> is the declaration level at which the procedure is declared and is used in checks of assignment comaptibility. 
<P>annotations type corresponds to the type structure for procedure types and is used for procedure calls and for checking compat- ibility. level is the declaration level at which the procedure is declared and is used in checks of assignment comaptibility. 
<P><HR>
<A NAME="0243">
<A HREF="#0239" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0242" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0244" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Variables</H4>

<P>annotations If the identifier is associated with an elementary variable that is of a subrange type, then the range component contains the possible set of values that can be assigned to the variable. 
<P>annotations If the identifier is associated with a pointer variable then the type of the pointer is associated with the variable so that any pointer dereferencing can be checked. 
<P>annotations The components of an array variable are all of the same type. 
<P>annotations A variant variable contains information about the explicit tag associated with the variant fields of which the variable is a component; thus before accessing the value of the variable, the tag can be checked to see if its value is such that the variant that contains the variable is active. 
<P>annotations A tag variable contains information about the variant components that are associated with it. Thus any change to the value of the tag that will cause a different component to be selected can be reflected by setting the variables of the old component to undefined. 
<P>annotations A tagged variable contains information about the implicit tag associated with the variant fields of which the variable is a component; thus before accessing the value of the variable, the tag can be checked to see if its value is such that the variant that contains the variable is active. 
<P><HR>
<A NAME="0244">
<A HREF="#0238" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0243" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0245" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Operations on the Environment</H3>

<P><UL>
<LI><A HREF="#0245" TARGET=body>Functions Accessing the Constants Component of the Environment</A>
<LI><A HREF="#0246" TARGET=body>Functions Accessing the Types Component of the Environment</A>
<LI><A HREF="#0247" TARGET=body>Functions Accessing the Structures Component of the Environment</A>
<LI><A HREF="#0248" TARGET=body>Functions Accessing the Variables Component of the Environment</A>
<LI><A HREF="#0249" TARGET=body>Functions Accessing the Procedures Component of the Environment</A>
<LI><A HREF="#0250" TARGET=body>Functions Accessing the Modules Component of the Environment</A>
<LI><A HREF="#0251" TARGET=body>Functions Accessing the Procedure Level Component of the Environment</A>
<LI><A HREF="#0252" TARGET=body>Functions Accessing the Continuations Component of the Environment</A>
<LI><A HREF="#0253" TARGET=body>Functions Accessing the Protection Components of the Environment</A>
<LI><A HREF="#0254" TARGET=body>Functions Accessing the Environment</A>
<LI><A HREF="#0255" TARGET=body>Operations to Update Environments</A>
</UL>
<P><HR>
<A NAME="0245">
<A HREF="#0244" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0244" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0246" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Functions Accessing the Constants Component of the Environment</H4>

<P>annotations Check that a qualident denotes a constant. 
<P>annotations The result is the unique type of a qualident that denotes a constant. 
<P>annotations The result is the constant value associated with a qualident that is introduced in a constant declaration. 
<P>annotations Construct an environment by overwriting the given environment with the given constants component. Any identifiers from the given environment that do not appear in the given constants component will remain visible in the new environment. 
<P><HR>
<A NAME="0246">
<A HREF="#0244" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0245" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0247" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Functions Accessing the Types Component of the Environment</H4>

<P>annotations Check that a qualident denotes a type. 
<P>annotations The result is the type name or basic type associated with a qualident that denotes a type. 
<P>annotations Construct an environment by overwriting the given environment with the given types component. Any identifiers from the given environment that do not appear in the given types component will remain visible in the new environment. 
<P><HR>
<A NAME="0247">
<A HREF="#0244" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0246" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0248" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Functions Accessing the Structures Component of the Environment</H4>

<P>annotations The result is the structure associated with a type or with a procedure. Only constructed types, procedures, and the <I>String-type</I> have a structure; other types are synonyms for the basic types or the basic types themselves. 
<P>annotations The result is the structure of a qualident that denotes a type. 
<P>annotations Construct an environment by overwriting the given environment with the given structure component. Any type names from the given environment that do not appear in the given structure component will remain in the domain of the new environment. 
<P><HR>
<A NAME="0248">
<A HREF="#0244" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0247" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0249" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Functions Accessing the Variables Component of the Environment</H4>

<P>annotations Check if a qualident denotes a variable; this may be a field of a record inside a with statement. 
<P>annotations The result is the type name or basic type of a qualident that denotes a variable; used with environments constructed for the <I>wf-</I> and <I>t-</I> functions. 
<P>annotations The result is the variable associated with a qualident that denotes a variable; used with environments constructed for the <I>m-</I> functions. 
<P>annotations Construct an environment by overwriting the given environment with the given variables component. Any identifiers from the given environment that do not appear in the given variables component will remain visible in the new environment. 
<P><HR>
<A NAME="0249">
<A HREF="#0244" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0248" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0250" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Functions Accessing the Procedures Component of the Environment</H4>

<P>annotations Check if a qualident denotes a procedure. 
<P>annotations The result is the type of a qualident that denotes a declared procedure; this is a record comprising the structure and declaration level information. 
<P>annotations The result is the type structure for a declared procedure. 
<P>annotations The result is the declaration level of a declared procedure. 
<P>annotations Construct an environment by overwriting the given environment with the given procs component. Any identifiers from the given environment that do not appear in the given procs component will remain visible in the new environment. 
<P><HR>
<A NAME="0250">
<A HREF="#0244" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0249" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0251" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Functions Accessing the Modules Component of the Environment</H4>

<P>annotations Checks if a qualident denotes a module. 
<P>annotations Return the module environment associated with the qualident. 
<P>annotations Return the environment associated with the module environment. 
<P>annotations Construct an environment by overwriting the given environment with the given module component. Any identifiers from the given environment that do not appear in the given module component will remain visible in the new environment. 
<P>annotations Return the local definition module environment associated with the qualident. 
<P><HR>
<A NAME="0251">
<A HREF="#0244" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0250" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0252" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Functions Accessing the Procedure Level Component of the Environment</H4>

<P>annotations Return the current declaration level of the environment. 
<P>annotations Increase the declaration level of declarations by one. 
<P><HR>
<A NAME="0252">
<A HREF="#0244" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0251" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0253" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Functions Accessing the Continuations Component of the Environment</H4>

<P>annotations Extract the current exception handler. 
<P><HR>
<A NAME="0253">
<A HREF="#0244" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0252" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0254" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Functions Accessing the Protection Components of the Environment</H4>

<P>annotations If a module is declared within a protected module, and this module is not protected, the same protection applies; otherwise the protection of this module applies. 
<P>annotations Extract the module protection expression and procedures from the environment. 
<P>annotations Add the set of exported identifiers to the environment. 
<P>annotations Extract the set of exported identifiers from the environment. 
<P><HR>
<A NAME="0254">
<A HREF="#0244" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0253" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0255" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Functions Accessing the Environment</H4>

<P>annotations Look up a (possibly qualified) identifier in the environment, and return the associated entity and its properties. 
<P>annotations The set of visible identifiers is the set defined by the union of all of the domains of various (mapping) components of the environment. The scope of these identifiers includes the points where the environment applies. 
<P><HR>
<A NAME="0255">
<A HREF="#0244" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0254" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0256" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Operations to Update Environments</H4>

<P>annotations Merge two environments. 
<P>annotations Merge all the environments contained in a set of environments. 
<P>annotations Overwrite the environment ? with the environment env . 
<P>annotations visible-identifiers(restrict-environment (ids )?) = ids 
<P>annotations The identifiers are visible in the new environment, but their meanings are unknown; used in checking declare before use rules. 
<P>annotations Combine the environments of a definition module and the associated implementation module. Note that the declarations for opaque types and procedures are taken from the implementation module. 
<P><HR>
<A NAME="0256">
<A HREF="#0238" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0255" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0257" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Types</H3>

<P><UL>
<LI><A HREF="#0257" TARGET=body>New Type Names</A>
<LI><A HREF="#0258" TARGET=body>Structured (Composite) Types</A>
<LI><A HREF="#0259" TARGET=body>Elementary Types</A>
<LI><A HREF="#0260" TARGET=body>Scalar Types</A>
<LI><A HREF="#0261" TARGET=body>Ordinal Types</A>
<LI><A HREF="#0262" TARGET=body>Whole Number Types</A>
<LI><A HREF="#0263" TARGET=body>Number Types</A>
<LI><A HREF="#0264" TARGET=body>String Types</A>
<LI><A HREF="#0265" TARGET=body>System Storage Types</A>
</UL>
<P><HR>
<A NAME="0257">
<A HREF="#0256" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0256" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0258" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>New Type Names</H4>

<P>annotations Generate a type name that has not been used elsewhere in the current environment. 
<P><HR>
<A NAME="0258">
<A HREF="#0256" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0257" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0259" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Structured (Composite) Types</H4>

<P>A structured (composite) type is an array type or a record type. 
<P>annotations Check that a type is a structured type. 
<P>annotations Check that a type denotes an array type. 
<P>annotations Check that a type denotes a record type. 
<P><HR>
<A NAME="0259">
<A HREF="#0256" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0258" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0260" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Elementary Types</H4>

<P>An elementary type is either a procedure type, a pointer type, an opaque type, a set type, a packedset type, a scalar type, or a complex number type. 
<P>annotations Check that a type is an elementary type. 
<P>annotations Check that a type-name denotes a proper procedure type or a function procedure type; these are the types of procedure variables. 
<P>annotations Check that a type denotes a proper procedure type; this is the type of a procedure variable of a proper procedure structure. 
<P>annotations Check that a type denotes a function procedure type; this is the type of a procedure variable of a function procedure structure. 
<P>annotations Check that a type denotes a set type. 
<P>annotations Check that a type denotes a packedset type. 
<P>annotations Check that a type denotes a pointer type. 
<P>annotations Check that a type denotes an opaque type. 
<P><HR>
<A NAME="0260">
<A HREF="#0256" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0259" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0261" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Scalar Types</H4>

<P>A scalar type is either an ordinal type or a real number type. 
<P>annotations Check that a type denotes a scalar type. 
<P><HR>
<A NAME="0261">
<A HREF="#0256" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0260" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0262" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Ordinal Types</H4>

<P>An ordinal type is either the Boolean type, the character type, an enumeration type, a subrange type, or a whole number type; the character literal type is included since it is interpreted as a value of the character type in contexts where an ordinal type is expected. 
<P>annotations Check that a type is an ordinal type. 
<P>annotations Check that a type is the character type. 
<P>annotations Check that a type is an enumeration type. 
<P>annotations Check that an identifier is an enumeration constant and thus denotes itself. 
<P>annotations Check that a type is a subrange type. 
<P><HR>
<A NAME="0262">
<A HREF="#0256" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0261" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0263" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Whole Number Types</H4>

<P>A whole number type is either the unsigned type, the signed type or the type of an expression whose operands are whole number literal values. 
<P>annotations Check that a type denotes a whole number type. 
<P>annotations Check that a type denotes the unsigned type. 
<P>annotations Check that a type denotes the signed type. 
<P>annotations Check that a type denotes the Z-type. 
<P><HR>
<A NAME="0263">
<A HREF="#0256" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0262" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0264" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Number Types</H4>

<P>A number type is a real number type or a whole number type. 
<P><B>Note:</B> A complex number type is not a &lsquo;number type&rsquo; as it does not permit relational operations. 
<P>annotations Check that a type denotes a real number type or a whole number type. 
<P><HR>
<A NAME="0264">
<A HREF="#0256" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0263" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0265" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>String Types</H4>

<P>The string type is the type of a literal string; it has a structure representing the length of the literal string. Values of the string literal type of length 0 or length 1 are distinguished as values of the character literal type since the character type is assignment compatible and expression compatible with this type. 
<P>annotations Check that a type denotes a string type of length 0 or 1. 
<P><HR>
<A NAME="0265">
<A HREF="#0256" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0264" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0266" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>System Storage Types</H4>

<P>A system storage type is either the location type, denoted by <TT>SYSTEM.LOC</TT>, the word type, denoted by <TT>SYSTEM.WORD</TT>, or the byte type, denoted by <TT>SYSTEM.BYTE</TT> if provided by an implementation. 
<P>annotations Check that a type denotes a system storage type. 
<P>annotations Check that a type denotes the location type. 
<P>annotations Check that a type denotes the address type. 
<P><HR>
<A NAME="0266">
<A HREF="#0238" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0265" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0267" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Unit Types</H3>

<P>A unit type is either the range type of a subrange type, the host type of a subrange type, the base type of a set type, the base type of a packedset type, the component type of an array type, the index type of an array type, or the bound type of a pointer type. 
<P><UL>
<LI><A HREF="#0267" TARGET=body>Range Type</A>
<LI><A HREF="#0268" TARGET=body>Host Type</A>
<LI><A HREF="#0269" TARGET=body>Base Type</A>
<LI><A HREF="#0270" TARGET=body>Component Type</A>
<LI><A HREF="#0271" TARGET=body>Index Type</A>
<LI><A HREF="#0272" TARGET=body>Bound Type</A>
</UL>
<P><HR>
<A NAME="0267">
<A HREF="#0266" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0266" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0268" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Range Type</H4>

<P>The range type of a subrange type is the ordinal type from which the subrange type is directly derived. 
<P>annotations The result is the range type of a subrange type. 
<P><HR>
<A NAME="0268">
<A HREF="#0266" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0267" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0269" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Host Type</H4>

<P>The host type of a subrange type is the ordinal type from which the subrange type is indirectly derived by defining a subrange of a previously defined ordinal type. It is the Boolean type, the character type, an enumeration type, the signed type, or the unsigned type. 
<P>annotations The result is the host type of a subrange type. 
<P><HR>
<A NAME="0269">
<A HREF="#0266" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0268" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0270" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Base Type</H4>

<P>The base type of a set type or a packedset type is the ordinal type to which the members of the set type or packedset type directly belong. 
<P>annotations The result is the base type of a set type or a packedset type. 
<P><HR>
<A NAME="0270">
<A HREF="#0266" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0269" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0271" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Component Type</H4>

<P>The component type of an array type is the type of the components of an array structure. 
<P>annotations The result is the component type of an array type. 
<P><HR>
<A NAME="0271">
<A HREF="#0266" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0270" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0272" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Index Type</H4>

<P>The index type of an array type is the type of the index of an array structure. 
<P>annotations The result is the index type of an array type. 
<P><HR>
<A NAME="0272">
<A HREF="#0266" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0271" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0273" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Bound Type</H4>

<P>The bound type of a pointer type is the type of the variable pointed to by a value of the pointer type. 
<P>annotations The result is the bound type of a pointer type. 
<P><HR>
<A NAME="0273">
<A HREF="#0238" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0272" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0274" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Other Type Functions</H3>

<P><UL>
<LI><A HREF="#0274" TARGET=body>Formal Parameter Types</A>
<LI><A HREF="#0275" TARGET=body>Auxiliary Functions for Records</A>
<LI><A HREF="#0276" TARGET=body>Auxiliary Functions for Arrays</A>
<LI><A HREF="#0277" TARGET=body>Auxiliary Functions for Open Arrays</A>
<LI><A HREF="#0278" TARGET=body>Auxiliary Functions for Opaque Types</A>
</UL>
<P><HR>
<A NAME="0274">
<A HREF="#0273" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0273" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0275" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Formal Parameter Types</H4>

<P>annotations Applied to the type of a value designator, this function returns the formal parameter structure and types for procedures, procedure constants, and procedure variables. 
<P><HR>
<A NAME="0275">
<A HREF="#0273" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0274" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0276" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Auxiliary Functions for Records</H4>

<P>annotations The result is a mapping whose domain is the field identifiers of the fixed part of a record together with the field identifiers of the variant component(s). In the mapping each field identifier is mapped to its declared type. 
<P>annotations Construct a mapping that is the union of the mappings constructed from each of the fields-structure components of the field-list-structure. 
<P>annotations Construct a mapping from either a fixed-fields-structure or a variant-fields-structure component of a field-list- structure. 
<P>annotations Construct a mapping whose domain is the field identifiers of all the variant components of a record, and in which each field identifier is mapped to its declared type. 
<P>annotations Construct a mapping whose domain is the tag identifier, the field identifiers of the variant components of a record and the field identifiers of the ELSE component, and in which each field identifier is mapped to its declared type. 
<P>annotations Construct a mapping that relates the identifiers belonging to every variant component of a record type with their declared types. 
<P>annotations Construct a mapping that relates the field identifiers of a particular variant component of a record type with their declared types. 
<P><HR>
<A NAME="0276">
<A HREF="#0273" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0275" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0277" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Auxiliary Functions for Arrays</H4>

<P>annotations Check that a type is an array type with signed index starting at zero. 
<P>annotations The result is the lower bound of an array. 
<P>annotations The result is the upper bound of an array. 
<P><HR>
<A NAME="0277">
<A HREF="#0273" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0276" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0278" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Auxiliary Functions for Open Arrays</H4>

<P>annotations Check that a type denotes an open array formal type. 
<P><HR>
<A NAME="0278">
<A HREF="#0273" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0277" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0279" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Auxiliary Functions for Opaque Types</H4>

<P>annotations The opaque types of an environment are those types whose structure is opaque. 
<P><HR>
<A NAME="0279">
<A HREF="#0238" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0278" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0280" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Values Associated with a Type</H3>

<P>The values associated with a type are the smallest and largest values that a value of that type may assume. 
<P>annotations Return the largest value of a type. 
<P>annotations Return the largest value of an enumeration type. This is denoted by the last identifier that occurs in the sequence of identifiers of the enumeration type. 
<P>annotations Return the largest value of a subrange type. 
<P>annotations Return the smallest value of a type. 
<P>annotations Return the smallest value of an enumeration type. This is denoted by the first identifier that occurs in the sequence of identifiers of the enumeration type. 
<P>annotations Return the smallest value of a subrange type. 
<P>annotations Return the set of values associated with a type. 
<P>annotations Return the set of value associated with an enumeration type. This is the set of values containing the identifiers that occurs in the sequence of identifiers of the enumeration type. 
<P>annotations Convert a natural number into an Enumeration-value. 
<P>annotations Return the set of value associated with an subrange type. 
<P>annotations Return a sequence of values associated with a type. This sequence is ordered by the values from which it is constructed. 
<P>
<P><HR>
<A NAME="0280">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0279" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0281" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>The Storage Model and Auxiliary Formal Definitions</H2>

<P><UL>
<LI><A HREF="#0281" TARGET=body>The External Program State</A>
<LI><A HREF="#0283" TARGET=body>The Store</A>
<LI><A HREF="#0286" TARGET=body>Exceptions</A>
<LI><A HREF="#0287" TARGET=body>Interrupt Handlers</A>
<LI><A HREF="#0288" TARGET=body>Operations on Storage</A>
<LI><A HREF="#0294" TARGET=body>Accessing the Procedure Denotation Component of the State</A>
<LI><A HREF="#0295" TARGET=body>Program Initialization and Program Termination</A>
<LI><A HREF="#0299" TARGET=body>Exception Handling</A>
<LI><A HREF="#0301" TARGET=body>Interrupt Handlers</A>
<LI><A HREF="#0302" TARGET=body>Accessing the Protection Component of the State</A>
<LI><A HREF="#0303" TARGET=body>Coroutine and Continuations</A>
</UL>
<P><HR>
<A NAME="0281">
<A HREF="#0280" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0280" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0282" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The External Program State</H3>

<P>annotations The <I>program-storage-pool</I> component of an <I>External-program-state</I> is an implementation dependent model of storage available to a Modula-2 program that consists of a set of Locs that denotes the initial free storage available to a program. The <I>external-store</I> component of an <I>External-program-state</I> is a model of the storage locations that a Modula-2 program can have access to via an address that is calculated from the machine address component of a variable declaration (see <A HREF="#0291" TARGET=body>Aliasing Machine Addresses</A>). 
<P><UL>
<LI><A HREF="#0282" TARGET=body>Operations to Initialize and Terminate the Program State</A>
</UL>
<P><HR>
<A NAME="0282">
<A HREF="#0281" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0281" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0283" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Operations to Initialize and Terminate the Program State</H4>

<P>annotations Initializes the state with the external program state. As part of the call of <I>read-external-program-state</I> , the changes to the library state of abstract implementation modules, as defined by the operation <I>read-external- &lt; libraryname &gt; -state</I> , should be carried out. 
<P>annotations This operation returns the final state of any external storage and de-allocates all storage in the storage model. As part of the call of <I>write-external-program-state</I> , the extraction of changes to the library state of abstract implementation modules, as defined by the operation <I>write-external- &lt; libraryname &gt; -state</I> , should be carried out. 
<P><HR>
<A NAME="0283">
<A HREF="#0280" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0282" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0284" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>The Store</H3>

<P><UL>
<LI><A HREF="#0284" TARGET=body>Storage</A>
<LI><A HREF="#0285" TARGET=body>Values</A>
</UL>
<P><HR>
<A NAME="0284">
<A HREF="#0283" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0283" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0285" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Storage</H4>

<P>annotations The invariant requires that the storage locations allocated to a coroutine are disjoint from the storage locations used by the coroutine. The operation <I>check-changes</I> requires that once storage has been allocated to a coroutine, it must not be used by the coroutine that was originally allocated the storage. Taken together, this means that an implementation <I>may</I> re-use the storage passed to a coroutine for the workspace of that coroutine. 
<P>annotations The rest component is an implementation dependent type consisting of a set of <I>Loc</I> , posssibly derived from the <I>allocated</I> component, from which storage can be allocated. 
<P><HR>
<A NAME="0285">
<A HREF="#0283" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0284" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0286" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Values</H4>

<P>annotations Strictly speaking N ? Z? R ? C , however, they are shown as separate sets for clarity. 
<P><HR>
<A NAME="0286">
<A HREF="#0280" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0285" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0287" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Exceptions</H3>

<P>annotations Each coroutine has a non-empty stack of exception contexts associated with it. The top context on the stack indicates whether the coroutine is executing in the state of normal execution, exceptional execution due to the raising of a language exception, or exceptional execution due to the raising of a user exception. The stack is initialized to indicate normal execution; a further normal execution context is pushed on the stack on the execution of a block body that has an exceptional part. If an exception is raised, the top exception context is replaced by a context that holds information about the exception. 
<P><HR>
<A NAME="0287">
<A HREF="#0280" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0286" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0288" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Interrupt Handlers</H3>

<P>annotations <I>Interrupt-source</I> is an implementation defined set of values 
<P><HR>
<A NAME="0288">
<A HREF="#0280" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0287" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0289" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Operations on Storage</H3>

<P><UL>
<LI><A HREF="#0289" TARGET=body>Operations Accessing Storage</A>
<LI><A HREF="#0290" TARGET=body>Storage Aliasing</A>
<LI><A HREF="#0292" TARGET=body>Operations to Allocate and Deallocate Storage</A>
<LI><A HREF="#0293" TARGET=body>Operations to Allocate and Deallocate Storage Locations</A>
</UL>
<P><HR>
<A NAME="0289">
<A HREF="#0288" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0288" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0290" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Operations Accessing Storage</H4>

<P>annotations Check the existence of a storage location. 
<P>annotations Access the value of a storage location associated with a variable. 
<P>annotations Change the value of a storage location. That storage location could be aliased with other storage locations caused by passing a variable using a variable parameter of a system storage formal type; this will cause an implementation defined change to these storage locations. 
<P>annotations Check that the locations denoted by the first parameter are not contained in storage that has been allocated to a coroutine. 
<P><HR>
<A NAME="0290">
<A HREF="#0288" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0289" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0291" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Storage Aliasing</H4>

<P>annotations The storage location denoted by loc is aliased with (part of ) the storage location(s) denoted by var . Thus a change to the contents of the storage location modelled by var when the value val is assigned to it may change the contents of the storage location modelled by loc | return an implementation defined value that describes any changes to the contents of the storage location loc because of the assignment. 
<P>annotations Return the set of alias pairs that could occur if two variables share storage. 
<P>annotations Update the alias information with the set of alias pairs that could occur if two variables share storage. 
<P>annotations Remove alias pairs from storage. 
<P><A NAME="0291">
<A HREF="#0290" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0290" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0292" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Aliasing Machine Addresses</H5>

<P>annotations Alias a machine address with a location. 
<P>annotations Convert a machine address to a location. The value of type Loc returned by this function must be in the domain of the machine-storage component of the state. 
<P><HR>
<A NAME="0292">
<A HREF="#0288" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0291" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0293" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Operations to Allocate and Deallocate Storage</H4>

<P>annotations An exception is raised if there is not enough storage available. 
<P>annotations Deallocate the storage associated with a set of identifiers. 
<P>annotations De-allocate the storage of the modules in the environment. 
<P>annotations Deallocate the storage associated with a set of variables. 
<P>annotations Return the set of locations associated with a variable. 
<P><HR>
<A NAME="0293">
<A HREF="#0288" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0292" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0294" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Operations to Allocate and Deallocate Storage Locations</H4>

<P>annotations Generate a new storage location (one currently not in the domain of the storage map) and set its value to undefined. The choice of storage location is non-deterministic. 
<P>annotations Return an implementation dependent set of <I>Locs</I> derived from the storage pool. 
<P>annotations Deallocate storage defined by a set of locations &mdash; return the set of storage locations (currently in the domain of the storage map) and return them to the storage pool. 
<P><HR>
<A NAME="0294">
<A HREF="#0280" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0293" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0295" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Accessing the Procedure Denotation Component of the State</H3>

<P>annotations The well-formed conditions for abstract modules require that all procedure identifiers used in the program be distinct. 
<P><HR>
<A NAME="0295">
<A HREF="#0280" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0294" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0296" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Program Initialization and Program Termination</H3>

<P><UL>
<LI><A HREF="#0296" TARGET=body>Program Initialization</A>
<LI><A HREF="#0297" TARGET=body>Program Termination</A>
<LI><A HREF="#0298" TARGET=body>Program Halting</A>
</UL>
<P><HR>
<A NAME="0296">
<A HREF="#0295" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0295" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0297" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Program Initialization</H4>

<P>annotations Set the program termination flag to signal that initialization is occurring. The main program and each coroutine will be able to enquire if it is terminating. 
<P><HR>
<A NAME="0297">
<A HREF="#0295" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0296" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0298" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Program Termination</H4>

<P>annotations Set this coroutine as terminating. 
<P>annotations Check if this coroutine is terminating. 
<P>annotations Check if any coroutine is terminating. 
<P>annotations Check if any coroutine is terminating. 
<P>annotations Check if the coroutine with the identifier cid is terminating. 
<P>annotations Return the next module finalization code if one exists, otherwise return nil . 
<P>annotations Implementation dependent housekeeping to complete execution of a program. 
<P><HR>
<A NAME="0298">
<A HREF="#0295" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0297" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0299" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Program Halting</H4>

<P>annotations Set the program termination flag to signal that termination is occuring. 
<P>annotations Check if the program is halting. 
<P><HR>
<A NAME="0299">
<A HREF="#0280" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0298" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0300" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Exception Handling</H3>

<P>annotations An exception has no exception handler &mdash; these are implementation dependent actions that are to be performed when the program is terminated exceptionally. 
<P>annotations Push an exception context. 
<P>annotations Pop an exception context. 
<P>annotations Read the current exception context. 
<P>annotations Read the current exception context. 
<P>annotations Return true iff the given exception context indicates the state of exceptional execution. 
<P>annotations Raise an exception under the current exception handler with the exception context. 
<P><UL>
<LI><A HREF="#0300" TARGET=body>Allocation of Exception Sources</A>
</UL>
<P><HR>
<A NAME="0300">
<A HREF="#0299" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0299" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0301" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Allocation of Exception Sources</H4>

<P>annotations Allocate a source, or return nil if no more <I>Exception-source</I> values are availablle. 
<P><HR>
<A NAME="0301">
<A HREF="#0280" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0300" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0302" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Interrupt Handlers</H3>

<P>annotations Attach the calling coroutine to a source of interrupts. 
<P>annotations Detach the calling coroutine from a source of interrupts. 
<P>annotations Return the identity of the currently executing coroutine. 
<P>annotations Set a handler for an interrupt. 
<P>annotations Check that the currently executing coroutine is attached to a source of interrupts. 
<P>annotations An event connected to the coroutine calling <TT>IOTRANSFER</TT> will cause the coroutine to resume at the statement following the call to <TT>IOTRANSFER</TT> and place the identity of the coroutine that was interrupted in the first argument. 
<P>annotations Return the handlers of the program from the program state. 
<P><HR>
<A NAME="0302">
<A HREF="#0280" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0301" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0303" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Accessing the Protection Component of the State</H3>

<P>annotations Read the state and return the current protection of the caller. 
<P>annotations Read the state and return true iff the parameter is less restrictive than the current protection of the caller. 
<P>annotations Add the new protection to the state. 
<P><HR>
<A NAME="0303">
<A HREF="#0280" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0302" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0304" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Coroutine and Continuations</H3>

<P><UL>
<LI><A HREF="#0304" TARGET=body>Operations on Continuations</A>
</UL>
<P><HR>
<A NAME="0304">
<A HREF="#0303" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0303" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="isom2004.html#0305" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Operations on Continuations</H4>

<P>annotations Continue with the continuation <I>cont</I> . 
<P>annotations Initialize a coroutine by adding to the coroutine environment. 
<P>annotations Resume a coroutine by saving the current execution of the coroutine that is currently being executed in the envi- ronment, and continuing the execution of the coroutine to be resumed. 
<P>annotations Allocate an unused coroutine identifier. 
<P>annotations Construct coroutine storage and add it to the state. The storage consists of an empty protection stack and the storage for the variables and control information for a coroutine. 
<P>annotations Add the storage for a coroutine to the state. 
<P>
</BODY>
</HTML>
