<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Modules</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<P><HR>
<A NAME="0043">
<A HREF="o2rep000.html#root" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="o2rep010.html#0042" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="o2rep012.html#0044" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H1>Modules</H1>

<P>A module is a collection of declarations of constants, types, variables, and procedures, together with a sequence of statements for the purpose of assigning initial values to the variables. A module constitutes a text that is compilable as a unit. <FONT SIZE=2>
<P><PRE>&nbsp;&nbsp;Module&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;MODULE&nbsp;ident&nbsp;&quot;;&quot;&nbsp;[ImportList]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeclarationSequence
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;BEGIN&nbsp;StatementSequence&nbsp;]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END&nbsp;ident&nbsp;&quot;.&quot;.
&nbsp;&nbsp;ImportList&nbsp;=&nbsp;IMPORT&nbsp;Import&nbsp;{&quot;,&quot;&nbsp;Import}&nbsp;&quot;;&quot;.
&nbsp;&nbsp;Import&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;[ident&nbsp;&quot;:=&quot;]&nbsp;ident.
</PRE>
</FONT>
<P>The import list specifies the names of the imported modules. If a module A is imported by a module M and A exports an identifier x, then x is referred to as A.x within M. If A is imported as B := A, the object x is referenced as B.x. This allows short alias names in qualified identifiers. A module must not import itself. Identifiers that are to be exported (i.e. that are to be visible in client modules) must be marked by an export mark in their declaration (see section <A HREF="o2rep004.html#0009" TARGET=body>Declarations and scope rules</A>). 
<P>The statement sequence following the symbol BEGIN is executed when the module is added to a system (loaded), which is done after the imported modules have been loaded. It follows that cyclic import of modules is illegal. Individual (parameterless and exported) procedures can be activated from the system, and these procedures serve as <I>commands</I>. <FONT SIZE=2>
<P><PRE>MODULE&nbsp;Trees;
(*&nbsp;exports:
&nbsp;&nbsp;Tree,&nbsp;Node,&nbsp;Insert,&nbsp;Search,&nbsp;Write,&nbsp;NewTree
*)
(*&nbsp;exports&nbsp;read-only:&nbsp;Node.name&nbsp;*)
IMPORT&nbsp;Texts,&nbsp;Oberon;
TYPE
&nbsp;&nbsp;Tree*&nbsp;=&nbsp;POINTER&nbsp;TO&nbsp;Node;
&nbsp;&nbsp;Node*&nbsp;=&nbsp;RECORD
&nbsp;&nbsp;&nbsp;&nbsp;name-:&nbsp;POINTER&nbsp;TO&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;left,&nbsp;right:&nbsp;Tree
&nbsp;&nbsp;END;

VAR&nbsp;w:&nbsp;Texts.Writer;

PROCEDURE&nbsp;(t:&nbsp;Tree)&nbsp;Insert*&nbsp;(name:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
&nbsp;&nbsp;VAR&nbsp;p,&nbsp;father:&nbsp;Tree;
BEGIN
&nbsp;&nbsp;p&nbsp;:=&nbsp;t;
&nbsp;&nbsp;REPEAT&nbsp;father&nbsp;:=&nbsp;p;
&nbsp;&nbsp;&nbsp;&nbsp;IF&nbsp;name&nbsp;=&nbsp;p.name^&nbsp;THEN&nbsp;RETURN&nbsp;END;
&nbsp;&nbsp;&nbsp;&nbsp;IF&nbsp;name&nbsp;&lt;&nbsp;p.name^&nbsp;THEN&nbsp;p&nbsp;:=&nbsp;p.left
&nbsp;&nbsp;&nbsp;&nbsp;ELSE&nbsp;p&nbsp;:=&nbsp;p.right
&nbsp;&nbsp;&nbsp;&nbsp;END
&nbsp;&nbsp;UNTIL&nbsp;p&nbsp;=&nbsp;NIL;
&nbsp;&nbsp;NEW(p);&nbsp;p.left&nbsp;:=&nbsp;NIL;&nbsp;p.right&nbsp;:=&nbsp;NIL;
&nbsp;&nbsp;NEW(p.name,LEN(name)+1);
&nbsp;&nbsp;COPY(name,p.name^);
&nbsp;&nbsp;IF&nbsp;name&nbsp;&lt;&nbsp;father.name^&nbsp;THEN&nbsp;father.left&nbsp;:=&nbsp;p
&nbsp;&nbsp;ELSE&nbsp;father.right&nbsp;:=&nbsp;p
&nbsp;&nbsp;END;
END&nbsp;Insert;

PROCEDURE&nbsp;(t:&nbsp;Tree)&nbsp;Search*&nbsp;(name:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR):&nbsp;Tree;
&nbsp;&nbsp;VAR&nbsp;p:&nbsp;Tree;
BEGIN
&nbsp;&nbsp;p&nbsp;:=&nbsp;t;
&nbsp;&nbsp;WHILE&nbsp;(p&nbsp;#&nbsp;NIL)&nbsp;&amp;&nbsp;(name&nbsp;#&nbsp;p.name^)&nbsp;DO
&nbsp;&nbsp;&nbsp;&nbsp;IF&nbsp;name&nbsp;=&nbsp;p.name^&nbsp;THEN&nbsp;p&nbsp;:=&nbsp;p.left
&nbsp;&nbsp;&nbsp;&nbsp;ELSE&nbsp;p&nbsp;:=&nbsp;p.right
&nbsp;&nbsp;&nbsp;&nbsp;END
&nbsp;&nbsp;END;
&nbsp;&nbsp;RETURN&nbsp;p
END&nbsp;Search;

PROCEDURE&nbsp;(t:&nbsp;Tree)&nbsp;Write*;
BEGIN
&nbsp;&nbsp;IF&nbsp;t.left&nbsp;#&nbsp;NIL&nbsp;THEN&nbsp;t.left.Write&nbsp;END;
&nbsp;&nbsp;Texts.WriteString(w,&nbsp;t.name^);
&nbsp;&nbsp;Texts.WriteLn(w);
&nbsp;&nbsp;Texts.Append(Oberon.Log,&nbsp;w.buf);
&nbsp;&nbsp;IF&nbsp;t.right&nbsp;#&nbsp;NIL&nbsp;THEN&nbsp;t.right.Write&nbsp;END
END&nbsp;Write;

PROCEDURE&nbsp;NewTree*&nbsp;():&nbsp;Tree;
&nbsp;&nbsp;VAR&nbsp;t:&nbsp;Tree;
BEGIN
&nbsp;&nbsp;NEW(t);&nbsp;NEW(t.name,&nbsp;1);
&nbsp;&nbsp;t.name[0]&nbsp;:=&nbsp;0X;
&nbsp;&nbsp;t.left&nbsp;:=&nbsp;NIL;&nbsp;t.right&nbsp;:=&nbsp;NIL;
&nbsp;&nbsp;RETURN&nbsp;t
END&nbsp;NewTree;

BEGIN
&nbsp;&nbsp;Texts.OpenWriter(w)
END&nbsp;Trees.
</PRE>

<P></FONT> 
</BODY>
</HTML>
