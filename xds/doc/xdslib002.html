<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>ISO Modula-2 standard libraries</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<P><HR>
<A NAME="0001">
<A HREF="xdslib000.html#root" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="xdslib001.html#0000" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0002" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H1>ISO Modula-2 standard libraries</H1>

<P>It is our aim to provide the full set of ISO Modula-2 libraries. However, some modules are unimplemented on a particular hardware/sortware platform. System libraries are described in the <I>XDS Modula-2</I> Chapter of the <I>XDS User&rsquo;s Guide</I>. 
<P>This chapter does not contain a complete reference. A brief description and some samples are provided for each group of modules. For more information, refer to the <I>ISO Modula-2 Library Reference</I>. 
<P><UL>
<LI><A HREF="#0002" TARGET=body>Input/output library</A>
<LI><A HREF="#0007" TARGET=body>String conversions</A>
<LI><A HREF="#0008" TARGET=body>Mathematical libraries</A>
<LI><A HREF="#0009" TARGET=body>Processes and Semaphores</A>
<LI><A HREF="#0011" TARGET=body>Other libraries</A>
</UL>
<P><HR>
<A NAME="0002">
<A HREF="#0001" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0001" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0003" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Input/output library</H2>

<P>The IO library allows one to read and write the data streams over one or more channels. Channels are connected to the source of input data, or to destination of output data, known as devices. A set of devices can be extended. 
<P>A group of modules is provided to operate on the default input and output channel (<A HREF="#0003" TARGET=body>Reading and writing via default channels</A>). Another group of modules provide facilities to operate on channels specified explicitly by a parameter (<A HREF="#0004" TARGET=body>Reading and writing data</A>). The device modules provide facilities to get a channel connected to a source (<A HREF="#0005" TARGET=body>Device modules</A>). The primitive device-independent operations are provided by the module <B>IOChan</B>; the module <B>IOLink</B> allows specialized device module to be implemented (See <A HREF="#0006" TARGET=body>Low-level IO modules</A>). 
<P><UL>
<LI><A HREF="#0003" TARGET=body>Reading and writing via default channels</A>
<LI><A HREF="#0004" TARGET=body>Reading and writing data</A>
<LI><A HREF="#0005" TARGET=body>Device modules</A>
<LI><A HREF="#0006" TARGET=body>Low-level IO modules</A>
</UL>
<P><HR>
<A NAME="0003">
<A HREF="#0002" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0002" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0004" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Reading and writing via default channels</H3>

<P>The following modules provide procedures that operate via default input and output channels and do not take a parameter which identifies a channel: 
<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;"><B>IOConsts </B></TD>
<TD  STYLE="padding:0px 3px;">Types and constants for IO modules </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>SLongIO </B></TD>
<TD  STYLE="padding:0px 3px;">LONGREAL numbers IO operations </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>SRawIO </B></TD>
<TD  STYLE="padding:0px 3px;">Raw IO operations (no conversion or interpretation) </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>SRealIO </B></TD>
<TD  STYLE="padding:0px 3px;">REAL numbers IO operations </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>SResultIO </B></TD>
<TD  STYLE="padding:0px 3px;">Read results for the default input channel </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>STextIO </B></TD>
<TD  STYLE="padding:0px 3px;">Character and string types IO operations </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>SWholeIO </B></TD>
<TD  STYLE="padding:0px 3px;">Whole numbers IO operations </TD>
</TR>
</TABLE>
<P>The module <B>STextIO</B> resembles the well-known <B>InOut</B> library. The <I>Hello, World</I> program is implemented in the following example: 
<P><PRE>MODULE&nbsp;Hello;

IMPORT&nbsp;&nbsp;STextIO;

BEGIN
&nbsp;&nbsp;STextIO.WriteString('Hello,&nbsp;World!');
&nbsp;&nbsp;STextIO.WriteLn;
END&nbsp;Hello.
</PRE>

<P>The modules <B>SWholeIO</B>, <B>SRealIO</B>, <B>SLongIO</B> provides facilities for the input and output of whole and real numbers in a decimal form using text operations on a channel. 
<P><PRE>PROCEDURE&nbsp;Print(stage:&nbsp;CARDINAL;&nbsp;val:&nbsp;REAL);
BEGIN
&nbsp;&nbsp;STextIO.WriteString(&quot;On&nbsp;stage&quot;);
&nbsp;&nbsp;SWholeIO.WriteCard(stage,0);
&nbsp;&nbsp;STextIO.WriteString(&quot;&nbsp;the&nbsp;value&nbsp;is&nbsp;equal&nbsp;to&nbsp;&quot;);
&nbsp;&nbsp;SRealIO.WriteReal(val,15);
&nbsp;&nbsp;STextIO.WriteLn;
END&nbsp;Print;
</PRE>

<P>The module <B>SIOResult</B> allows one to determine whether the last input operation from a default input channel succeed. Text operations produce or consume data streams as a sequence of characters and line marks. The text input procedures (such as <TT>ReadString</TT> never remove a line mark from the input stream. The procedure <TT>SkipLine</TT> should be used to pass a line mark. 
<P>The <TT>Copy</TT> procedure reads strings from the input channel and copies them to the output channel. 
<P><PRE>PROCEDURE&nbsp;Copy;
&nbsp;&nbsp;VAR&nbsp;s:&nbsp;ARRAY&nbsp;[0..63]&nbsp;OF&nbsp;CHAR;
BEGIN
&nbsp;&nbsp;LOOP
&nbsp;&nbsp;&nbsp;&nbsp;STextIO.ReadString(s);
&nbsp;&nbsp;&nbsp;&nbsp;CASE&nbsp;SIOResult.ReadResult()&nbsp;OF
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|SIOResult.allRight:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STextIO.WriteString(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|SIOResult.endOfLine:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STextIO.SkipLine;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STextIO.WriteLn;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|SIOResult.endOfInput:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EXIT
&nbsp;&nbsp;&nbsp;&nbsp;END;
&nbsp;&nbsp;END;
END&nbsp;Copy;
</PRE>

<P>No procedure is provided to get the result of a &lsquo;write&rsquo; operation. Device errors are reported by raising an exception (See module <B>IOChan</B>). 
<P><HR>
<A NAME="0004">
<A HREF="#0002" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0003" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0005" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Reading and writing data</H3>

<P>For all modules in this group a channel is specified by an actual parameter of the type <B>IOChan.ChanId</B>. 
<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;"><B>IOResult </B></TD>
<TD  STYLE="padding:0px 3px;">Read results for specified channels </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>LongIO </B></TD>
<TD  STYLE="padding:0px 3px;">LONGREAL numbers IO operations </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>RawIO </B></TD>
<TD  STYLE="padding:0px 3px;">Raw IO operations (no conversion or interpretation) </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>RealIO </B></TD>
<TD  STYLE="padding:0px 3px;">REAL numbers IO operations </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>TextIO </B></TD>
<TD  STYLE="padding:0px 3px;">Character and string types IO operations </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>WholeIO </B></TD>
<TD  STYLE="padding:0px 3px;">Whole numbers IO operations </TD>
</TR>
</TABLE>
<P>The following procedure copies an input channel to an output channel byte by byte: 
<P><PRE>PROCEDURE&nbsp;CopyChars(in,out:&nbsp;IOChan.ChanId);
&nbsp;&nbsp;VAR&nbsp;ch:&nbsp;CHAR;
BEGIN
&nbsp;&nbsp;LOOP
&nbsp;&nbsp;&nbsp;&nbsp;TextIO.ReadChar(in,ch);
&nbsp;&nbsp;&nbsp;&nbsp;CASE&nbsp;IOResult.ReadResult(in)&nbsp;OF
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|IOResult.allRight:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TextIO.WriteChar(out,ch);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|IOResult.endOfLine:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TextIO.SkipLine(in);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TextIO.WriteLn(out);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|IOResult.endOfInput:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EXIT
&nbsp;&nbsp;&nbsp;&nbsp;END;
&nbsp;&nbsp;END;
END&nbsp;CopyChars;
</PRE>

<P><HR>
<A NAME="0005">
<A HREF="#0002" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0004" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0006" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Device modules</H3>

<P>The device modules allows to get a channel connected to a stream, a file, program arguments and to default channels. 
<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;"><B>ChanConsts </B></TD>
<TD  STYLE="padding:0px 3px;">Common types and values for channel open </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;">&nbsp;</TD>
<TD  STYLE="padding:0px 3px;">requests and results </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>ProgramArgs </B></TD>
<TD  STYLE="padding:0px 3px;">Access to program arguments </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>RndFile </B></TD>
<TD  STYLE="padding:0px 3px;">Random access files </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>SeqFile </B></TD>
<TD  STYLE="padding:0px 3px;">Rewindable sequential files </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>StdChans </B></TD>
<TD  STYLE="padding:0px 3px;">Access to standard and default channels </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>StreamFile </B></TD>
<TD  STYLE="padding:0px 3px;">Independent sequential data streams </TD>
</TR>
</TABLE>
<P>In the following example a channel connected to a rewindable file is opened: 
<P><PRE>MODULE&nbsp;Example;

IMPORT&nbsp;&nbsp;SeqFile,&nbsp;STextIO,&nbsp;TextIO;

CONST&nbsp;flags&nbsp;=&nbsp;SeqFile.text&nbsp;+&nbsp;SeqFile.old;

VAR
&nbsp;&nbsp;cid:&nbsp;SeqFile.ChanId;
&nbsp;&nbsp;res:&nbsp;SeqFile.OpenResults;
&nbsp;&nbsp;i&nbsp;&nbsp;:&nbsp;CARDINAL;

BEGIN
&nbsp;&nbsp;SeqFile.OpenWrite(cid,&quot;example.dat&quot;,flags,res);
&nbsp;&nbsp;IF&nbsp;res&nbsp;=&nbsp;SeqFile.opened&nbsp;THEN
&nbsp;&nbsp;&nbsp;&nbsp;FOR&nbsp;i:=0&nbsp;TO&nbsp;9&nbsp;DO
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TextIO.WriteString(cid,&quot;Hello&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TextIO.WriteLn(cid);
&nbsp;&nbsp;&nbsp;&nbsp;END;
&nbsp;&nbsp;&nbsp;&nbsp;SeqFile.Close(cid);
&nbsp;&nbsp;ELSE
&nbsp;&nbsp;&nbsp;&nbsp;STextIO.WriteString(&quot;Open&nbsp;error&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;STextIO.WriteLn;
&nbsp;&nbsp;END;
END&nbsp;Example.
</PRE>

<P>The module <B>StdChans</B> allows one to get channels already open to sources and destinations of standard input, standard output and standard error output. Default channels initially corresponds to the standard channels, but their values may be changed to redirect input or output. 
<P><PRE>PROCEDURE&nbsp;RedirectOutput(cid:&nbsp;StdChans.ChanId);
BEGIN
(*&nbsp;writing&nbsp;to&nbsp;the&nbsp;current&nbsp;default&nbsp;channel:&nbsp;*)
&nbsp;&nbsp;STextIO.WriteString(&quot;Redirecting&nbsp;output...&quot;);
&nbsp;&nbsp;STextIO.WriteLn;
(*&nbsp;redirecting&nbsp;output:&nbsp;*)
&nbsp;&nbsp;StdChans.SetOutChan(cid);
END&nbsp;RedirectOutput;
</PRE>

<P>After the call of <TT>RedirectOutput(cid)</TT> all subsequent output via modules <B>STextIO</B>, <B>SWholeIO</B>, etc will be written to the channel <TT>cid</TT>. To restore output call 
<P><PRE>&nbsp;&nbsp;StdChans.SetOutChan(StdChans.StdOutChan());
</PRE>

<P>The module <B>ProgramArgs</B> provides a channel to access program&rsquo;s arguments. The following program prints all its arguments. 
<P><PRE>MODULE&nbsp;Args;

IMPORT&nbsp;ProgramArgs,&nbsp;TextIO,&nbsp;STextIO;

VAR
&nbsp;&nbsp;str:&nbsp;ARRAY&nbsp;[0..255]&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;cid:&nbsp;ProgramArgs.ChanId;

BEGIN
&nbsp;&nbsp;cid:=ProgramArgs.ArgChan();
&nbsp;&nbsp;WHILE&nbsp;ProgramArgs.IsArgPresent()&nbsp;DO
&nbsp;&nbsp;&nbsp;&nbsp;TextIO.ReadToken(cid,str);
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Note:&nbsp;read&nbsp;result&nbsp;test&nbsp;is&nbsp;omitted&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;STextIO.WriteString(str);&nbsp;STextIO.WriteLn;
&nbsp;&nbsp;END;
END&nbsp;Args.
</PRE>

<P><HR>
<A NAME="0006">
<A HREF="#0002" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0005" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0007" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>Low-level IO modules</H3>

<P>Two low-level modules are described in this section. The module <B>IOChan</B> defines the type <TT>ChanId</TT> that is used to identify channels and provides a set of procedures forming the channel&rsquo;s interface in a device-independent manner. 
<P>The module <B>IOLink</B> provides facilities that allow one to define new device modules. Let us implement an encryption channel, i.e. a channel that encrypts all information that is written to it. To make the encryption device-independent we need a channel for input/output operations. 
<P>In the following example a sketch of the encryption device module is shown. 
<P><PRE>DEFINITION&nbsp;MODULE&nbsp;EncryptChan;

IMPORT&nbsp;IOChan,&nbsp;ChanConsts;

TYPE
&nbsp;&nbsp;ChanId&nbsp;=&nbsp;IOChan.ChanId;
&nbsp;&nbsp;OpenResults&nbsp;=&nbsp;ChanConsts.OpenResults;

PROCEDURE&nbsp;Connect(VAR&nbsp;cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;io:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;res:&nbsp;OpenResults);
(*&nbsp;Attempts&nbsp;to&nbsp;open&nbsp;an&nbsp;encryption&nbsp;channel.&nbsp;All&nbsp;I/O
&nbsp;&nbsp;&nbsp;operations&nbsp;will&nbsp;be&nbsp;made&nbsp;through&nbsp;&quot;io&quot;&nbsp;channel.
*)

PROCEDURE&nbsp;Close(VAR&nbsp;cid:&nbsp;ChanId);
(*&nbsp;Closes&nbsp;the&nbsp;channel.&nbsp;*)

END&nbsp;EncryptChan.
</PRE>

<P>Values of the type <TT>DeviceId</TT> are used to identify device modules. By calling the procedure <TT>DeviceTablePtrValue</TT>, a device module can obtain a pointer to a device table for the channel. Each channel has it own copy of a device table. A device table contains a field in which the device module can store private data. In our example, the <TT>io</TT> channel will be stored in this field. The device table also serves as a method table (or virtual function table) in object-oriented languages. It contains the procedure variables for each device procedure. All fields are initialized by the call of <TT>MakeChan</TT> procedure. A device module has to assign its own device procedures to the fields of a device table. See the <TT>Connect</TT> procedure below. 
<P><PRE>IMPLEMENTATION&nbsp;MODULE&nbsp;EncryptChan;

IMPORT&nbsp;IOChan,&nbsp;IOLink,&nbsp;ChanConsts,&nbsp;SYSTEM;

(*&nbsp;&quot;did&quot;&nbsp;is&nbsp;used&nbsp;to&nbsp;identify&nbsp;the&nbsp;channel's&nbsp;kind:&nbsp;*)
VAR&nbsp;did:&nbsp;IOLink.DeviceId;

PROCEDURE&nbsp;EncryptChar(from:&nbsp;SYSTEM.ADDRESS;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;ch:&nbsp;CHAR);
BEGIN
&nbsp;&nbsp;ch:='a';&nbsp;(*&nbsp;very&nbsp;simple&nbsp;encryption&nbsp;:-)&nbsp;*)
END&nbsp;EncryptChar;

PROCEDURE&nbsp;TextWrite(x:&nbsp;IOLink.DeviceTablePtr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from:&nbsp;SYSTEM.ADDRESS;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len:&nbsp;CARDINAL);
&nbsp;&nbsp;VAR&nbsp;i:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ch:&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;cid:&nbsp;IOChan.ChanId;
BEGIN
&nbsp;&nbsp;(*&nbsp;get&nbsp;the&nbsp;channel&nbsp;id&nbsp;*)
&nbsp;&nbsp;cid:=SYSTEM.CAST(IOChan.ChanId,x^.cd);
&nbsp;&nbsp;FOR&nbsp;i:=0&nbsp;TO&nbsp;len-1&nbsp;DO
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;encrypt&nbsp;i-th&nbsp;character&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;EncryptChar(from,i,ch);
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;write&nbsp;an&nbsp;encrypted&nbsp;character&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;IOChan.TextWrite(cid,SYSTEM.ADR(ch),1);
&nbsp;&nbsp;END;
END&nbsp;TextWrite;

PROCEDURE&nbsp;Connect(VAR&nbsp;cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;io:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;res:&nbsp;OpenResults);
&nbsp;&nbsp;VAR&nbsp;x:&nbsp;IOLink.DeviceTablePtr;
BEGIN
&nbsp;&nbsp;IOLink.MakeChan(did,cid);
&nbsp;&nbsp;IF&nbsp;cid&nbsp;=&nbsp;IOChan.InvalidChan()&nbsp;THEN
&nbsp;&nbsp;&nbsp;&nbsp;res:=ChanConsts.outOfChans
&nbsp;&nbsp;ELSE
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;get&nbsp;a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;device&nbsp;table&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;x:=IOLink.DeviceTablePtrValue(cid,did,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IOChan.notAvailable,&quot;&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;store&nbsp;the&nbsp;channel&nbsp;id&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;x^.cd:=SYSTEM.CAST(SYSTEM.ADDRESS,io);
&nbsp;&nbsp;&nbsp;&nbsp;x^.doTextWrite:=TextWrite;
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;...&nbsp;*)
&nbsp;&nbsp;END;
END&nbsp;Connect;

PROCEDURE&nbsp;Close(VAR&nbsp;cid:&nbsp;ChanId);
BEGIN
&nbsp;&nbsp;IOLink.UnMakeChan(did,cid);
END&nbsp;Close;

BEGIN
&nbsp;&nbsp;IOLink.AllocateDeviceId(did);
END&nbsp;EncryptChan.
</PRE>

<P>The module <B>EncryptChan</B> can be used as any standard device module. 
<P><HR>
<A NAME="0007">
<A HREF="#0001" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0006" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0008" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>String conversions</H2>

<P>The string conversion library admits the conversion of the values of numeric data types to and from the character string representation. It contains the following modules: 
<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;"><B>ConvTypes </B></TD>
<TD  STYLE="padding:0px 3px;">Common types used in the string conversion modules</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>LongConv </B></TD>
<TD  STYLE="padding:0px 3px;">Low-level LONGREAL/string conversions </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>LongStr </B></TD>
<TD  STYLE="padding:0px 3px;">LONGREAL/string conversions </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>RealConv </B></TD>
<TD  STYLE="padding:0px 3px;">Low-level REAL/string conversions </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>RealStr </B></TD>
<TD  STYLE="padding:0px 3px;">REAL/string conversions </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>WholeConv </B></TD>
<TD  STYLE="padding:0px 3px;">Low-level whole number/string conversions </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>WholeStr </B></TD>
<TD  STYLE="padding:0px 3px;">Whole number/string conversions </TD>
</TR>
</TABLE>
<P>The module <B>ConvTypes</B> defines the enumeration type <TT>ConvResults</TT>. It also defines the types <TT>ScanClass</TT> and <TT>ScanState</TT> to use in the low-level conversion modules. 
<P>The low-level conversion modules allow to control lexical scanning of character sequences. For example, the <B>WholeConv</B> module implements procedures <TT>ScanInt</TT> and <TT>ScanCard</TT> representing the start state for a finite state scanner for signed and unsigned whole numbers. In the following example the procedure <TT>ScanInt</TT> is used to locate a position of the first character in a string which is not a part of an integer. 
<P><PRE>PROCEDURE&nbsp;SkipInt(str:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;pos:&nbsp;CARDINAL);
&nbsp;&nbsp;VAR&nbsp;len:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;state:&nbsp;ConvTypes.ConvState;
&nbsp;&nbsp;&nbsp;&nbsp;class:&nbsp;ConvTypes.ConvClass;
BEGIN
&nbsp;&nbsp;pos:=0;&nbsp;len:=LENGTH(str);
&nbsp;&nbsp;state:=WholeConv.ScanInt;
&nbsp;&nbsp;WHILE&nbsp;pos&nbsp;&lt;&nbsp;len&nbsp;DO
&nbsp;&nbsp;&nbsp;&nbsp;state(str[pos],class,state);
&nbsp;&nbsp;&nbsp;&nbsp;IF&nbsp;&nbsp;&nbsp;(class&nbsp;=&nbsp;WholeConv.invalid)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OR&nbsp;(class&nbsp;=&nbsp;WholeConv.terminator)
&nbsp;&nbsp;&nbsp;&nbsp;THEN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RETURN
&nbsp;&nbsp;&nbsp;&nbsp;END;
&nbsp;&nbsp;&nbsp;&nbsp;INC(pos);
&nbsp;&nbsp;END;
END&nbsp;SkipInt;
</PRE>

<P><HR>
<A NAME="0008">
<A HREF="#0001" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0007" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0009" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Mathematical libraries</H2>

<P>The following modules constitute a mathematical library: 
<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;"><B>ComplexMath </B></TD>
<TD  STYLE="padding:0px 3px;"><TT>COMPLEX</TT> mathematical functions </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>LongComplexMath </B></TD>
<TD  STYLE="padding:0px 3px;"><TT>LONGCOMPLEX</TT> mathematical functions </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>LongMath </B></TD>
<TD  STYLE="padding:0px 3px;"><TT>LONGREAL</TT> mathematical functions </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>RealMath </B></TD>
<TD  STYLE="padding:0px 3px;"><TT>REAL</TT> mathematical functions </TD>
</TR>
</TABLE>
<P><HR>
<A NAME="0009">
<A HREF="#0001" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0008" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0010" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Processes and Semaphores</H2>

<P>The following modules allows concurrent algorithms to be expressed using processes: 
<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;"><B>Processes </B></TD>
<TD  STYLE="padding:0px 3px;">Provides process creation and manipulation facilities. </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>Semaphores </B></TD>
<TD  STYLE="padding:0px 3px;">Provides mutual exclusion facilities for use by processes. </TD>
</TR>
</TABLE>
<P><A NAME="0010">
<A HREF="#0006" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0009" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0011" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Example</H5>

<P><PRE>MODULE&nbsp;Test;

IMPORT&nbsp;Processes,&nbsp;Semaphores,&nbsp;STextIO;

VAR
&nbsp;&nbsp;sig&nbsp;:&nbsp;Semaphores.SEMAPHORE;
&nbsp;&nbsp;prs&nbsp;:&nbsp;Processes.ProcessId;
&nbsp;&nbsp;main:&nbsp;Processes.ProcessId;

PROCEDURE&nbsp;Proc;
BEGIN
&nbsp;&nbsp;STextIO.WriteString('Proc&nbsp;1');&nbsp;STextIO.WriteLn;
&nbsp;&nbsp;Semaphores.Claim(sig);&nbsp;(*&nbsp;suspend&nbsp;until&nbsp;released&nbsp;*)
&nbsp;&nbsp;STextIO.WriteString('Proc&nbsp;2');&nbsp;STextIO.WriteLn;
&nbsp;&nbsp;Processes.StopMe;
END&nbsp;Proc;

BEGIN
&nbsp;&nbsp;STextIO.WriteString('Main&nbsp;1');&nbsp;STextIO.WriteLn;
&nbsp;&nbsp;Semaphores.Create(sig,0);
&nbsp;&nbsp;main:=Processes.Me();
&nbsp;&nbsp;Processes.Start(Proc,40000,Processes.UrgencyOf(main)+1,NIL,prs);
&nbsp;&nbsp;STextIO.WriteString('Main&nbsp;2');&nbsp;STextIO.WriteLn;
&nbsp;&nbsp;Semaphores.Release(sig);
&nbsp;&nbsp;STextIO.WriteString('Main&nbsp;3');&nbsp;STextIO.WriteLn;
&nbsp;&nbsp;Processes.StopMe;
END&nbsp;Test.
</PRE>

<P><HR>
<A NAME="0011">
<A HREF="#0001" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0010" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="xdslib003.html#0012" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Other libraries</H2>

<P>In this section we list the ISO modules that do not belong to any of the above groups: 
<P><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;"><B>CharClass </B></TD>
<TD  STYLE="padding:0px 3px;">provides predicates to test a value of a character type </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>Storage </B></TD>
<TD  STYLE="padding:0px 3px;">Facilities for allocating and deallocating storage </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>Strings </B></TD>
<TD  STYLE="padding:0px 3px;">Facilities for string manipulation </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><B>SysClock </B></TD>
<TD  STYLE="padding:0px 3px;">Access to a system clock </TD>
</TR>
</TABLE>
<P>
</BODY>
</HTML>
