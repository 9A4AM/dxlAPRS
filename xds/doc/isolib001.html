<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Input/Output</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<P><HR>
<A NAME="0000">
<A HREF="isolib000.html#root" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<IMG ALT="   " SRC="empty.gif" BORDER=0>
<A HREF="#0001" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H1>Input/Output</H1>
 
<P>The input/output library defined in this chapter provides facilities for reading and writing of data streams over one or more <I>channels</I>. Channels are connected to sources of input data, or to destinations of output data, known as <I>devices</I> or <I>device instances</I>. There is a separation between modules that are concerned with device-independent operations, such as reading and writing, and modules concerned with device-dependent operations, such as making connections to named files. This separation allows the library to be extended to work with new devices. The module structure of the library is depicted in the following figure. 
<P><B>The figure will be available in the final release</B> 
<P>Channels already open to standard sources and destinations can be identified using procedures provided by the module <TT><A HREF="#0002" TARGET=body>StdChans</A></TT>. This module also provides for the identification and selection of channels used by default for input and output operations. 
<P>The modules <TT><A HREF="#0015" TARGET=body>TextIO</A></TT>, <TT><A HREF="#0024" TARGET=body>WholeIO</A></TT>, <TT><A HREF="#0029" TARGET=body>RealIO</A></TT>, and <TT><A HREF="#0029" TARGET=body>LongIO</A></TT>, provide facilities that allow the reading and writing of high-level units of data, using <I>text operations</I> on channels specified explicitly by a parameter. These high-level units include characters, strings, and whole numbers and real numbers in decimal notation. The module <TT><A HREF="#0035" TARGET=body>RawIO</A></TT> provides facilities for reading and writing of arbitrary data types, using <I>raw (binary) operations</I> on explicitly specified channels. 
<P>Text operations produce or consume data streams as sequences of characters and line marks. Raw operations produce or consume data streams as sequences of storage locations (i.e. as arrays whose component type is <TT>SYSTEM.LOC</TT>). 
<P>The library allows devices to support both text and raw operations on a single channel, although this behaviour is not required. 
<P>The module <TT><A HREF="#0040" TARGET=body>IOResult</A></TT> provides the facility for a program to determine whether the last operation to read data from a specified input channel found data in the required format. 
<P>Corresponding to the <TT><A HREF="#0015" TARGET=body>TextIO</A></TT> group of modules is a group of modules <TT><A HREF="#0015" TARGET=body>STextIO</A></TT>, <TT><A HREF="#0024" TARGET=body>SWholeIO</A></TT>, <TT><A HREF="#0029" TARGET=body>SRealIO</A></TT>, <TT><A HREF="#0029" TARGET=body>SLongIO</A></TT>, <TT><A HREF="#0035" TARGET=body>SRawIO</A></TT> and <TT><A HREF="#0040" TARGET=body>SIOResult</A></TT>. The prefix <TT>&quot;S&quot;</TT> serves as an abbreviation for <TT>&quot;Simple&quot;</TT>. The procedures exported from this group do not take parameters identifying a channel. They operate on the default input and output channels, as identified by the module <TT><A HREF="#0002" TARGET=body>StdChans</A></TT>. 
<P>The module <TT><A HREF="#0038" TARGET=body>IOConsts</A></TT> defines types and constants used by <TT><A HREF="#0040" TARGET=body>IOResult</A></TT> and <TT><A HREF="#0040" TARGET=body>SIOResult</A></TT>. 
<P>The device modules <TT><A HREF="#0078" TARGET=body>StreamFile</A></TT>, <TT><A HREF="#0082" TARGET=body>SeqFile</A></TT>, <TT><A HREF="#0090" TARGET=body>RndFile</A></TT>, and <TT><A HREF="#0101" TARGET=body>TermFile</A></TT> provide facilities that allow a channel to be opened to a named stream, to a rewindable sequential file, to a random access file, or to a terminal device respectively. The device module <TT><A HREF="#0105" TARGET=body>ProgramArgs</A></TT> provides an open channel from which program arguments may be read. Device specific operations, such as positioning within a random access file, are also defined by the appropriate device module. 
<P>The module <TT><A HREF="#0073" TARGET=body>ChanConsts</A></TT> defines the constants and types used in those device module procedures that open channels. 
<P>The primitive device-independent operations on channels are provided by the module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>. 
<P>The module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT> defines general input/output library exception values that may be raised when using any device through a channel. Device errors, such as a hardware read/write error, are reported by raising one of the general exception values, and providing an implementation-defined error number. Exception values associated with device- specific operations are defined by the appropriate device module. 
<P>The module <TT><A HREF="#0110" TARGET=body>IOLink</A></TT> provides facilities that allow a user to provide further specialized device modules for use with channels, following the pattern of the rest of the library. 
<P><B>NOTE:</B> 
<P>Partial implementations of the input/output library may provide modules selected exclusively from the group <TT><A HREF="#0015" TARGET=body>STextIO</A></TT>, <TT><A HREF="#0024" TARGET=body>SWholeIO</A></TT>, <TT><A HREF="#0029" TARGET=body>SRealIO</A></TT>, and <TT><A HREF="#0029" TARGET=body>SLongIO</A></TT>, normally with <TT><A HREF="#0040" TARGET=body>SIOResult</A></TT> and <TT><A HREF="#0038" TARGET=body>IOConsts</A></TT>. If any other module is provided, the module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT> must also be provided, in accordance with the import dependencies between the definition modules of the library. 
<P><UL>
<LI><A HREF="#0001" TARGET=body>Standard and Default Channels</A>
<LI><A HREF="#0014" TARGET=body>Reading and Writing of Data</A>
<LI><A HREF="#0043" TARGET=body>Device-Independent Channel Operations</A>
<LI><A HREF="#0072" TARGET=body>Obtaining Channels from Device Modules</A>
<LI><A HREF="#0109" TARGET=body>Interface to Channels for New Device Modules</A>
</UL>
<P><HR>
<A NAME="0001">
<A HREF="#0000" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0000" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0002" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Standard and Default Channels</H2>

<P><I>Standard channels</I> do not have to be opened by a client program since they are already open and ready for use. Under some operating systems they may be connected to sources and destinations specified before the program is run, while on a stand-alone system they may be connected to a console terminal. 
<P>No method is provided for closing a standard channel, and the values used to identify standard channels are constant throughout the execution of the program. 
<P><I>Default channels</I> are channels whose identities have been stored as those to be used by default for input and output operations. Initially these correspond to the standard channels, but their values may be varied to obtain the effect of redirection. 
<P><UL>
<LI><A HREF="#0002" TARGET=body>Module StdChans</A>
</UL>
<P><HR>
<A NAME="0002"><A NAME="ChanID">
<A HREF="#0001" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0001" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0003" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Module StdChans</H3>

<P>The module <TT>StdChans</TT> defines functions that identify channels already open to implementation-defined sources and destinations of standard input, standard output, and standard error output. Access to a &lsquo;null device&rsquo; is provided to allow unwanted output to be suppressed. The null device throws away all data written to it, and gives an immediate end of input indication on reading. 
<P>The module <TT>StdChans</TT> provides procedures for identification and selection of the channels used by default for input and output operations. 
<P><UL>
<LI><A HREF="#0003" TARGET=body>ChanID - Channel identity</A>
<LI><A HREF="#0004" TARGET=body>StdInChan - Get standard input channel id</A>
<LI><A HREF="#0005" TARGET=body>StdOutChan - Get standard output channel id</A>
<LI><A HREF="#0006" TARGET=body>StdErrChan - Get standard error channel id</A>
<LI><A HREF="#0007" TARGET=body>NullChan - Get null device channel id</A>
<LI><A HREF="#0008" TARGET=body>InChan - Get current default input channel id</A>
<LI><A HREF="#0009" TARGET=body>OutChan - Get current default output channel id</A>
<LI><A HREF="#0010" TARGET=body>ErrChan - Get current default error channel id</A>
<LI><A HREF="#0011" TARGET=body>SetInChan - Set current default input channel</A>
<LI><A HREF="#0012" TARGET=body>SetOutChan - Set current default output channel</A>
<LI><A HREF="#0013" TARGET=body>SetErrChan - Set current default output channel</A>
</UL>
<P><HR>
<A NAME="0003"><A NAME="StdInChan">
<A HREF="#0002" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0002" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0004" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>ChanID - Channel identity</H4>
 
<P><PRE>TYPE
&nbsp;&nbsp;ChanId&nbsp;=&nbsp;IOChan.ChanId;
</PRE>

<P>Module <TT><A HREF="#0002" TARGET=body>StdChans</A></TT>
<P>The type <TT><A HREF="#0045" TARGET=body>IOChan.ChanId</A></TT> which is used to identify channels is reexported. 
<P><HR>
<A NAME="0004"><A NAME="StdOutChan">
<A HREF="#0002" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0003" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0005" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>StdInChan - Get standard input channel id</H4>
 
<P><PRE>PROCEDURE&nbsp;StdInChan&nbsp;():&nbsp;ChanId;
</PRE>

<P>Module <TT><A HREF="#0002" TARGET=body>StdChans</A></TT>
<P>The function procedure <TT>StdInChan</TT> returns a value identifying a channel open to the implementation-defined standard source for program input. 
<P><HR>
<A NAME="0005"><A NAME="StdErrChan">
<A HREF="#0002" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0004" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0006" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>StdOutChan - Get standard output channel id</H4>
 
<P><PRE>PROCEDURE&nbsp;StdOutChan&nbsp;():&nbsp;ChanId;
</PRE>

<P>Module <TT><A HREF="#0002" TARGET=body>StdChans</A></TT>
<P>The function procedure <TT>StdOutChan</TT> returns a value identifying a channel open to the implementation-defined standard destination for program output. 
<P><HR>
<A NAME="0006"><A NAME="NullChan">
<A HREF="#0002" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0005" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0007" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>StdErrChan - Get standard error channel id</H4>
 
<P><PRE>PROCEDURE&nbsp;StdErrChan&nbsp;():&nbsp;ChanId;
</PRE>

<P>Module <TT><A HREF="#0002" TARGET=body>StdChans</A></TT>
<P>The function procedure <TT>StdErrChan</TT> returns a value identifying a channel open to the implementation-defined standard destination for program error messages. 
<P><HR>
<A NAME="0007"><A NAME="InChan">
<A HREF="#0002" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0006" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0008" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>NullChan - Get null device channel id</H4>
 
<P><PRE>PROCEDURE&nbsp;NullChan&nbsp;():&nbsp;ChanId;
</PRE>

<P>Module <TT><A HREF="#0002" TARGET=body>StdChans</A></TT>
<P>The function procedure <TT>NullChan</TT> returns a value identifying a channel open to the null device. 
<P><B>NOTE:</B> 
<P>The null device supports all operations by discarding all data written to it, or by giving an immediate end of input indication on reading. 
<P><HR>
<A NAME="0008"><A NAME="OutChan">
<A HREF="#0002" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0007" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0009" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>InChan - Get current default input channel id</H4>
 
<P><PRE>PROCEDURE&nbsp;InChan&nbsp;():&nbsp;ChanId;
</PRE>

<P>Module <TT><A HREF="#0002" TARGET=body>StdChans</A></TT>
<P>The function procedure <TT>InChan</TT> returns the identity of the current default input channel. This is the channel used by input procedures that do not take a channel parameter. Initially this is the value returned by <TT><A HREF="#0004" TARGET=body>StdInChan</A></TT>. 
<P><HR>
<A NAME="0009"><A NAME="ErrChan">
<A HREF="#0002" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0008" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0010" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>OutChan - Get current default output channel id</H4>
 
<P><PRE>PROCEDURE&nbsp;OutChan&nbsp;():&nbsp;ChanId;
</PRE>

<P>Module <TT><A HREF="#0002" TARGET=body>StdChans</A></TT>
<P>The function procedure <TT>OutChan</TT> returns the identity of the current default output channel. This is the channel used by output procedures that do not take a channel parameter. Initially this is the value returned by <TT><A HREF="#0005" TARGET=body>StdOutChan</A></TT>. 
<P><HR>
<A NAME="0010"><A NAME="SetInChan">
<A HREF="#0002" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0009" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0011" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>ErrChan - Get current default error channel id</H4>
 
<P><PRE>PROCEDURE&nbsp;ErrChan&nbsp;():&nbsp;ChanId;
</PRE>

<P>Module <TT><A HREF="#0002" TARGET=body>StdChans</A></TT>
<P>The function procedure <TT>ErrChan</TT> returns the identity of the current default output channel for program error messages. Initially this is the value returned by <TT><A HREF="#0006" TARGET=body>StdErrChan</A></TT>. 
<P><HR>
<A NAME="0011"><A NAME="SetOutChan">
<A HREF="#0002" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0010" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0012" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>SetInChan - Set current default input channel</H4>
 
<P><PRE>PROCEDURE&nbsp;SetInChan&nbsp;(cid:&nbsp;ChanId);
</PRE>

<P>Module <TT><A HREF="#0002" TARGET=body>StdChans</A></TT>
<P>The procedure <TT>SetInChan</TT> sets the current default input channel to that identified by <TT>cid</TT>. 
<P><HR>
<A NAME="0012"><A NAME="SetErrChan">
<A HREF="#0002" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0011" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0013" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>SetOutChan - Set current default output channel</H4>
 
<P><PRE>PROCEDURE&nbsp;SetOutChan&nbsp;(cid:&nbsp;ChanId);
</PRE>

<P>Module <TT><A HREF="#0002" TARGET=body>StdChans</A></TT>
<P>The procedure <TT>SetOutChan</TT> sets the current default output channel to that identified by <TT>cid</TT>. 
<P><HR>
<A NAME="0013">
<A HREF="#0002" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0012" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0014" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>SetErrChan - Set current default output channel</H4>
 
<P><PRE>PROCEDURE&nbsp;SetErrChan&nbsp;(cid:&nbsp;ChanId);
</PRE>

<P>Module <TT><A HREF="#0002" TARGET=body>StdChans</A></TT>
<P>The procedure <TT>SetErrChan</TT> sets the current default output channel for error messages to that identified by <TT>cid</TT>. 
<P><HR>
<A NAME="0014">
<A HREF="#0000" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0013" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0015" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Reading and Writing of Data</H2>

<P>The module <TT><A HREF="#0015" TARGET=body>TextIO</A></TT> provides facilities for input and output of characters, character strings, and line marks, using text operations. 
<P>The module <TT><A HREF="#0024" TARGET=body>WholeIO</A></TT> provides facilities for input and output of whole numbers in decimal text form. 
<P>The modules <TT><A HREF="#0029" TARGET=body>RealIO</A></TT> and <TT><A HREF="#0029" TARGET=body>LongIO</A></TT> provide facilities for input and output of real numbers in decimal text form. 
<P>The module <TT><A HREF="#0035" TARGET=body>RawIO</A></TT> provides facilities for direct input and output of data, using raw operations (i.e. without any interpretation). 
<P>The input procedures of the modules <TT><A HREF="#0015" TARGET=body>TextIO</A></TT>, <TT><A HREF="#0024" TARGET=body>WholeIO</A></TT>, <TT><A HREF="#0029" TARGET=body>RealIO</A></TT>, <TT><A HREF="#0029" TARGET=body>LongIO</A></TT>, and <TT><A HREF="#0035" TARGET=body>RawIO</A></TT> are sufficient for use where the format of the input data is known. Since, in practice, their use may be inconsistent with the format of the input data, they have the effect of setting a <I>&lsquo;read result&rsquo;</I> for the used channel. The module <TT><A HREF="#0040" TARGET=body>IOResult</A></TT> provides the facility for obtaining the read result applicable to the most recent input operation on a given channel. 
<P>In all cases, channels are selected explicitly by passing an actual parameter of the type <TT>ChanId</TT> to the procedures of these modules. 
<P>The modules <TT><A HREF="#0015" TARGET=body>STextIO</A></TT>, <TT><A HREF="#0024" TARGET=body>SWholeIO</A></TT>, <TT><A HREF="#0029" TARGET=body>SRealIO</A></TT>, <TT><A HREF="#0029" TARGET=body>SLongIO</A></TT>, <TT><A HREF="#0035" TARGET=body>SRawIO</A></TT>, and <TT><A HREF="#0040" TARGET=body>SIOResult</A></TT> provide the set of similar procedures set that operate over default input and output channels, and so do not take a parameter identifying a channel. 
<P><UL>
<LI><A HREF="#0015" TARGET=body>Modules TextIO and STextIO</A>
<LI><A HREF="#0024" TARGET=body>Modules WholeIO and SWholeIO</A>
<LI><A HREF="#0029" TARGET=body>Modules RealIO, SRealIO, LongIO, and SLongIO</A>
<LI><A HREF="#0035" TARGET=body>Modules RawIO and SRawIO</A>
<LI><A HREF="#0038" TARGET=body>Module IOConsts</A>
<LI><A HREF="#0040" TARGET=body>Modules IOResult and SIOResult</A>
</UL>
<P><HR>
<A NAME="0015"><A NAME="ReadChar">
<A HREF="#0014" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0014" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0016" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Modules TextIO and STextIO</H3>

<P>The module <TT>TextIO</TT> provides facilities for input and output of characters, character strings, and line marks, using text operations. 
<P>The procedures of the module <TT>STextIO</TT> behave as the corresponding procedures of the module <TT>TextIO</TT>, except that input is taken from the default input channel, and output is sent to the default output channel. 
<P><UL>
<LI><A HREF="#0016" TARGET=body>ReadChar - Read a character</A>
<LI><A HREF="#0017" TARGET=body>ReadRestLine - Read rest of line</A>
<LI><A HREF="#0018" TARGET=body>ReadString - Read a string</A>
<LI><A HREF="#0019" TARGET=body>ReadToken - Read a space-delimited token</A>
<LI><A HREF="#0020" TARGET=body>SkipLine - Skip rest of input line</A>
<LI><A HREF="#0021" TARGET=body>WriteChar - Write a character</A>
<LI><A HREF="#0022" TARGET=body>WriteLn - Write a line mark</A>
<LI><A HREF="#0023" TARGET=body>WriteString - Write a string</A>
</UL>
<P><HR>
<A NAME="0016"><A NAME="ReadRestLine">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0015" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0017" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>ReadChar - Read a character</H4>
 
<P><PRE>PROCEDURE&nbsp;ReadChar&nbsp;(cid:&nbsp;IOChan.ChanId;&nbsp;VAR&nbsp;ch:&nbsp;CHAR);
PROCEDURE&nbsp;ReadChar&nbsp;(VAR&nbsp;ch:&nbsp;CHAR);
</PRE>

<P>Modules: <TT><A HREF="#0015" TARGET=body>TextIO</A></TT>, <TT><A HREF="#0015" TARGET=body>STextIO</A></TT>
<P>If there is a character next in the input stream identified by <TT>cid</TT>, the procedure <TT>ReadChar</TT> removes it from the stream and assigns its value to <TT>ch</TT>; otherwise the value of <TT>ch</TT> is not defined. The read result for the channel is set to the value 
<DL>
 
<DT><TT>allRight</TT></DT>
<DD>if a character is read; </DD>
<DT><TT>endOfLine</TT></DT>
<DD>if no character is read, the next item being a line mark; </DD>
<DT><TT>endOfInput</TT></DT>
<DD>if no character is read, the input stream having ended. </DD>
</DL>

<P><HR>
<A NAME="0017"><A NAME="ReadString">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0016" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0018" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>ReadRestLine - Read rest of line</H4>
 
<P><PRE>PROCEDURE&nbsp;ReadRestLine&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;s:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
PROCEDURE&nbsp;ReadRestLine&nbsp;(VAR&nbsp;s:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
</PRE>

<P>Modules: <TT><A HREF="#0015" TARGET=body>TextIO</A></TT>, <TT><A HREF="#0015" TARGET=body>STextIO</A></TT>
<P>If there is a character next in the input stream identified by <TT>cid</TT>, the procedure <TT>ReadRestLine</TT> reads a string of characters; reading continues as long as there are still characters before the next line mark or the end of the stream. As much of the string as can be accommodated is copied to <TT>s</TT> as a string value. The read result for the channel is set to the value 
<DL>
 
<DT><TT>allRight</TT></DT>
<DD>if <TT>s</TT> is not empty and accomodates all of the string that has been read; </DD>
<DT><TT>outOfRange</TT></DT>
<DD>if <TT>s</TT> is not empty but does not accommodate all of the string; </DD>
<DT><TT>endOfLine</TT></DT>
<DD>if <TT>s</TT> is empty, the next item being a line mark; </DD>
<DT><TT>endOfInput</TT></DT>
<DD>if <TT>s</TT> is empty, the input stream having ended. </DD>
</DL>

<P><HR>
<A NAME="0018"><A NAME="ReadToken">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0017" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0019" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>ReadString - Read a string</H4>
 
<P><PRE>PROCEDURE&nbsp;ReadString&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;s:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
PROCEDURE&nbsp;ReadString&nbsp;(VAR&nbsp;s:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
</PRE>

<P>Modules: <TT><A HREF="#0015" TARGET=body>TextIO</A></TT>, <TT><A HREF="#0015" TARGET=body>STextIO</A></TT>
<P>If there is a character next in the input stream identified by <TT>cid</TT>, the procedure <TT>ReadString</TT> reads a string of characters; reading continues as long as there are still characters before the next line mark or the end of the stream and the capacity of <TT>s</TT> has not been exhausted. The string is copied to <TT>s</TT> as a string value. The read result for the channel is set to the value 
<DL>
 
<DT><TT>allRight</TT></DT>
<DD>if <TT>s</TT> is not empty; </DD>
<DT><TT>endOfLine</TT></DT>
<DD>if <TT>s</TT> is empty, the next item being a line mark; </DD>
<DT><TT>endOfInput</TT></DT>
<DD>if <TT>s</TT> is empty, the input stream having ended. </DD>
</DL>

<P><HR>
<A NAME="0019"><A NAME="SkipLine">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0018" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0020" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>ReadToken - Read a space-delimited token</H4>
 
<P><PRE>PROCEDURE&nbsp;ReadToken&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;s:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
PROCEDURE&nbsp;ReadToken&nbsp;(VAR&nbsp;s:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
</PRE>

<P>Modules: <TT><A HREF="#0015" TARGET=body>TextIO</A></TT>, <TT><A HREF="#0015" TARGET=body>STextIO</A></TT>
<P>The procedure <TT>ReadToken</TT> first skips any leading spaces in the input stream identified by <TT>cid</TT>. If the next item is a character, a string of characters is read; reading continues as long as there are still non-space characters before the next line mark or the end of the stream. As much of the string as can be accommodated is copied to <TT>s</TT> as a string value. The read result for the channel is set to the value 
<DL>
 
<DT><TT>allRight</TT></DT>
<DD>if <TT>s</TT> is not empty and accomodates all of the string that has been read; </DD>
<DT><TT>outOfRange</TT></DT>
<DD>if <TT>s</TT> is not empty but does not accommodate all of the string; </DD>
<DT><TT>endOfLine</TT></DT>
<DD>if <TT>s</TT> is empty, the next item being a line mark; </DD>
<DT><TT>endOfInput</TT></DT>
<DD>if <TT>s</TT> is empty, the input stream having ended. </DD>
</DL>

<P><HR>
<A NAME="0020"><A NAME="WriteChar">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0019" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0021" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>SkipLine - Skip rest of input line</H4>
 
<P><PRE>PROCEDURE&nbsp;SkipLine&nbsp;(cid:&nbsp;IOChan.ChanId);
PROCEDURE&nbsp;SkipLine&nbsp;();
</PRE>

<P>Modules: <TT><A HREF="#0015" TARGET=body>TextIO</A></TT>, <TT><A HREF="#0015" TARGET=body>STextIO</A></TT>
<P>The procedure <TT>SkipLine</TT> reads successive items from the input stream identified by <TT>cid</TT> up to and including the next line mark, or until the end of the stream is reached. 
<P>The read result for the channel is set to the value 
<DL>
 
<DT><TT>allRight</TT></DT>
<DD>if a line mark is read; </DD>
<DT><TT>endOfInput</TT></DT>
<DD>if no line mark is read, the input stream having ended. </DD>
</DL>

<P><HR>
<A NAME="0021"><A NAME="WriteLn">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0020" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0022" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>WriteChar - Write a character</H4>
 
<P><PRE>PROCEDURE&nbsp;WriteChar&nbsp;(cid:&nbsp;IOChan.ChanId;&nbsp;ch:&nbsp;CHAR);
PROCEDURE&nbsp;WriteChar&nbsp;(ch:&nbsp;CHAR);
</PRE>

<P>The procedure <TT>WriteChar</TT> writes the character <TT>ch</TT> to the output stream identified by <TT>cid</TT>. 
<P><HR>
<A NAME="0022"><A NAME="WriteString">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0021" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0023" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>WriteLn - Write a line mark</H4>
 
<P><PRE>PROCEDURE&nbsp;WriteLn&nbsp;(cid:&nbsp;IOChan.ChanId);
PROCEDURE&nbsp;WriteLn&nbsp;();
</PRE>

<P>Modules: <TT><A HREF="#0015" TARGET=body>TextIO</A></TT>, <TT><A HREF="#0015" TARGET=body>STextIO</A></TT>
<P>The procedure <TT>WriteLn</TT> writes a line mark to the output stream identified by <TT>cid</TT>. 
<P><HR>
<A NAME="0023">
<A HREF="#0015" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0022" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0024" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>WriteString - Write a string</H4>
 
<P><PRE>PROCEDURE&nbsp;WriteString&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
PROCEDURE&nbsp;WriteString&nbsp;(s:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
</PRE>

<P>Modules: <TT><A HREF="#0015" TARGET=body>TextIO</A></TT>, <TT><A HREF="#0015" TARGET=body>STextIO</A></TT>
<P>The procedure <TT>WriteString</TT> writes the string value in <TT>s</TT> to the output stream identified by <TT>cid</TT>. 
<P><HR>
<A NAME="0024"><A NAME="ReadInt">
<A HREF="#0014" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0023" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0025" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Modules WholeIO and SWholeIO</H3>

<P>The module <TT>WholeIO</TT> provides facilities for input and output of whole numbers in decimal text form. 
<P>The text form of a signed whole number is 
<P><PRE>[&quot;+&quot;&nbsp;|&nbsp;&quot;-&quot;],&nbsp;decimal&nbsp;digit,&nbsp;{decimal&nbsp;digit}
</PRE>

<P>The text form of an unsigned whole number is 
<P><PRE>decimal&nbsp;digit,&nbsp;{decimal&nbsp;digit}
</PRE>

<P>The procedures of the module <TT>SWholeIO</TT> behave as the corresponding procedures of the module <TT>WholeIO</TT>, except that input is taken from the default input channel, and output is sent to the default output channel. 
<P><UL>
<LI><A HREF="#0025" TARGET=body>ReadInt - Read an INTEGER value</A>
<LI><A HREF="#0026" TARGET=body>WriteInt - Write an INTEGER value</A>
<LI><A HREF="#0027" TARGET=body>ReadCard - Read a CARDINAL value</A>
<LI><A HREF="#0028" TARGET=body>WriteCard - Write a CARDINAL value</A>
</UL>
<P><HR>
<A NAME="0025"><A NAME="WriteInt">
<A HREF="#0024" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0024" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0026" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>ReadInt - Read an INTEGER value</H4>
 
<P><PRE>PROCEDURE&nbsp;ReadInt&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;int:&nbsp;INTEGER);
PROCEDURE&nbsp;ReadInt&nbsp;(VAR&nbsp;int:&nbsp;INTEGER);
</PRE>

<P>Modules: <TT><A HREF="#0024" TARGET=body>WholeIO</A></TT>, <TT><A HREF="#0024" TARGET=body>SWholeIO</A></TT>
<P>The procedure <TT>ReadInt</TT> skips any leading spaces from the input stream identified by <TT>cid</TT>, and then reads characters that form a signed whole number. The read result for the channel is set to the value 
<DL>
 
<DT><TT>allRight</TT></DT>
<DD>if a signed whole number is read, and its value is in the range of the type <TT>INTEGER</TT>; the value of this number is assigned to <TT>int</TT>; </DD>
<DT><TT>outOfRange</TT></DT>
<DD>if a signed whole number is read, but its value is out of range of the type <TT>INTEGER</TT>; the value <TT>MAX(INTEGER)</TT> or <TT>MIN(INTEGER)</TT> is assigned to <TT>int</TT> according to the sign of the number; </DD>
<DT><TT>wrongFormat</TT></DT>
<DD>if there are characters read or to be read, but these are not in the format of a signed whole number; the value of <TT>int</TT> is not defined; </DD>
<DT><TT>endOfLine</TT></DT>
<DD>if no characters are read, the next item being a line mark; the value of <TT>int</TT> is not defined; </DD>
<DT><TT>endOfInput</TT></DT>
<DD>if no characters are read, the input having ended; the value of <TT>int</TT> is not defined. </DD>
</DL>

<P><HR>
<A NAME="0026"><A NAME="ReadCard">
<A HREF="#0024" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0025" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0027" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>WriteInt - Write an INTEGER value</H4>
 
<P><PRE>PROCEDURE&nbsp;WriteInt&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int:&nbsp;INTEGER;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
PROCEDURE&nbsp;WriteInt&nbsp;(int:&nbsp;INTEGER;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
</PRE>

<P>Modules: <TT><A HREF="#0024" TARGET=body>WholeIO</A></TT>, <TT><A HREF="#0024" TARGET=body>SWholeIO</A></TT>
<P>The procedure <TT>WriteInt</TT> writes the value of <TT>int</TT> to the output stream identified by <TT>cid</TT> in text form, with leading spaces as required to make the number of characters written at least that given by <TT>width</TT>. A sign is written only for negative values. In the special case of a value of zero for <TT>width</TT>, exactly one leading space is written. 
<P><HR>
<A NAME="0027"><A NAME="WriteCard">
<A HREF="#0024" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0026" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0028" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>ReadCard - Read a CARDINAL value</H4>
 
<P><PRE>PROCEDURE&nbsp;ReadCard&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;card:&nbsp;CARDINAL);
PROCEDURE&nbsp;ReadCard&nbsp;(VAR&nbsp;card:&nbsp;CARDINAL);
</PRE>

<P>Modules: <TT><A HREF="#0024" TARGET=body>WholeIO</A></TT>, <TT><A HREF="#0024" TARGET=body>SWholeIO</A></TT>
<P>The procedure <TT>ReadCard</TT> skips any leading spaces from the input stream identified by <TT>cid</TT>, and then reads characters that form an unsigned whole number. The read result for the channel is set to the value 
<DL>
 
<DT><TT>allRight</TT></DT>
<DD>if an unsigned whole number is read, and its value is in the range of the type <TT>CARDINAL</TT>; the value of the number is assigned to <TT>card</TT>; </DD>
<DT><TT>outOfRange</TT></DT>
<DD>if a signed whole number is read, but its value is out of range of the values of the type <TT>CARDINAL</TT>; the value <TT>MAX(CARDINAL)</TT> is assigned to <TT>card</TT>; </DD>
<DT><TT>wrongFormat</TT></DT>
<DD>if there are characters read or to be read, but these are not in the format of an unsigned whole number; the value of <TT>card</TT> is not defined; </DD>
<DT><TT>endOfLine</TT></DT>
<DD>if no characters are read, the next item being a line mark; the value of <TT>card</TT> is not defined; </DD>
<DT><TT>endOfInput</TT></DT>
<DD>if no characters are read, the input having ended; the value of <TT>card</TT> is not defined. </DD>
</DL>

<P><HR>
<A NAME="0028">
<A HREF="#0024" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0027" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0029" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>WriteCard - Write a CARDINAL value</H4>
 
<P><PRE>PROCEDURE&nbsp;WriteCard&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;card:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
PROCEDURE&nbsp;WriteCard&nbsp;(card:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
</PRE>

<P>Modules: <TT><A HREF="#0024" TARGET=body>WholeIO</A></TT>, <TT><A HREF="#0024" TARGET=body>SWholeIO</A></TT>
<P>The procedure <TT>WriteCard</TT> writes the value of <TT>card</TT> to the output stream identified by <TT>cid</TT> in text form, with leading spaces as required to make the number of characters written at least that given by <TT>width</TT>. In the special case of a value of zero for <TT>width</TT>, exactly one leading space is written. 
<P><HR>
<A NAME="0029"><A NAME="ReadReal">
<A HREF="#0014" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0028" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0030" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Modules RealIO, SRealIO, LongIO, and SLongIO</H3>

<P>The modules <TT>RealIO</TT> and <TT>LongIO</TT> provide facilities for input and output of real numbers in decimal text form. 
<P>In the case of <TT>RealIO</TT>, real number parameters are of the type <TT>REAL</TT>. In the case of <TT>LongIO</TT>, real number parameters are of the type <TT>LONGREAL</TT>. 
<P>The semantics of the two modules are the same, except that when module <TT>RealIO</TT> refers to real number values, these values are of the type <TT>REAL</TT>, and when module <TT>LongIO</TT> refers to real number values, these values are of the type <TT>LONGREAL</TT>. 
<P><B>NOTE:</B> 
<P>The above statement is merely to avoid needless repetition of the semantics for the two modules. 
<P>The text form of a signed fixed-point real number is 
<P><PRE>[&quot;+&quot;&nbsp;|&nbsp;&quot;-&quot;],&nbsp;decimal&nbsp;digit,&nbsp;{decimal&nbsp;digit},
[&quot;.&quot;,&nbsp;{decimal&nbsp;digit}]
</PRE>

<P>The text form of a signed floating-point real number is 
<P><PRE>signed&nbsp;fixed-point&nbsp;real&nbsp;number,
&quot;E&quot;|&quot;e&quot;,&nbsp;[&quot;+&quot;&nbsp;|&nbsp;&quot;-&quot;],&nbsp;decimal&nbsp;digit,&nbsp;{decimal&nbsp;digit}
</PRE>

<P>The procedures of the module <TT>SRealIO</TT> behave as the corresponding procedures of the module <TT>RealIO</TT>, except that input is taken from the default input channel, and output is sent to the default output channel. 
<P>The procedures of the module <TT>SLongIO</TT> behave as the corresponding procedures of the module <TT>LongIO</TT>, except that input is taken from the default input channel, and output is sent to the default output channel. 
<P><UL>
<LI><A HREF="#0030" TARGET=body>ReadReal - Read a real value</A>
<LI><A HREF="#0031" TARGET=body>WriteFloat - Write a real value in floating-point format</A>
<LI><A HREF="#0032" TARGET=body>WriteEng - Write a real value in engineering format</A>
<LI><A HREF="#0033" TARGET=body>WriteFixed - Write a real value in fixed-point format</A>
<LI><A HREF="#0034" TARGET=body>WriteReal - Write a real value</A>
</UL>
<P><HR>
<A NAME="0030"><A NAME="WriteFloat">
<A HREF="#0029" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0029" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0031" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>ReadReal - Read a real value</H4>
 
<P><PRE>PROCEDURE&nbsp;ReadReal&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;real:&nbsp;REAL);
PROCEDURE&nbsp;ReadReal&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;real:&nbsp;LONGREAL);
PROCEDURE&nbsp;ReadReal&nbsp;(VAR&nbsp;real:&nbsp;REAL);
PROCEDURE&nbsp;ReadReal&nbsp;(VAR&nbsp;real:&nbsp;LONGREAL);
</PRE>

<P>Modules: <TT><A HREF="#0029" TARGET=body>RealIO</A></TT>, <TT><A HREF="#0029" TARGET=body>SRealIO</A></TT>, <TT><A HREF="#0029" TARGET=body>LongIO</A></TT>, <TT><A HREF="#0029" TARGET=body>SLongIO</A></TT> 
<P>The procedure <TT>ReadReal</TT> skips any leading spaces from the input stream identified by <TT>cid</TT>, and then reads characters that form a signed fixed or floating point number. The read result for the channel is set to the value 
<DL>
 
<DT><TT>allRight</TT></DT>
<DD>if a signed real number is read, and its value is in the range of the type of <TT>real</TT>; the value of this number is assigned to <TT>real</TT>; </DD>
<DT><TT>outOfRange</TT></DT>
<DD>if a signed real number is read, but its value is out of range of the type of <TT>real</TT>; the maximum or minimum value of the type of <TT>real</TT> is assigned to <TT>real</TT> according to the sign of the number; </DD>
<DT><TT>wrongFormat</TT></DT>
<DD>if there are characters read or to be read, but these characters are not in the format of a signed real number; the value of <TT>real</TT> is not defined; </DD>
<DT><TT>endOfLine</TT></DT>
<DD>if no characters are read, the next item being a line mark; the value of <TT>real</TT> is not defined; </DD>
<DT><TT>endOfInput</TT></DT>
<DD>if no characters are read, the input having ended; the value of <TT>real</TT> is not defined. </DD>
</DL>

<P><HR>
<A NAME="0031"><A NAME="WriteEng">
<A HREF="#0029" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0030" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0032" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>WriteFloat - Write a real value in floating-point format</H4>
 
<P><PRE>PROCEDURE&nbsp;WriteFloat&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real:&nbsp;REAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigFigs:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
PROCEDURE&nbsp;WriteFloat&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real:&nbsp;LONGREAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigFigs:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
PROCEDURE&nbsp;WriteFloat&nbsp;(real:&nbsp;REAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigFigs:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
PROCEDURE&nbsp;WriteFloat&nbsp;(real:&nbsp;LONGREAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigFigs:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
</PRE>

<P>Modules: <TT><A HREF="#0029" TARGET=body>RealIO</A></TT>, <TT><A HREF="#0029" TARGET=body>SRealIO</A></TT>, <TT><A HREF="#0029" TARGET=body>LongIO</A></TT>, <TT><A HREF="#0029" TARGET=body>SLongIO</A></TT> 
<P>The procedure <TT>WriteFloat</TT> writes the value of <TT>real</TT> to the output stream identified by <TT>cid</TT> in floating-point text form, with leading spaces as required to make the number of characters written at least that given by <TT>width</TT>. A sign is written only for negative values. In the special case of a value of zero for <TT>width</TT>, exactly one leading space is written. 
<P>One significant digit is included in the whole number part. The signed exponent part is included only if the exponent value is not zero. If the value of <TT>sigFigs</TT> is greater than zero, that number of significant digits is included, otherwise an implementation-defined number of significant digits is included. The decimal point is not included if there are no significant digits in the fractional part. 
<P>The following table gives examples of output by <TT>WriteFloat</TT>: 
<P ALIGN=CENTER><TT>
<TABLE CELLSPACING=0>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none none solid none;border-width: 0px 0px 1px 0px">sigFigs </TT></TD>
<TD  STYLE="padding:0px 3px;border-style: none none solid none;border-width: 0px 0px 1px 0px"><TT>3923009 </TT></TD>
<TD  STYLE="padding:0px 3px;border-style: none none solid none;border-width: 0px 0px 1px 0px"><TT>39.23009 </TT></TD>
<TD  STYLE="padding:0px 3px;border-style: none none solid none;border-width: 0px 0px 1px 0px"><TT>0.0003923009 </TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;"><TT>1 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>4E+6 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>4E+1 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>4E-4 </TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;"><TT>2 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>3.9E+6 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>3.9E+1 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>3.9E-4 </TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;"><TT>5 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>3.9230E+6 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>3.9230E+1 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>3.9230E-4 </TT></TD>
</TR>
</TABLE> 
<P><HR>
<A NAME="0032"><A NAME="WriteFixed">
<A HREF="#0029" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0031" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0033" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>WriteEng - Write a real value in engineering format</H4>
 
<P><PRE>PROCEDURE&nbsp;WriteEng&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real:&nbsp;REAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigFigs:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
PROCEDURE&nbsp;WriteEng&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real:&nbsp;LONGREAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigFigs:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
PROCEDURE&nbsp;WriteEng&nbsp;(real:&nbsp;REAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigFigs:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
PROCEDURE&nbsp;WriteEng&nbsp;(real:&nbsp;LONGREAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigFigs:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
</PRE>

<P>Modules: <TT><A HREF="#0029" TARGET=body>RealIO</A></TT>, <TT><A HREF="#0029" TARGET=body>SRealIO</A></TT>, <TT><A HREF="#0029" TARGET=body>LongIO</A></TT>, <TT><A HREF="#0029" TARGET=body>SLongIO</A></TT> 
<P>The procedure <TT>WriteEng</TT> behaves as the procedure <TT><A HREF="#0031" TARGET=body>WriteFloat</A></TT> except that the number is scaled with one to three digits in the whole number part, and with an exponent that is a multiple of three. 
<P>The following table gives examples of output by <TT>WriteEng</TT>: 
<P ALIGN=CENTER><TT>
<TABLE CELLSPACING=0>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none none solid none;border-width: 0px 0px 1px 0px">sigFigs </TT></TD>
<TD  STYLE="padding:0px 3px;border-style: none none solid none;border-width: 0px 0px 1px 0px"><TT>3923009 </TT></TD>
<TD  STYLE="padding:0px 3px;border-style: none none solid none;border-width: 0px 0px 1px 0px"><TT>39.23009 </TT></TD>
<TD  STYLE="padding:0px 3px;border-style: none none solid none;border-width: 0px 0px 1px 0px"><TT>0.0003923009 </TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;"><TT>1 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>4E+6 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>40 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>400E-6 </TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;"><TT>2 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>3.9E+6 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>39 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>390E-6 </TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;"><TT>5 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>3.9230E+6 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>39.230 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>392.30E-6 </TT></TD>
</TR>
</TABLE> 
<P><HR>
<A NAME="0033"><A NAME="WriteReal">
<A HREF="#0029" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0032" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0034" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>WriteFixed - Write a real value in fixed-point format</H4>
 
<P><PRE>PROCEDURE&nbsp;WriteFixed&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real:&nbsp;REAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;place:&nbsp;INTEGER;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
PROCEDURE&nbsp;WriteFixed&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real:&nbsp;LONGREAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;place:&nbsp;INTEGER;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
PROCEDURE&nbsp;WriteFixed&nbsp;(real:&nbsp;REAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;place:&nbsp;INTEGER;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
PROCEDURE&nbsp;WriteFixed&nbsp;(real:&nbsp;LONGREAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;place:&nbsp;INTEGER;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
</PRE>

<P>Modules: <TT><A HREF="#0029" TARGET=body>RealIO</A></TT>, <TT><A HREF="#0029" TARGET=body>SRealIO</A></TT>, <TT><A HREF="#0029" TARGET=body>LongIO</A></TT>, <TT><A HREF="#0029" TARGET=body>SLongIO</A></TT> 
<P>The procedure <TT>WriteFixed</TT> writes the value of <TT>real</TT> to the output stream identified by <TT>cid</TT> in fixed-point text form with leading spaces as required to make the number of characters written at least that given by <TT>width</TT>. A sign is written only for negative values. In the special case of a value of zero for <TT>width</TT>, exactly one leading space is written. 
<P>At least one digit is included in the whole number part. The value is rounded to the given value of <TT>place</TT> relative to the decimal point. The decimal point is suppressed if <TT>place</TT> is less than zero. 
<P>The following table gives examples of output by <TT>WriteFixed</TT>: 
<P ALIGN=CENTER><TT>
<TABLE CELLSPACING=0>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;border-style: none none solid none;border-width: 0px 0px 1px 0px">places </TT></TD>
<TD  STYLE="padding:0px 3px;border-style: none none solid none;border-width: 0px 0px 1px 0px"><TT>3923009 </TT></TD>
<TD  STYLE="padding:0px 3px;border-style: none none solid none;border-width: 0px 0px 1px 0px"><TT>39.23009 </TT></TD>
<TD  STYLE="padding:0px 3px;border-style: none none solid none;border-width: 0px 0px 1px 0px"><TT>0.0003923009 </TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;"><TT>-5 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>3920000 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>0 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>0 </TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;"><TT>-2 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>3923010 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>40 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>0 </TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;"><TT>-1 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>3923009 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>39 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>0 </TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;"><TT>0 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>3923009. </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>39. </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>0. </TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;"><TT>1 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>3923009.0 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>39.2 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>0.0 </TT></TD>
</TR>
<TR>
<TD ALIGN=CENTER STYLE="padding:0px 3px;"><TT>4 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>3923009.0000 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>39.2301 </TT></TD>
<TD  STYLE="padding:0px 3px;"><TT>0.0004 </TT></TD>
</TR>
</TABLE> 
<P><HR>
<A NAME="0034">
<A HREF="#0029" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0033" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0035" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>WriteReal - Write a real value</H4>
 
<P><PRE>PROCEDURE&nbsp;WriteReal&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real:&nbsp;REAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
PROCEDURE&nbsp;WriteReal&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real:&nbsp;LONGREAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
PROCEDURE&nbsp;WriteReal&nbsp;(real:&nbsp;REAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
PROCEDURE&nbsp;WriteReal&nbsp;(real:&nbsp;LONGREAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;CARDINAL);
</PRE>

<P>Modules: <TT><A HREF="#0029" TARGET=body>RealIO</A></TT>, <TT><A HREF="#0029" TARGET=body>SRealIO</A></TT>, <TT><A HREF="#0029" TARGET=body>LongIO</A></TT>, <TT><A HREF="#0029" TARGET=body>SLongIO</A></TT> 
<P>If the sign and magnitude of real can be expressed in a field given by <TT>width</TT>, the procedure <TT>WriteReal</TT> behaves as the procedure <TT><A HREF="#0033" TARGET=body>WriteFixed</A></TT>, with a value of <TT>place</TT> chosen to fill exactly the remaining field. Otherwise it behaves as the procedure <TT><A HREF="#0031" TARGET=body>WriteFloat</A></TT>, with a value of <TT>sigFigs</TT> of at least one, limited to those that can be included together with the sign and exponent part in the given <TT>width</TT>. 
<P>In the special case of a <TT>width</TT> of zero, the effect is as for the procedure <TT><A HREF="#0031" TARGET=body>WriteFloat</A></TT> with a value of <TT>sigFigs</TT> equal to zero. 
<P><HR>
<A NAME="0035"><A NAME="Read">
<A HREF="#0014" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0034" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0036" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Modules RawIO and SRawIO</H3>

<P>The module <TT>RawIO</TT> provides facilities for direct input and output of data using raw operations (i.e. without any interpretation). 
<P>The procedures of the module <TT>SRawIO</TT> behave as the corresponding procedures of the module <TT>RawIO</TT>, except that input is taken from the default input channel, and output is sent to the default output channel. 
<P><UL>
<LI><A HREF="#0036" TARGET=body>Read - Read storage units</A>
<LI><A HREF="#0037" TARGET=body>Write - Write storage units</A>
</UL>
<P><HR>
<A NAME="0036"><A NAME="Write">
<A HREF="#0035" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0035" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0037" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>Read - Read storage units</H4>
 
<P><PRE>PROCEDURE&nbsp;Read&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;to:&nbsp;ARRAY&nbsp;OF&nbsp;SYSTEM.LOC);
PROCEDURE&nbsp;Read&nbsp;(VAR&nbsp;to:&nbsp;ARRAY&nbsp;OF&nbsp;SYSTEM.LOC);
</PRE>

<P>Modules: <TT><A HREF="#0035" TARGET=body>RawIO</A></TT>, <TT><A HREF="#0035" TARGET=body>SRawIO</A></TT>
<P>While the stream identified by <TT>cid</TT> is not exhausted, the procedure <TT>Read</TT> reads successive storage units from that channel, and assign them without interpretation to successive components of <TT>to</TT>. The read result for the channel is set to the value 
<DL>
 
<DT><TT>allRight</TT></DT>
<DD>if items are read for all components; </DD>
<DT><TT>wrongFormat</TT></DT>
<DD>if some items are read, but not for all components; </DD>
<DT><TT>endOfInput</TT></DT>
<DD>if no items are read, the input having ended. </DD>
</DL>

<P><HR>
<A NAME="0037">
<A HREF="#0035" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0036" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0038" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Write - Write storage units</H4>
 
<P><PRE>PROCEDURE&nbsp;Write&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from:&nbsp;ARRAY&nbsp;OF&nbsp;SYSTEM.LOC);
PROCEDURE&nbsp;Write&nbsp;(from:&nbsp;ARRAY&nbsp;OF&nbsp;SYSTEM.LOC);
</PRE>

<P>Modules: <TT><A HREF="#0035" TARGET=body>RawIO</A></TT>, <TT><A HREF="#0035" TARGET=body>SRawIO</A></TT>
<P>The procedure <TT>Write</TT> writes successive components of <TT>from</TT> to the channel identified by <TT>cid</TT>, as storage units without interpretation. 
<P><HR>
<A NAME="0038"><A NAME="ReadResults">
<A HREF="#0014" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0037" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0039" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Module IOConsts</H3>

<P>The module <TT>IOConsts</TT> defines the enumeration type <TT>ReadResults</TT> used to express read results. Programs do not normally need to import from <TT>IOConsts</TT> directly, since client modules define identifiers that correspond to those defined by this module. 
<P><UL>
<LI><A HREF="#0039" TARGET=body>ReadResults - Read result identities</A>
</UL>
<P><HR>
<A NAME="0039">
<A HREF="#0038" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0038" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0040" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>ReadResults - Read result identities</H4>
 
<P><PRE>TYPE
&nbsp;&nbsp;ReadResults&nbsp;=&nbsp;&nbsp;(*&nbsp;This&nbsp;type&nbsp;is&nbsp;used&nbsp;to&nbsp;classify&nbsp;the&nbsp;result
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;an&nbsp;input&nbsp;operation&nbsp;*)
&nbsp;&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;notKnown,&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;no&nbsp;read&nbsp;result&nbsp;is&nbsp;set&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;allRight,&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;data&nbsp;is&nbsp;as&nbsp;expected&nbsp;or&nbsp;as&nbsp;required&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;outOfRange,&nbsp;&nbsp;(*&nbsp;data&nbsp;cannot&nbsp;be&nbsp;represented&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;wrongFormat,&nbsp;(*&nbsp;data&nbsp;not&nbsp;in&nbsp;expected&nbsp;format&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;endOfLine,&nbsp;&nbsp;&nbsp;(*&nbsp;end&nbsp;of&nbsp;line&nbsp;seen&nbsp;before&nbsp;expected&nbsp;data&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;endOfInput&nbsp;&nbsp;&nbsp;(*&nbsp;end&nbsp;of&nbsp;input&nbsp;seen&nbsp;before&nbsp;expected&nbsp;data&nbsp;*)
&nbsp;&nbsp;);
</PRE>

<P>Module <TT><A HREF="#0038" TARGET=body>IOConsts</A></TT>
<P><HR>
<A NAME="0040"><A NAME="ReadResults">
<A HREF="#0014" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0039" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0041" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Modules IOResult and SIOResult</H3>

<P>The module <TT>IOResult</TT> provides the facility for a program to determine whether the last operation to read data from a specified input channel found data in the required format. 
<P>The procedure of the module <TT>SIOResult</TT> behaves as the corresponding procedure of the module <TT>IOResult</TT>, except that the read result for the default input channel is returned. 
<P><B>NOTE:</B> 
<P>The existence of the module <TT><A HREF="#0038" TARGET=body>IOConsts</A></TT> allows the definition module <TT>SIOResult</TT> to be independent of the modules <TT><A HREF="#0040" TARGET=body>IOResult</A></TT> and <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>. 
<P><UL>
<LI><A HREF="#0041" TARGET=body>ReadResults - Read result identities</A>
<LI><A HREF="#0042" TARGET=body>ReadResult - Get read result for channel</A>
</UL>
<P><HR>
<A NAME="0041"><A NAME="ReadResult">
<A HREF="#0040" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0040" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0042" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>ReadResults - Read result identities</H4>
 
<P><PRE>TYPE
&nbsp;&nbsp;ReadResults&nbsp;=&nbsp;IOConsts.ReadResults;
</PRE>

<P>Modules: <TT><A HREF="#0040" TARGET=body>IOResult</A></TT>, <TT><A HREF="#0040" TARGET=body>SIOResult</A></TT>
<P>The type <TT><A HREF="#0039" TARGET=body>IOConsts.ReadResults</A></TT> is re-exported. 
<P><HR>
<A NAME="0042">
<A HREF="#0040" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0041" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0043" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>ReadResult - Get read result for channel</H4>
 
<P><PRE>PROCEDURE&nbsp;ReadResult&nbsp;(cid:&nbsp;IOChan.ChanId):&nbsp;ReadResults;
PROCEDURE&nbsp;ReadResult&nbsp;():&nbsp;ReadResults;
</PRE>

<P>Modules: <TT><A HREF="#0040" TARGET=body>IOResult</A></TT>, <TT><A HREF="#0040" TARGET=body>SIOResult</A></TT>
<P>The function procedure <TT>ReadResult</TT> returns the stored read result for the channel identified by <TT>cid</TT>. 
<P><HR>
<A NAME="0043">
<A HREF="#0000" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0042" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0044" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Device-Independent Channel Operations</H2>

<P>The module <TT>IOChan</TT> provides access to channel operations that are provided in a device-independent manner for all channels. 
<P>Device-dependent operations (which include operations for opening new channels and subsequently closing them) are defined in the definition module for each device. 
<P><UL>
<LI><A HREF="#0044" TARGET=body>Module IOChan</A>
<LI><A HREF="#0047" TARGET=body>Module IOChan - Text Operations</A>
<LI><A HREF="#0054" TARGET=body>Module IOChan - Raw Operations</A>
<LI><A HREF="#0057" TARGET=body>Module IOChan - Common Operations</A>
<LI><A HREF="#0061" TARGET=body>Module IOChan - Access to Read Results</A>
<LI><A HREF="#0064" TARGET=body>Module IOChan - Channel Enquiries</A>
<LI><A HREF="#0066" TARGET=body>Module IOChan - Exceptions and Device Errors</A>
</UL>
<P><HR>
<A NAME="0044"><A NAME="ChanId">
<A HREF="#0043" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0043" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0045" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Module IOChan</H3>

<P>The module <TT>IOChan</TT> defines the hidden type <TT>ChanId</TT> that is used to identify channels throughout the input/output library, and provides facilities for device-independent access to operations supported by the device to which a channel is connected. 
<P><UL>
<LI><A HREF="#0045" TARGET=body>ChanId - Channel identity</A>
<LI><A HREF="#0046" TARGET=body>InvalidChan - Get an invalid channel id</A>
</UL>
<P><HR>
<A NAME="0045"><A NAME="InvalidChan">
<A HREF="#0044" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0044" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0046" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>ChanId - Channel identity</H4>
 
<P><PRE>TYPE
&nbsp;&nbsp;ChanId;
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>Values of this type are used to identify channels throughout the input/output library. 
<P><HR>
<A NAME="0046">
<A HREF="#0044" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0045" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0047" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>InvalidChan - Get an invalid channel id</H4>
 
<P><PRE>PROCEDURE&nbsp;InvalidChan&nbsp;():&nbsp;ChanId;
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>The function procedure <TT>InvalidChan</TT> returns the identity of the invalid channel. 
<P><B>NOTE:</B> 
<P>The invalid channel is a channel on which no data transfer operations are available; enquiries on the invalid channel indicate that this is the case. The identity of the invalid channel can be used to initialize variables of the type <TT>ChanId</TT>. 
<P><HR>
<A NAME="0047"><A NAME="Look">
<A HREF="#0043" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0046" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0048" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Module IOChan - Text Operations</H3>

<P>Each of the following procedures invokes a corresponding operation for the device associated with the given channel. If the associated device supports the operation on the channel, the behaviour of the procedure conforms with the given description. The full behaviour is defined separately for each device. 
<P>These device operations produce a <I>text stream</I>. A text stream is a sequence of items, each of which corresponds either to a character or a line mark. The sequence may be empty. 
<P>The text operations provided by a device module perform any necessary translation between the internal representation (as a sequence of characters and line marks) and the external representation used by the source or destination. This may involve, for example, translation to and from escape sequences used in a coded character set, mapping between the external and internal representation of lines, or the interpretation of format effectors. 
<P>The interpretation of control characters is implementation-defined. The exception <TT>textParseError</TT> occurs (but need not be raised) if input data does not correspond to a character or line mark. 
<P>If the device does not support the operation on the channel, it raises the exception <TT>notAvailable</TT>. 
<P><UL>
<LI><A HREF="#0048" TARGET=body>Look - Invoke Look operation</A>
<LI><A HREF="#0049" TARGET=body>Skip - Invoke Skip operation</A>
<LI><A HREF="#0050" TARGET=body>SkipLook - Invoke SkipLook operation</A>
<LI><A HREF="#0051" TARGET=body>WriteLn - Invoke WriteLn operation</A>
<LI><A HREF="#0052" TARGET=body>TextRead - Invoke TextRead operation</A>
<LI><A HREF="#0053" TARGET=body>TextWrite - Invoke TextWrite operation</A>
</UL>
<P><HR>
<A NAME="0048"><A NAME="Skip">
<A HREF="#0047" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0047" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0049" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>Look - Invoke Look operation</H4>
 
<P><PRE>PROCEDURE&nbsp;Look&nbsp;(cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;ch:&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;res:&nbsp;IOConsts.ReadResults);
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>The procedure <TT>Look</TT> invokes the <TT>Look</TT> operation for the device that is associated with the channel identified by <TT>cid</TT>. 
<P><B>NOTE:</B> 
<P>If supported on the channel, the device <TT>Look</TT> operation attempts to examine the next item in the input stream for the channel identified by <TT>cid</TT>, without removing it. If the next item is a character, its value is assigned to <TT>ch</TT>; otherwise, the value of <TT>ch</TT> is not defined. <TT>res</TT> is set to the same value as the stored read result for the channel <TT>cid</TT>, this being: 
<DL>
 
<DT><TT>allRight</TT></DT>
<DD>if a character is seen next; </DD>
<DT><TT>endOfLine</TT></DT>
<DD>if no character is seen, the next item being a line mark; </DD>
<DT><TT>endOfInput</TT></DT>
<DD>if no character is seen, the input having ended. </DD>
</DL>

<P><HR>
<A NAME="0049"><A NAME="SkipLook">
<A HREF="#0047" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0048" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0050" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>Skip - Invoke Skip operation</H4>
 
<P><PRE>PROCEDURE&nbsp;Skip&nbsp;(cid:&nbsp;ChanId);
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>The procedure <TT>Skip</TT> invokes the <TT>Skip</TT> operation for the device that is associated with the channel identified by <TT>cid</TT>. 
<P><B>NOTE:</B> 
<P>If supported on the channel, the device <TT>Skip</TT> operation attempts to remove the next item in the input stream for the channel identified by <TT>cid</TT>. If there is no next item, the end of the input stream having been reached, the exception <TT>skipAtEnd</TT> is raised; otherwise the next character or line mark in the stream is removed, and the stored read result for the channel <TT>cid</TT> is set to the value <TT>allRight</TT>. 
<P><HR>
<A NAME="0050"><A NAME="WriteLn">
<A HREF="#0047" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0049" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0051" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>SkipLook - Invoke SkipLook operation</H4>
 
<P><PRE>PROCEDURE&nbsp;SkipLook&nbsp;(cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;ch:&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;res:&nbsp;IOConsts.ReadResults);
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>The procedure <TT>SkipLook</TT> invokes the <TT>SkipLook</TT> operation for the device that is associated with the channel identified by <TT>cid</TT>. 
<P><B>NOTE:</B> 
<P>If supported on the channel, the device <TT>SkipLook</TT> operation attempts to remove the next item in the input stream for the channel identified by <TT>cid</TT> and then to examine the following item without removing it. If there is no next item, the end of the input stream having been reached, the exception <TT>skipAtEnd</TT> is raised; otherwise the next character or line mark in the stream is removed. If this is followed by a character as the next item in the stream, its value is assigned to <TT>ch</TT>, without removing the character from the stream; otherwise, the value of <TT>ch</TT> is not defined. <TT>res</TT> is set to the same value as the stored read result for the channel <TT>cid</TT>, this being: 
<DL>
 
<DT><TT>allRight</TT></DT>
<DD>if a character is seen next; </DD>
<DT><TT>endOfLine</TT></DT>
<DD>if no character is seen, the next item being a line mark; </DD>
<DT><TT>endOfInput</TT></DT>
<DD>if no character is seen, the input having ended. </DD>
</DL>

<P><HR>
<A NAME="0051"><A NAME="TextRead">
<A HREF="#0047" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0050" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0052" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>WriteLn - Invoke WriteLn operation</H4>
 
<P><PRE>PROCEDURE&nbsp;WriteLn&nbsp;(cid:&nbsp;ChanId);
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>The procedure <TT>WriteLn</TT> invokes the <TT>WriteLn</TT> operation for the device that is associated with the channel identified by <TT>cid</TT>. 
<P><B>NOTE:</B> If supported on the channel, the device <TT>WriteLn</TT> operation writes a line mark to the output stream identified by <TT>cid</TT>. 
<P><HR>
<A NAME="0052"><A NAME="TextWrite">
<A HREF="#0047" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0051" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0053" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>TextRead - Invoke TextRead operation</H4>
 
<P><PRE>PROCEDURE&nbsp;TextRead&nbsp;(cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to:&nbsp;SYSTEM.ADDRESS;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxChars:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;charsRead:&nbsp;CARDINAL);
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>The procedure <TT>TextRead</TT> invokes the <TT>TextRead</TT> operation for the device that is associated with the channel identified by <TT>cid</TT>. 
<P><B>NOTES:</B> 
<UL>
 
<LI>If supported on the channel, the device <TT>TextRead</TT> operation reads at most <TT>maxChars</TT> characters from the current line on the input stream for the channel identified by <TT>cid</TT>, and assigns their values to successive components of an array variable of the character type for which the address of the first component is <TT>to</TT>. The number of characters read is assigned to <TT>charsRead</TT>. The read result for the channel <TT>cid</TT> is set to the value 
<DL>
 
<DT><TT>allRight</TT></DT>
<DD>if <TT>&lsquo;maxChars = charsRead = 0&rsquo; or (&lsquo;maxChars &gt; 0&rsquo; and &lsquo;charsRead &gt; 0&rsquo;)</TT>; </DD>
<DT><TT>endOfLine</TT></DT>
<DD>if <TT>&lsquo;maxChars &gt; 0&rsquo; and &lsquo;charsRead = 0&rsquo;</TT> , the next item being a line mark; </DD>
<DT><TT>endOfInput</TT></DT>
<DD>if <TT>&lsquo;maxChars &gt; 0&rsquo; and &lsquo;charsRead = 0&rsquo;</TT>, the input having ended. </DD>
</DL>
</LI>
<LI>The intention is to allow &lsquo;sub-arrays&rsquo; to be selected, by passing the address of a starting component within a larger array. An exception occurs, but need not be raised, if the call leads to an attempt to access a non-existent component of the larger array. </LI>
</UL>

<P><HR>
<A NAME="0053">
<A HREF="#0047" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0052" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0054" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>TextWrite - Invoke TextWrite operation</H4>
 
<P><PRE>PROCEDURE&nbsp;TextWrite&nbsp;(cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from:&nbsp;SYSTEM.ADDRESS;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;charsToWrite:&nbsp;CARDINAL);
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>The procedure <TT>TextWrite</TT> invokes the <TT>TextWrite</TT> operation for the device that is associated with the channel identified by <TT>cid</TT>. 
<P><B>NOTES:</B> 
<UL>
 
<LI>If supported on the channel, the device <TT>TextWrite</TT> operation copies <TT>charsToWrite</TT> characters, from successive components of an array variable of the character type, for which the address of the first component is <TT>from</TT>, to the output stream for the channel identified by <TT>cid</TT>. Copying starts from the index given by <TT>offset</TT>. </LI>
<LI>The intention is to allow &lsquo;sub-arrays&rsquo; to be selected, by passing the address of a starting component within a larger array. An exception occurs, but need not be raised, if the call leads to an attempt to access a non-existent component of the larger array. </LI>
</UL>

<P><HR>
<A NAME="0054"><A NAME="RawRead">
<A HREF="#0043" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0053" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0055" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Module IOChan - Raw Operations</H3>

<P>Each of the following procedures invokes a corresponding operation for the device associated with the given channel. If the associated device supports the operation on the channel, the behaviour of the procedure conforms with the given description. The full behaviour is defined for each device module. 
<P>The raw operations provided by a device module transfer data location by location with no translation or interpretation. 
<P>If the device does not support the operation on the channel, it raises the exception <TT>notAvailable</TT>. 
<P><UL>
<LI><A HREF="#0055" TARGET=body>RawRead - Invoke RawRead operation</A>
<LI><A HREF="#0056" TARGET=body>RawWrite - Invoke RawWrite operation</A>
</UL>
<P><HR>
<A NAME="0055"><A NAME="RawWrite">
<A HREF="#0054" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0054" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0056" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>RawRead - Invoke RawRead operation</H4>
 
<P><PRE>PROCEDURE&nbsp;RawRead&nbsp;(cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to:&nbsp;SYSTEM.ADDRESS;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxLocs:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;locsRead:&nbsp;CARDINAL);
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>The procedure <TT>RawRead</TT> invokes the <TT>RawRead</TT> operation for the device that is associated with the channel identified by <TT>cid</TT>. 
<P><B>NOTES</B> 
<UL>
 
<LI>If supported on the channel, the device <TT>RawRead</TT> operation reads at most <TT>maxLocs</TT> items from the input stream for the channel identified by <TT>cid</TT>, and assigns their values to successive components of an array variable of the location type for which the address of the first component is <TT>to</TT>. The number of items read is assigned to <TT>locsRead</TT>. The read result for the channel cid is set to the value 
<DL>
 
<DT><TT>allRight</TT></DT>
<DD>if <TT>(&lsquo;maxLocs = locsRead = 0&rsquo;) or (&lsquo;maxLocs &gt; 0 and &lsquo;locsRead &gt; 0&rsquo;)</TT> </DD>
<DT><TT>endOfInput</TT></DT>
<DD>if <TT>&lsquo;maxLocs &gt; 0&rsquo; and &lsquo;locsRead = 0&rsquo;</TT> </DD>
</DL>
</LI>
<LI>The intention is to allow &lsquo;sub-arrays&rsquo; to be selected, by passing the address of a starting component within a larger array. An exception occurs, but need not be raised, if the call leads to an attempt to access a non-existent component of the larger array. </LI>
</UL>

<P><HR>
<A NAME="0056">
<A HREF="#0054" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0055" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0057" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>RawWrite - Invoke RawWrite operation</H4>
 
<P><PRE>PROCEDURE&nbsp;RawWrite&nbsp;(cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from:&nbsp;SYSTEM.ADDRESS;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;locsToWrite:&nbsp;CARDINAL);
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>The procedure <TT>RawWrite</TT> invokes the <TT>RawWrite</TT> operation for the device that is associated with the channel identified by <TT>cid</TT>. 
<P><B>NOTES:</B> 
<UL>
 
<LI>If supported on the channel, the device <TT>RawWrite</TT> operation copies <TT>locsToWrite</TT> items, from successive components of an array variable of the character type, for which the address of the first component is <TT>from</TT>, to the output stream for the channel identified by <TT>cid</TT>. Copying starts from the index given by <TT>offset</TT>. </LI>
<LI>The intention is to allow &lsquo;sub-arrays&rsquo; to be selected, by passing the address of a starting component within a larger array. An exception occurs, but need not be raised, if the call leads to an attempt to access a non-existent component of the larger array. </LI>
</UL>

<P><HR>
<A NAME="0057"><A NAME="GetName">
<A HREF="#0043" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0056" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0058" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Module IOChan - Common Operations</H3>

<P>Each of the following procedures invokes a corresponding operation for the device associated with the given channel. The behaviour of the procedure conforms with the given description. The full behaviour is defined for each device module. 
<P><UL>
<LI><A HREF="#0058" TARGET=body>GetName - Invoke GetName operation</A>
<LI><A HREF="#0059" TARGET=body>Reset - Invoke Reset operation</A>
<LI><A HREF="#0060" TARGET=body>Flush - Invoke Flush operation</A>
</UL>
<P><HR>
<A NAME="0058"><A NAME="Reset">
<A HREF="#0057" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0057" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0059" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>GetName - Invoke GetName operation</H4>
 
<P><PRE>PROCEDURE&nbsp;GetName&nbsp;(cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;s:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>The procedure <TT>GetName</TT> invokes the <TT>GetName</TT> operation for the device that is associated with the channel identified by <TT>cid</TT>. 
<P><B>NOTES:</B> 
<UL>
 
<LI>The device <TT>GetName</TT> operation copies to <TT>s</TT> (as a string value) a name associated with the channel identified by <TT>cid</TT>. </LI>
<LI>The name is truncated if the capacity of <TT>s</TT> is inadequate. </LI>
</UL>

<P><HR>
<A NAME="0059"><A NAME="Flush">
<A HREF="#0057" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0058" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0060" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>Reset - Invoke Reset operation</H4>
 
<P><PRE>PROCEDURE&nbsp;Reset&nbsp;(cid:&nbsp;ChanId);
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>The procedure <TT>Reset</TT> invokes the Reset operation for the device that is associated with the channel identified by <TT>cid</TT>. 
<P><B>NOTE</B>: 
<P>The device <TT>Reset</TT> operation resets the device associated with the channel identified by <TT>cid</TT> to a state defined by the device module. 
<P><HR>
<A NAME="0060">
<A HREF="#0057" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0059" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0061" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Flush - Invoke Flush operation</H4>
 
<P><PRE>PROCEDURE&nbsp;Flush&nbsp;(cid:&nbsp;ChanId);
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>The procedure <TT>Flush</TT> invokes the <TT>Flush</TT> operation for the device that is associated with the channel identified by <TT>cid</TT>. 
<P><B>NOTE:</B> 
<P>The device <TT>Flush</TT> operation flushes any data buffered by the device module out to the destination associated with <TT>cid</TT>. 
<P><HR>
<A NAME="0061"><A NAME="SetReadResult">
<A HREF="#0043" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0060" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0062" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Module IOChan - Access to Read Results</H3>

<P>Higher-level data input procedures, for units such as strings and numerals, may alter the read result for a channel to indicate success or a particular kind of failure of interpretation. The result can be recovered, if necessary, by the caller of the data input procedure. 
<P><UL>
<LI><A HREF="#0062" TARGET=body>SetReadResult - Set read result for channel</A>
<LI><A HREF="#0063" TARGET=body>ReadResult - Get read result for channel</A>
</UL>
<P><HR>
<A NAME="0062"><A NAME="ReadResult">
<A HREF="#0061" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0061" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0063" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>SetReadResult - Set read result for channel</H4>
 
<P><PRE>PROCEDURE&nbsp;SetReadResult&nbsp;(cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res:&nbsp;IOConsts.ReadResults);
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>The procedure <TT>SetReadResult</TT> sets the read result for the channel identified by <TT>cid</TT> to the value given by <TT>res</TT>. 
<P><HR>
<A NAME="0063">
<A HREF="#0061" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0062" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0064" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>ReadResult - Get read result for channel</H4>
 
<P><PRE>PROCEDURE&nbsp;ReadResult&nbsp;(cid:&nbsp;ChanId):&nbsp;IOConsts.ReadResults;
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>The function procedure <TT>ReadResult</TT> returns the stored read result for the channel identified by <TT>cid</TT>. 
<P><HR>
<A NAME="0064"><A NAME="CurrentFlags">
<A HREF="#0043" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0063" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0065" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Module IOChan - Channel Enquiries</H3>

<P><UL>
<LI><A HREF="#0065" TARGET=body>CurrentFlags - Get current flags for channel</A>
</UL>
<P><HR>
<A NAME="0065">
<A HREF="#0064" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0064" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0066" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>CurrentFlags - Get current flags for channel</H4>
 
<P><PRE>PROCEDURE&nbsp;CurrentFlags&nbsp;(cid:&nbsp;ChanId):&nbsp;ChanConsts.FlagSet;
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>The function procedure <TT>CurrentFlags</TT> returns the set of flags that currently apply to the channel identified by <TT>cid</TT>, as defined for the associated device. 
<P><HR>
<A NAME="0066"><A NAME="ChanExceptions">
<A HREF="#0043" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0065" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0067" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Module IOChan - Exceptions and Device Errors</H3>

<P>The device-independent exceptions raised by the input/output library are identified by the values of the enumeration type <TT>ChanExceptions</TT>: 
<P><UL>
<LI><A HREF="#0067" TARGET=body>ChanExceptions - Channel exceptions identities</A>
<LI><A HREF="#0068" TARGET=body>IsChanException - Query exceptional state</A>
<LI><A HREF="#0069" TARGET=body>ChanException - Query exception id</A>
<LI><A HREF="#0070" TARGET=body>DeviceErrNum - Device error number</A>
<LI><A HREF="#0071" TARGET=body>DeviceError - Get device error number</A>
</UL>
<P><HR>
<A NAME="0067"><A NAME="IsChanException">
<A HREF="#0066" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0066" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0068" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>ChanExceptions - Channel exceptions identities</H4>
 
<P><PRE>TYPE
&nbsp;&nbsp;ChanExceptions&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;(wrongDevice,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;device&nbsp;specific&nbsp;operation&nbsp;on&nbsp;wrong&nbsp;device&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notAvailable,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;operation&nbsp;attempted&nbsp;is&nbsp;not&nbsp;available&nbsp;on&nbsp;the&nbsp;channel&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;skipAtEnd,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;attempt&nbsp;to&nbsp;skip&nbsp;data&nbsp;from&nbsp;a&nbsp;stream&nbsp;that&nbsp;has&nbsp;ended&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;softDeviceError,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;device&nbsp;specific&nbsp;recoverable&nbsp;error&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hardDeviceError,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;device&nbsp;specific&nbsp;non-recoverable&nbsp;error&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;textParseError,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;input&nbsp;data&nbsp;does&nbsp;not&nbsp;correspond&nbsp;to&nbsp;a&nbsp;character
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;line&nbsp;mark&nbsp;-&nbsp;optional&nbsp;detection&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notAChannel
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;given&nbsp;value&nbsp;does&nbsp;not&nbsp;identify&nbsp;a&nbsp;channel&nbsp;-
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;optional&nbsp;detection&nbsp;*)
&nbsp;&nbsp;&nbsp;);
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P><B>NOTE:</B> 
<P>The detection of the exceptions <TT>textParseError</TT> and <TT>notAChannel</TT> is implementation-defined. 
<P><HR>
<A NAME="0068"><A NAME="ChanException">
<A HREF="#0066" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0067" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0069" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>IsChanException - Query exceptional state</H4>
 
<P><PRE>PROCEDURE&nbsp;IsChanException&nbsp;():&nbsp;BOOLEAN;
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>If the calling coroutine is in the state of exceptional execution because of the raising of an exception from <TT>ChanExceptions</TT>, the function procedure <TT>IsChanException</TT> returns <TT>TRUE</TT>; otherwise it returns <TT>FALSE</TT>. 
<P><HR>
<A NAME="0069"><A NAME="DeviceErrNum">
<A HREF="#0066" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0068" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0070" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>ChanException - Query exception id</H4>
 
<P><PRE>PROCEDURE&nbsp;ChanException&nbsp;():&nbsp;ChanExceptions;
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>If the calling coroutine is in the state of exceptional execution because of the raising of an exception from <TT>ChanExceptions</TT>, the function procedure <TT>ChanException</TT> returns the value that identifies the raised exception; otherwise the language exception <TT>exException</TT> is raised. 
<P><HR>
<A NAME="0070"><A NAME="DeviceError">
<A HREF="#0066" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0069" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0071" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>DeviceErrNum - Device error number</H4>
 
<P><PRE>TYPE
&nbsp;&nbsp;DeviceErrNum&nbsp;=&nbsp;INTEGER;
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>Values of the type <TT>DeviceErrNum</TT> are used to identufy the implementation-defined error number for a chennel in the device exception handler. 
<P>See <TT><A HREF="#0071" TARGET=body>DeviceError</A></TT> procedure. 
<P><HR>
<A NAME="0071">
<A HREF="#0066" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0070" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0072" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>DeviceError - Get device error number</H4>
 
<P><PRE>PROCEDURE&nbsp;DeviceError&nbsp;(cid:&nbsp;ChanId):&nbsp;DeviceErrNum;
</PRE>

<P>Module <TT><A HREF="#0044" TARGET=body>IOChan</A></TT>
<P>The function procedure <TT>DeviceError</TT> returns the error number stored by the device module for the channel identified by <TT>cid</TT>, provided that a device error exception has been raised during an operation on that channel; otherwise the value of the call is not defined. 
<P><B>NOTE:</B> 
<P>When a device procedure detects a device error, it raises the exception <TT>softDeviceError</TT> or <TT>hardDeviceError</TT>. If these exceptions are handled, the procedure <TT>DeviceError</TT> may be used to discover the implementation-defined error number stored by the device module for the channel that was in use when the device error occurred. 
<P><HR>
<A NAME="0072">
<A HREF="#0000" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0071" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0073" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Obtaining Channels from Device Modules</H2>

<P>Separate device modules are defined that provide a program with the facility to obtain a new channel, connected either to a sequential stream, a rewindable sequential file, a random access file, or a terminal device. 
<P>A request to obtain a channel is made by calling an appropriate &lsquo;open procedure&rsquo;, in general supplying a name that identifies the source or destination to which the connection is to be made. 
<P>The required input/output operations are specified using combinations of flags that are defined in terms of constants imported from the module <TT><A HREF="#0073" TARGET=body>ChanConsts</A></TT>. 
<P>An open procedure returns a parameter of an enumeration type (exported from the module <TT><A HREF="#0073" TARGET=body>ChanConsts</A></TT>) that indicates the success, or otherwise, of the request. 
<P>Each of these device modules defines a predicate allowing a check to be made that a given channel was opened by that module, as well as a &lsquo;close procedure&rsquo; that allows a program to break the connection and release the channel. 
<P>Procedures are also provided for device-dependent operations, such as setting the read/write position on a random access file. 
<P>A further device module is defined to allow access to the program arguments over a pre-opened channel. 
<P><UL>
<LI><A HREF="#0073" TARGET=body>Module ChanConsts</A>
<LI><A HREF="#0078" TARGET=body>Module StreamFile</A>
<LI><A HREF="#0082" TARGET=body>Module SeqFile</A>
<LI><A HREF="#0090" TARGET=body>Module RndFile</A>
<LI><A HREF="#0101" TARGET=body>Module TermFile</A>
<LI><A HREF="#0105" TARGET=body>Module ProgramArgs</A>
</UL>
<P><HR>
<A NAME="0073"><A NAME="ChanFlags">
<A HREF="#0072" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0072" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0074" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Module ChanConsts</H3>

<P>The module <TT>ChanConsts</TT> defines common types and values for use with open procedures. Programs do not normally need to import from <TT>ChanConsts</TT> directly, since device modules define identifiers that correspond to those defined by this module. 
<P><UL>
<LI><A HREF="#0074" TARGET=body>ChanFlags - Channel open flags</A>
<LI><A HREF="#0075" TARGET=body>FlagSet - Channel open flags set</A>
<LI><A HREF="#0076" TARGET=body>OpenResults - Results of an open request</A>
<LI><A HREF="#0077" TARGET=body>The Use of ChanConsts</A>
</UL>
<P><HR>
<A NAME="0074"><A NAME="FlagSet">
<A HREF="#0073" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0073" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0075" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>ChanFlags - Channel open flags</H4>
 
<P><PRE>TYPE
&nbsp;&nbsp;ChanFlags&nbsp;=
&nbsp;&nbsp;(&nbsp;readFlag,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;input&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;writeFlag,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;output&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;oldFlag,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;a&nbsp;file&nbsp;may/must/did&nbsp;exist
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;before&nbsp;the&nbsp;channel&nbsp;is&nbsp;opened&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;textFlag,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;text&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;rawFlag,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;raw&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;interactiveFlag,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;interactive&nbsp;use&nbsp;is&nbsp;requested/applies&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;echoFlag
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;echoing&nbsp;by&nbsp;interactive&nbsp;device&nbsp;on&nbsp;removal&nbsp;of&nbsp;characters
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;input&nbsp;stream&nbsp;requested/applies&nbsp;*)
&nbsp;&nbsp;);
</PRE>

<P>Module <TT><A HREF="#0073" TARGET=body>ChanConsts</A></TT>
<P>The elements of the enumeration type <TT>ChanFlags</TT> identify channel <I>flags</I> that are specified when a channel is opened and can be obtained for an open channel. 
<P><B>NOTE:</B> 
<P>The type <TT><A HREF="#0075" TARGET=body>FlagSet</A></TT> is used in actual calls. 
<P><HR>
<A NAME="0075"><A NAME="OpenResults">
<A HREF="#0073" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0074" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0076" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>FlagSet - Channel open flags set</H4>
 
<P><PRE>&nbsp;&nbsp;FlagSet&nbsp;=&nbsp;SET&nbsp;OF&nbsp;ChanFlags;

CONST
&nbsp;&nbsp;read&nbsp;=&nbsp;FlagSet{readFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;input&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;write&nbsp;=&nbsp;FlagSet{writeFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;output&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;old&nbsp;=&nbsp;FlagSet{oldFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;a&nbsp;file&nbsp;may/must/did&nbsp;exist
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;before&nbsp;the&nbsp;channel&nbsp;is&nbsp;opened&nbsp;*)
&nbsp;&nbsp;text&nbsp;=&nbsp;FlagSet{textFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;text&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;raw&nbsp;=&nbsp;FlagSet{rawFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;raw&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;interactive&nbsp;=&nbsp;FlagSet{interactiveFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;interactive&nbsp;use&nbsp;is&nbsp;requested/applies&nbsp;*)
&nbsp;&nbsp;echo&nbsp;=&nbsp;FlagSet{echoFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;echoing&nbsp;by&nbsp;interactive&nbsp;device&nbsp;on&nbsp;removal&nbsp;of&nbsp;characters
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;input&nbsp;stream&nbsp;requested/applies&nbsp;*)
</PRE>

<P>Module <TT><A HREF="#0073" TARGET=body>ChanConsts</A></TT>
<P>Values of the type <TT>FlagSet</TT> are used in the calls to channel open procedures. Singleton values of <TT>FlagSet</TT> are provided for convinience. For example, <TT>read + write</TT> can be used instead of <TT>FlagSet{read,write}</TT>. 
<P><HR>
<A NAME="0076">
<A HREF="#0073" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0075" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0077" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>OpenResults - Results of an open request</H4>
 
<P><PRE>TYPE
&nbsp;&nbsp;OpenResults&nbsp;=
&nbsp;&nbsp;(&nbsp;opened,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;the&nbsp;open&nbsp;succeeded&nbsp;as&nbsp;requested&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;wrongNameFormat,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;given&nbsp;name&nbsp;is&nbsp;in&nbsp;the&nbsp;wrong&nbsp;format
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;the&nbsp;implementation&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;wrongFlags,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;given&nbsp;flags&nbsp;include&nbsp;a&nbsp;value
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that&nbsp;does&nbsp;not&nbsp;apply&nbsp;to&nbsp;the&nbsp;device&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;tooManyOpen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;this&nbsp;device&nbsp;cannot&nbsp;support&nbsp;any&nbsp;more&nbsp;open&nbsp;channels&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;outOfChans,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;no&nbsp;more&nbsp;channels&nbsp;can&nbsp;be&nbsp;allocated&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;wrongPermissions,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;file&nbsp;or&nbsp;directory&nbsp;permissions&nbsp;do&nbsp;not&nbsp;allow&nbsp;request&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;noRoomOnDevice,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;storage&nbsp;limits&nbsp;on&nbsp;the&nbsp;device&nbsp;prevent&nbsp;the&nbsp;open&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;noSuchFile,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;a&nbsp;needed&nbsp;file&nbsp;does&nbsp;not&nbsp;exist&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;fileExists,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;a&nbsp;file&nbsp;of&nbsp;the&nbsp;given&nbsp;name&nbsp;already&nbsp;exists
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when&nbsp;a&nbsp;new&nbsp;one&nbsp;is&nbsp;required&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;wrongFileType,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;the&nbsp;file&nbsp;is&nbsp;of&nbsp;the&nbsp;wrong&nbsp;type&nbsp;to&nbsp;support
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;required&nbsp;operations&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;noTextOperations,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;text&nbsp;operations&nbsp;have&nbsp;been&nbsp;requested,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;but&nbsp;are&nbsp;not&nbsp;supported&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;noRawOperations,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;raw&nbsp;operations&nbsp;have&nbsp;been&nbsp;requested,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;but&nbsp;are&nbsp;not&nbsp;supported&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;noMixedOperations,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;text&nbsp;and&nbsp;raw&nbsp;operations&nbsp;have&nbsp;been&nbsp;requested,&nbsp;but&nbsp;they
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;not&nbsp;supported&nbsp;in&nbsp;combination&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;alreadyOpen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;the&nbsp;source/destination&nbsp;is&nbsp;already&nbsp;open
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;operations&nbsp;not&nbsp;supported&nbsp;in&nbsp;combination
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;the&nbsp;requested&nbsp;operations&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;otherProblem
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;open&nbsp;failed&nbsp;for&nbsp;some&nbsp;other&nbsp;reason&nbsp;*)
&nbsp;&nbsp;);
</PRE>

<P>Module <TT><A HREF="#0073" TARGET=body>ChanConsts</A></TT>
<P>The elements of the enumeration type <TT>OpenResults</TT> identify possible results of an open request. 
<P><HR>
<A NAME="0077">
<A HREF="#0073" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0076" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0078" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>The Use of ChanConsts</H4>

<P>To save repetition in the natural language definition of the device modules, the meaning given to some values of <TT><A HREF="#0075" TARGET=body>FlagSet</A></TT> and <TT><A HREF="#0076" TARGET=body>OpenResults</A></TT> is defined here. The meaning of the other flags is given for the open operations to which they apply. 
<P>In a call of a device module open procedure that has a request parameter of the type <TT><A HREF="#0075" TARGET=body>FlagSet</A></TT> and a result parameter of the type <TT><A HREF="#0076" TARGET=body>OpenResults</A></TT>: 
<P>If the result is <TT>opened</TT>, the following operations are provided for the opened channel for the combinations of request flags shown: 
<P ALIGN=CENTER><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid solid;border-width: 1px 1px 1px 1px">&nbsp;</TD>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px"><TT>read </TT></TD>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px"><TT>write </TT></TD>
<TD  STYLE="padding:0px 3px;border-style: solid solid solid none;border-width: 1px 1px 1px 0px">&nbsp;</TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid none solid;border-width: 0px 1px 0px 1px"><TT>text </TT></TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">text input </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">text output </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid none none;border-width: 0px 1px 0px 0px">as defined for the device </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;border-style: none solid solid solid;border-width: 0px 1px 1px 1px"><TT>raw </TT></TD>
<TD  STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px">raw input </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px">raw output </TD>
<TD  STYLE="padding:0px 3px;border-style: none solid solid none;border-width: 0px 1px 1px 0px">as defined for the device </TD>
</TR>
</TABLE>
<P><B>NOTE:</B> 
<P>The supplied flags specify the minimal functionality that must be available for the open operation to succeed. Implementations are free to allow operations in addition to those specified in the request flags provided that these are reflected in the enquiry flags returned for the channel. 
<P>If the result is other than <TT>opened</TT>, the channel parameter is assigned the value identifying the invalid channel, on which no input/output operations are provided. The result is chosen according to the following table: 
<P ALIGN=CENTER><TABLE CELLSPACING=0>
<TR>
<TD  STYLE="padding:0px 3px;"><TT>wrongNameFormat </TT></TD>
<TD  STYLE="padding:0px 3px;">if the given name is not in the format defined for the implementation </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><TT>wrongFlags </TT></TD>
<TD  STYLE="padding:0px 3px;">if the given flags include a value that does not apply to the device </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><TT>tooManyOpen </TT></TD>
<TD  STYLE="padding:0px 3px;">if the device cannot support any more open channels </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><TT>outOfChans </TT></TD>
<TD  STYLE="padding:0px 3px;">if no more channels can be allocated </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><TT>wrongPermissions </TT></TD>
<TD  STYLE="padding:0px 3px;">if file or directory permissions do not allow the request to be met </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><TT>noRoomOnDevice </TT></TD>
<TD  STYLE="padding:0px 3px;">if storage limits on the device do not allow the request to be met </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><TT>noSuchFile </TT></TD>
<TD  STYLE="padding:0px 3px;">if a needed file does not exist </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><TT>fileExists </TT></TD>
<TD  STYLE="padding:0px 3px;">if a file of the given name already exists when a new one is required </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><TT>wrongFileType </TT></TD>
<TD  STYLE="padding:0px 3px;">if the named file is of the wrong type to support the required operations </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><TT>noTextOperations </TT></TD>
<TD  STYLE="padding:0px 3px;">if text operations have been requested, but are not supported by the device </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><TT>noRawOperations </TT></TD>
<TD  STYLE="padding:0px 3px;">if raw operations have been requested, but are not supported by the device </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><TT>noMixedOperations </TT></TD>
<TD  STYLE="padding:0px 3px;">if text and raw operations have been requested, but they are not supported in combination by the device </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><TT>alreadyOpen </TT></TD>
<TD  STYLE="padding:0px 3px;">if the source/destination is already open for operations that are not supported in combination with the operations now requested </TD>
</TR>
<TR>
<TD  STYLE="padding:0px 3px;"><TT>otherProblem </TT></TD>
<TD  STYLE="padding:0px 3px;">if the open failed for a reason other than the above </TD>
</TR>
</TABLE>
<P><HR>
<A NAME="0078"><A NAME="Open">
<A HREF="#0072" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0077" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0079" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Module StreamFile</H3>

<P>The module <TT>StreamFile</TT> provides facilities for obtaining and releasing channels that are connected to named sources and/or destinations for independent sequential data streams. 
<P>The types <TT>IOChan.ChanId</TT>, <TT>ChanConsts.FlagSet</TT>, and <TT>ChanConsts.OpenResults</TT> are re-expored. The singleton values of the type <TT>FlagSet</TT> are declared for convinience: 
<P><PRE>TYPE
&nbsp;&nbsp;ChanId&nbsp;=&nbsp;IOChan.ChanId;
&nbsp;&nbsp;FlagSet&nbsp;=&nbsp;ChanConsts.FlagSet;
&nbsp;&nbsp;OpenResults&nbsp;=&nbsp;ChanConsts.OpenResults;

CONST
&nbsp;&nbsp;read&nbsp;=&nbsp;FlagSet{ChanConsts.readFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;input&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;write&nbsp;=&nbsp;FlagSet{ChanConsts.writeFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;output&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;old&nbsp;=&nbsp;FlagSet{ChanConsts.oldFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;a&nbsp;file&nbsp;may/must/did&nbsp;exist
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;before&nbsp;the&nbsp;channel&nbsp;is&nbsp;opened&nbsp;*)
&nbsp;&nbsp;text&nbsp;=&nbsp;FlagSet{ChanConsts.textFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;text&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;raw&nbsp;=&nbsp;FlagSet{ChanConsts.rawFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;raw&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
</PRE>

<P>In a request to open a sequential stream, the flags <TT>read</TT>, <TT>write</TT>, <TT>old</TT>, <TT>text</TT>, and <TT>raw</TT> apply. If <TT>raw</TT> is not included in the request parameter <TT>flags</TT>, inclusion of <TT>text</TT> is implied. 
<P><UL>
<LI><A HREF="#0079" TARGET=body>Open - Open sequential stream</A>
<LI><A HREF="#0080" TARGET=body>IsStreamFile - Query whether stream is sequential</A>
<LI><A HREF="#0081" TARGET=body>Close - Close sequential stream</A>
</UL>
<P><HR>
<A NAME="0079"><A NAME="IsStreamFile">
<A HREF="#0078" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0078" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0080" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>Open - Open sequential stream</H4>
 
<P><PRE>PROCEDURE&nbsp;Open&nbsp;(VAR&nbsp;cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flags:&nbsp;FlagSet;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;res:&nbsp;OpenResults);
</PRE>

<P>Module <TT><A HREF="#0078" TARGET=body>StreamFile</A></TT>
<P>If successful, the procedure <TT>Open</TT> assigns to <TT>cid</TT> the identity of a channel that is connected to a sequential stream specified by <TT>name</TT>, and the value <TT>opened</TT> is assigned to <TT>res</TT>. 
<P>If <TT>write</TT> is not included in <TT>flags</TT>, inclusion of <TT>read</TT> is implied; if <TT>read</TT> is given or implied, inclusion of <TT>old</TT> is implied; a source of the given name has to already exist if the call is to succeed. 
<P>If <TT>write</TT> is included, a destination of the given name has to not already exist, unless the flag <TT>old</TT> is given or implied. 
<P>If a channel cannot be opened as required, the value of <TT>res</TT> indicates the reason, and <TT>cid</TT> identifies the invalid channel. 
<P><B>NOTE:</B> 
<P>Distinct modes in combination with <TT>text</TT> and/or <TT>raw</TT> are given by the following equivalent sets of flags: 
<UL>
 
<LI>read from an existing source: <TT>read</TT> <TT>old</TT> <TT>read+old</TT> </LI>
<LI>write to a new destination: <TT>write</TT> </LI>
<LI>write to a new or old destination: <TT>write+old</TT> </LI>
<LI>read/write an existing source/destination: <TT>read+write</TT> <TT>read+write+old</TT> </LI>
</UL>

<P><HR>
<A NAME="0080"><A NAME="Close">
<A HREF="#0078" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0079" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0081" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>IsStreamFile - Query whether stream is sequential</H4>
 
<P><PRE>PROCEDURE&nbsp;IsStreamFile&nbsp;(cid:&nbsp;ChanId):&nbsp;BOOLEAN;
</PRE>

<P>Module <TT><A HREF="#0078" TARGET=body>StreamFile</A></TT>
<P>The function procedure <TT>IsStreamFile</TT> returns <TT>TRUE</TT> if the channel identified by <TT>cid</TT> is open to a sequential stream, and <TT>FALSE</TT> otherwise. 
<P><HR>
<A NAME="0081">
<A HREF="#0078" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0080" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0082" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Close - Close sequential stream</H4>
 
<P><PRE>PROCEDURE&nbsp;Close&nbsp;(VAR&nbsp;cid:&nbsp;ChanId);
</PRE>

<P>Module <TT><A HREF="#0078" TARGET=body>StreamFile</A></TT>
<P>If the channel identified by <TT>cid</TT> is open to a sequential stream, the procedure <TT>Close</TT> closes the channel and assigns the value identifying the invalid channel to <TT>cid</TT>; otherwise, the exception <TT>wrongDevice</TT> is raised. 
<P><HR>
<A NAME="0082"><A NAME="OpenWrite">
<A HREF="#0072" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0081" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0083" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Module SeqFile</H3>

<P>The module <TT>SeqFile</TT> provides facilities for obtaining and releasing channels that are connected to named rewindable sequential stored files. 
<P>If opened for both writing and reading, data written to the file may be read back from the start of the file. Rewriting from the start of the file causes the previous contents to be lost. 
<P>The types <TT>IOChan.ChanId</TT>, <TT>ChanConsts.FlagSet</TT>, and <TT>ChanConsts.OpenResults</TT> are re-expored. The singleton values of the type <TT>FlagSet</TT> are declared for convinience: 
<P><PRE>TYPE
&nbsp;&nbsp;ChanId&nbsp;=&nbsp;IOChan.ChanId;
&nbsp;&nbsp;FlagSet&nbsp;=&nbsp;ChanConsts.FlagSet;
&nbsp;&nbsp;OpenResults&nbsp;=&nbsp;ChanConsts.OpenResults;

CONST
&nbsp;&nbsp;read&nbsp;=&nbsp;FlagSet{ChanConsts.readFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;input&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;write&nbsp;=&nbsp;FlagSet{ChanConsts.writeFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;output&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;old&nbsp;=&nbsp;FlagSet{ChanConsts.oldFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;a&nbsp;file&nbsp;may/must/did&nbsp;exist&nbsp;before&nbsp;the&nbsp;channel&nbsp;is&nbsp;opened&nbsp;*)
&nbsp;&nbsp;text&nbsp;=&nbsp;FlagSet{ChanConsts.textFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;text&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;raw&nbsp;=&nbsp;FlagSet{ChanConsts.rawFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;raw&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
</PRE>

<P>In a request to open a rewindable sequential file, the flags <TT>read</TT>, <TT>write</TT>, <TT>old</TT>, <TT>text</TT>, and <TT>raw</TT> apply. If <TT>raw</TT> is not included in the request parameter flags, inclusion of <TT>text</TT> is implied. 
<P>Channels open to rewindable sequential files may be in <I>input mode</I> or in <I>output mode</I>. In input mode, only input operations are available, <TT>&lsquo;(IOChan.Flags()*(read+write) = read)&rsquo;</TT> is true, and an attempt to write over the channel raises the exception <TT>notAvailable</TT>. In output mode, only output operations are available, <TT>&lsquo;(IOChan.Flags()*(read+write) = write)&rsquo;</TT> is true, and an attempt to read from the channel raises the exception <TT>notAvailable</TT>. All data written to a rewindable sequential file is appended to previous data written to that file. 
<P><UL>
<LI><A HREF="#0083" TARGET=body>OpenWrite - Open sequential file for writing</A>
<LI><A HREF="#0084" TARGET=body>OpenAppend - Open sequential file for appending</A>
<LI><A HREF="#0085" TARGET=body>OpenRead - Open sequential file for reading</A>
<LI><A HREF="#0086" TARGET=body>IsSeqFile - Query whether channel is open to a sequential file</A>
<LI><A HREF="#0087" TARGET=body>Reread - Rewind and select input mode</A>
<LI><A HREF="#0088" TARGET=body>Rewrite - Rewind and select output mode</A>
<LI><A HREF="#0089" TARGET=body>Close - Close sequential file</A>
</UL>
<P><HR>
<A NAME="0083"><A NAME="OpenAppend">
<A HREF="#0082" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0082" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0084" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>OpenWrite - Open sequential file for writing</H4>
 
<P><PRE>PROCEDURE&nbsp;OpenWrite&nbsp;(VAR&nbsp;cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flags:&nbsp;FlagSet;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;res:&nbsp;OpenResults);
</PRE>

<P>Module <TT><A HREF="#0082" TARGET=body>SeqFile</A></TT>
<P>If successful, the procedure <TT>OpenWrite</TT> assigns to <TT>cid</TT> the identity of a channel that is connected to a stored file specified by <TT>name</TT>; the value <TT>opened</TT> is assigned to <TT>res</TT>. Output mode is selected and the file is truncated to zero length. 
<P>Inclusion of the <TT>write</TT> flag in the parameter <TT>flags</TT> is implied. 
<P>If the call is to succeed, a destination of the given name has to not already exist unless the flag <TT>old</TT> is given; if the <TT>read</TT> flag is included in the request, the <TT><A HREF="#0087" TARGET=body>Reread</A></TT> operation is available. 
<P>The effect of a <TT>Reset</TT> operation on the channel is to truncate the file to zero length and to select output mode. 
<P>If a channel cannot be opened as required, the value of <TT>res</TT> indicates the reason, and <TT>cid</TT> identifies the invalid channel. 
<P><B>NOTE:</B> 
<P>Distinct modes in combination with <TT>text</TT> and/or <TT>raw</TT> are given by the following equivalent sets of flags: 
<UL>
 
<LI>write to a new file: <TT>write</TT> </LI>
<LI>write to a new file or a truncated existing file: <TT>old</TT> <TT>write+old</TT> </LI>
<LI>write to a new file, need read operations: <TT>write+read</TT> <TT>read</TT> </LI>
<LI>write to a new or existing file, need read operations: <TT>old+read</TT> <TT>write+old+read</TT> </LI>
</UL>

<P><HR>
<A NAME="0084"><A NAME="OpenRead">
<A HREF="#0082" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0083" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0085" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>OpenAppend - Open sequential file for appending</H4>
 
<P><PRE>PROCEDURE&nbsp;OpenAppend&nbsp;(VAR&nbsp;cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flags:&nbsp;FlagSet;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;res:&nbsp;OpenResults);
</PRE>

<P>Module <TT><A HREF="#0082" TARGET=body>SeqFile</A></TT>
<P>If successful, the procedure <TT>OpenAppend</TT> assigns to <TT>cid</TT> the identity of a channel that is connected to a stored file specified by <TT>name</TT>; the value <TT>opened</TT> is assigned to <TT>res</TT>. Output mode is selected. 
<P><B>Have to write something here.</B>
<P>Inclusion of the <TT>write</TT> and <TT>old</TT> flags in the parameter <TT>flags</TT> is implied; a destination of the given name may already exist. 
<P>If the <TT>read</TT> flag is included in the request, the <TT><A HREF="#0087" TARGET=body>Reread</A></TT> operation is available if the call is to succeed. 
<P>The effect of a <TT>Reset</TT> operation on the channel is to select output mode. 
<P>If a channel cannot be opened as required, the value of <TT>res</TT> indicates the reason, and <TT>cid</TT> identifies the invalid channel. 
<P><B>NOTE:</B> 
<P>Distinct modes in combination with <TT>text</TT> and/or <TT>raw</TT> are given by the following equivalent sets of flags: 
<UL>
 
<LI>write to a new or append to an existing file: <TT>write</TT> <TT>old</TT> <TT>write+old</TT> </LI>
<LI>write to a new or append to an existing file, need read operations: <TT>read</TT> <TT>write+read</TT> <TT>old+read</TT> <TT>write+old+read</TT> </LI>
</UL>

<P><HR>
<A NAME="0085"><A NAME="IsSeqFile">
<A HREF="#0082" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0084" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0086" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>OpenRead - Open sequential file for reading</H4>
 
<P><PRE>PROCEDURE&nbsp;OpenRead&nbsp;(VAR&nbsp;cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flags:&nbsp;FlagSet;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;res:&nbsp;OpenResults);
</PRE>

<P>Module <TT><A HREF="#0082" TARGET=body>SeqFile</A></TT>
<P>If successful, the procedure <TT>OpenRead</TT> assigns to <TT>cid</TT> the identity of a channel that is connected to a stored file specified by <TT>name</TT>; the value opened is assigned to <TT>res</TT>. Input mode is selected and the read position correspond to the start of the file. 
<P>Inclusion of the <TT>read</TT> and <TT>old</TT> flags in the parameter <TT>flags</TT> is implied; a destination of the given name has to already exist if the call is to succeed. 
<P>If the <TT>write</TT> flag is included in the request, the <TT><A HREF="#0088" TARGET=body>Rewrite</A></TT> operation is available if the call is to succeed. 
<P>The effect of a <TT>Reset</TT> operation on the channel is to select input mode and to set the read position to the start of the file. 
<P>If a channel cannot be opened as required, the value of <TT>res</TT> indicates the reason, and <TT>cid</TT> identifies the invalid channel. 
<P><B>NOTE:</B> 
<P>Distinct modes in combination with <TT>text</TT> and/or <TT>raw</TT> are given by the following equivalent sets of flags: 
<UL>
 
<LI>read from an existing file: <TT>read</TT> <TT>old</TT> <TT>read+old</TT> </LI>
<LI>read from an existing file, need write operations: <TT>write</TT> <TT>read+write</TT> <TT>old+write</TT> <TT>read+old+write</TT> </LI>
</UL>

<P><HR>
<A NAME="0086"><A NAME="Reread">
<A HREF="#0082" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0085" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0087" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>IsSeqFile - Query whether channel is open to a sequential file</H4>
 
<P><PRE>PROCEDURE&nbsp;IsSeqFile&nbsp;(cid:&nbsp;ChanId):&nbsp;BOOLEAN;
</PRE>

<P>Module <TT><A HREF="#0082" TARGET=body>SeqFile</A></TT>
<P>The function procedure <TT>IsSeqFile</TT> returns <TT>TRUE</TT> if the channel identified by <TT>cid</TT> is open to a rewindable sequential file, and <TT>FALSE</TT> otherwise. 
<P><HR>
<A NAME="0087"><A NAME="Rewrite">
<A HREF="#0082" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0086" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0088" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>Reread - Rewind and select input mode</H4>
 
<P><PRE>PROCEDURE&nbsp;Reread&nbsp;(cid:&nbsp;ChanId);
</PRE>

<P>Module <TT><A HREF="#0082" TARGET=body>SeqFile</A></TT>
<P>If the channel identified by <TT>cid</TT> is open to a rewindable sequential file, the procedure <TT>Reread</TT> attempts to set the read position of the channel to the start of the file, and to select input mode; otherwise, the exception <TT>wrongDevice</TT> is raised. 
<P>If the operation cannot be performed, perhaps because of insufficient permissions, neither input mode nor output mode are selected. 
<P><HR>
<A NAME="0088"><A NAME="Close">
<A HREF="#0082" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0087" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0089" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>Rewrite - Rewind and select output mode</H4>
 
<P><PRE>PROCEDURE&nbsp;Rewrite&nbsp;(cid:&nbsp;ChanId);
</PRE>

<P>Module <TT><A HREF="#0082" TARGET=body>SeqFile</A></TT>
<P>If the channel identified by <TT>cid</TT> is open to a rewindable sequential file, the procedure <TT>Rewrite</TT> attempts to set the write position of the channel to the start of the file, to truncate the file to zero length, and to select output mode; otherwise, the exception <TT>wrongDevice</TT> is raised. 
<P>If the operation cannot be performed, perhaps because of insufficient permissions, neither input mode nor output mode are selected. 
<P><HR>
<A NAME="0089">
<A HREF="#0082" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0088" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0090" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Close - Close sequential file</H4>
 
<P><PRE>PROCEDURE&nbsp;Close&nbsp;(VAR&nbsp;cid:&nbsp;ChanId);
</PRE>

<P>Module <TT><A HREF="#0082" TARGET=body>SeqFile</A></TT>
<P>If the channel identified by <TT>cid</TT> is open to a rewindable sequential file, the procedure <TT>Close</TT> closes the channel and assigns the value identifying the invalid channel to <TT>cid</TT>; otherwise, the exception <TT>wrongDevice</TT> is raised. 
<P><HR>
<A NAME="0090"><A NAME="OpenOld">
<A HREF="#0072" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0089" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0091" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Module RndFile</H3>

<P>The module <TT>RndFile</TT> provides facilities for obtaining and releasing channels that are connected to named random access files. 
<P>The types <TT>IOChan.ChanId</TT>, <TT>ChanConsts.FlagSet</TT>, and <TT>ChanConsts.OpenResults</TT> are re-expored. The singleton values of the type <TT>FlagSet</TT> are declared for convinience: 
<P><PRE>TYPE
&nbsp;&nbsp;ChanId&nbsp;=&nbsp;IOChan.ChanId;
&nbsp;&nbsp;FlagSet&nbsp;=&nbsp;ChanConsts.FlagSet;
&nbsp;&nbsp;OpenResults&nbsp;=&nbsp;ChanConsts.OpenResults;

CONST
&nbsp;&nbsp;read&nbsp;=&nbsp;FlagSet{ChanConsts.readFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;input&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;write&nbsp;=&nbsp;FlagSet{ChanConsts.writeFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;output&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;old&nbsp;=&nbsp;FlagSet{ChanConsts.oldFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;a&nbsp;file&nbsp;may/must/did&nbsp;exist&nbsp;before&nbsp;the&nbsp;channel&nbsp;is&nbsp;opened&nbsp;*)
&nbsp;&nbsp;text&nbsp;=&nbsp;FlagSet{ChanConsts.textFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;text&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;raw&nbsp;=&nbsp;FlagSet{ChanConsts.rawFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;raw&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)

</PRE>

<P>Channels opened by the module <TT>RndFile</TT> have an associated read/write position in the corresponding random-access file. The read/write position is at the start of the file after opening, or after a <TT>Reset</TT> operation on the channel. It is moved forward by the number of positions occupied by data that are taken from the file by an input operation, or written to the file by an output operation. 
<P><PRE>CONST
&nbsp;&nbsp;FilePosSize&nbsp;=&nbsp;&lt;implementation-defined&nbsp;whole
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number&nbsp;greater&nbsp;than&nbsp;zero&gt;;

TYPE
&nbsp;&nbsp;FilePos&nbsp;=&nbsp;ARRAY&nbsp;[1&nbsp;..&nbsp;FilePosSize]&nbsp;OF&nbsp;SYSTEM.LOC;
</PRE>

<P><B>NOTE</B>: 
<P>The implementation-defined type <TT>FilePos</TT> has been specified in a way that enables values of this type to be read from or written to a file, while maintaining a degree of opacity for the type. 
<P>A random-access file have a length corresponding to the position after the highest read/write position at which data have been written. This length is zero if no data have been written to the file. If the read/write position is set at the current length, either implicitly on an input or output operation, or explicitly by a positioning operation, the effect of an input operation is as if the input stream had ended. A write at that position, if necessary, attempts to allocate more physical storage for the file. 
<P>In a request to open a random-access file, the flags <TT>read</TT>, <TT>write</TT>, <TT>old</TT>, <TT>text</TT>, and <TT>raw</TT> apply. If <TT>text</TT> is not included in the request parameter flags, inclusion of <TT>raw</TT> is implied. 
<P><UL>
<LI><A HREF="#0091" TARGET=body>OpenOld - Open existing random-aceess file</A>
<LI><A HREF="#0092" TARGET=body>OpenClean - Open and clear random-aceess file</A>
<LI><A HREF="#0093" TARGET=body>IsRndFile - Query whether channel is open to a random access file</A>
<LI><A HREF="#0094" TARGET=body>IsRndFileException - Query exceptional state</A>
<LI><A HREF="#0095" TARGET=body>StartPos - Query start position</A>
<LI><A HREF="#0096" TARGET=body>CurrentPos - Query current position</A>
<LI><A HREF="#0097" TARGET=body>EndPos - Query end position</A>
<LI><A HREF="#0098" TARGET=body>NewPos - Calculate new position</A>
<LI><A HREF="#0099" TARGET=body>SetPos - Set new position</A>
<LI><A HREF="#0100" TARGET=body>Close - Close random access file</A>
</UL>
<P><HR>
<A NAME="0091"><A NAME="OpenClean">
<A HREF="#0090" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0090" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0092" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>OpenOld - Open existing random-aceess file</H4>
 
<P><PRE>PROCEDURE&nbsp;OpenOld&nbsp;(VAR&nbsp;cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flags:&nbsp;FlagSet;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;res:&nbsp;OpenResults);
</PRE>

<P>Module <TT><A HREF="#0090" TARGET=body>RndFile</A></TT>
<P>If successful, the procedure <TT>OpenOld</TT> assigns to <TT>cid</TT> the identity of a channel that is connected to a random access file specified by <TT>name</TT>; the value opened is assigned to <TT>res</TT>. The read/write position correspond to the start of the file. 
<P>Inclusion of the <TT>old</TT> flag in the parameter flags is implied; a file of the given name have to already exist if the call is to succeed. 
<P>If the <TT>write</TT> flag is not included in the request, inclusion of the <TT>read</TT> flag is implied. 
<P>If a channel cannot be opened as required, the value of <TT>res</TT> indicates the reason, and <TT>cid</TT> identifies the invalid channel. 
<P><B>NOTE:</B> 
<P>Distinct modes in combination with <TT>text</TT> and/or <TT>raw</TT> are given by the following equivalent sets of flags: 
<UL>
 
<LI>read from an existing file: <TT>read</TT> <TT>old</TT> <TT>read+old</TT> </LI>
<LI>write to an existing file: <TT>write</TT> <TT>write+old</TT> </LI>
<LI>read/write an existing file: <TT>read+write</TT> <TT>read+write+old</TT> </LI>
</UL>

<P><HR>
<A NAME="0092"><A NAME="IsRndFile">
<A HREF="#0090" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0091" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0093" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>OpenClean - Open and clear random-aceess file</H4>
 
<P><PRE>PROCEDURE&nbsp;OpenClean&nbsp;(VAR&nbsp;cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flags:&nbsp;FlagSet;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;res:&nbsp;OpenResults);
</PRE>

<P>Module <TT><A HREF="#0090" TARGET=body>RndFile</A></TT>
<P>If successful, the procedure <TT>OpenClean</TT> assigns to <TT>cid</TT> the identity of a channel that is connected to a random access file specified by <TT>name</TT>; the value <TT>opened</TT> is assigned to <TT>res</TT>. The file is truncated to zero length. 
<P>Inclusion of the <TT>write</TT> flag in the parameter flags is implied; a destination of the given name has to not already exist unless the flag <TT>old</TT> is given. 
<P>If a channel cannot be opened as required, the value of <TT>res</TT> indicates the reason, and <TT>cid</TT> identifies the invalid channel. 
<P><B>NOTE:</B> 
<P>Distinct modes in combination with <TT>text</TT> and/or <TT>raw</TT> are given by the following equivalent sets of flags: 
<UL>
 
<LI>write to a new file: <TT>write</TT> </LI>
<LI>write to a new file or a truncated existing file: <TT>old</TT> <TT>write+old</TT> </LI>
<LI>write to a new file, read operations are needed: <TT>read</TT> <TT>write+read</TT> </LI>
<LI>write to a new file or a truncated existing file, read operations are needed: <TT>old+read</TT> <TT>write+old+read</TT> </LI>
</UL>

<P><HR>
<A NAME="0093"><A NAME="IsRndFileException">
<A HREF="#0090" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0092" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0094" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>IsRndFile - Query whether channel is open to a random access file</H4>
 
<P><PRE>PROCEDURE&nbsp;IsRndFile&nbsp;(cid:&nbsp;ChanId):&nbsp;BOOLEAN;
</PRE>

<P>Module <TT><A HREF="#0090" TARGET=body>RndFile</A></TT>
<P>The function procedure <TT>IsRndFile</TT> returns <TT>TRUE</TT> if the channel identified by <TT>cid</TT> is open to a random access file, and <TT>FALSE</TT> otherwise. 
<P><HR>
<A NAME="0094"><A NAME="StartPos">
<A HREF="#0090" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0093" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0095" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>IsRndFileException - Query exceptional state</H4>
 
<P><PRE>PROCEDURE&nbsp;IsRndFileException&nbsp;():&nbsp;BOOLEAN;
</PRE>

<P>Module <TT><A HREF="#0090" TARGET=body>RndFile</A></TT>
<P>If the calling coroutine is in the state of exceptional execution because of the raising of the <TT><A HREF="#0090" TARGET=body>RndFile</A></TT> exception, the function procedure <TT>IsRndFileException</TT> returns <TT>TRUE</TT>; otherwise it returns <TT>FALSE</TT>. 
<P><HR>
<A NAME="0095"><A NAME="CurrentPos">
<A HREF="#0090" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0094" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0096" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>StartPos - Query start position</H4>
 
<P><PRE>PROCEDURE&nbsp;StartPos&nbsp;(cid:&nbsp;ChanId):&nbsp;FilePos;
</PRE>

<P>Module <TT><A HREF="#0090" TARGET=body>RndFile</A></TT>
<P>If the channel identified by <TT>cid</TT> is open to a random access file, the function procedure <TT>StartPos</TT> returns the position of the start of the file; otherwise the exception <TT>wrongDevice</TT> is raised. 
<P><HR>
<A NAME="0096"><A NAME="EndPos">
<A HREF="#0090" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0095" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0097" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>CurrentPos - Query current position</H4>
 
<P><PRE>PROCEDURE&nbsp;CurrentPos&nbsp;(cid:&nbsp;ChanId):&nbsp;FilePos;
</PRE>

<P>Module <TT><A HREF="#0090" TARGET=body>RndFile</A></TT>
<P>If the channel identified by <TT>cid</TT> is open to a random access file, the function procedure <TT>CurrentPos</TT> returns the current read/write position of the file; otherwise the exception <TT>wrongDevice</TT> is raised. 
<P><HR>
<A NAME="0097"><A NAME="NewPos">
<A HREF="#0090" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0096" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0098" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>EndPos - Query end position</H4>
 
<P><PRE>PROCEDURE&nbsp;EndPos&nbsp;(cid:&nbsp;ChanId):&nbsp;FilePos;
</PRE>

<P>Module <TT><A HREF="#0090" TARGET=body>RndFile</A></TT>
<P>If the channel identified by <TT>cid</TT> is open to a random access file, the function procedure <TT>EndPos</TT> returns the first position in the file at or after which no data have been written; otherwise the exception <TT>wrongDevice</TT> is raised. 
<P><HR>
<A NAME="0098"><A NAME="SetPos">
<A HREF="#0090" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0097" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0099" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>NewPos - Calculate new position</H4>
 
<P><PRE>PROCEDURE&nbsp;NewPos&nbsp;(cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chunks:&nbsp;INTEGER;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chunkSize:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from:&nbsp;FilePos):&nbsp;FilePos;
</PRE>

<P>Module <TT><A HREF="#0090" TARGET=body>RndFile</A></TT>
<P>If the channel identified by <TT>cid</TT> is open to a random access file, the function procedure <TT>NewPos</TT> returns the read/write position <TT>chunks * chunkSize</TT> places relative to the position in the file given by the value of <TT>from</TT>; otherwise, the exception <TT>wrongDevice</TT> is raised. The <TT>RndFile</TT> exception is raised if the required position cannot be represented as a value of the type <TT>FilePos</TT>. 
<P><B>NOTE:</B> 
<P>Calculation of the position in a random access file at which to issue text operations is dependent upon knowledge of the external representation of text items in a particular file; the amount by which the read/write position is moved as a result of a text operation may vary depending upon the item that is read or written. For raw operations, the read/write position is always moved by a value equal to the storage size of variables of the type of the item read or written. 
<P><HR>
<A NAME="0099"><A NAME="Close">
<A HREF="#0090" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0098" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0100" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>SetPos - Set new position</H4>
 
<P><PRE>PROCEDURE&nbsp;SetPos&nbsp;(cid:&nbsp;ChanId;&nbsp;pos:&nbsp;FilePos);
</PRE>

<P>Module <TT><A HREF="#0090" TARGET=body>RndFile</A></TT>
<P>If the channel identified by <TT>cid</TT> is open to a random access file, the procedure <TT>SetPos</TT> sets the read/write position for the file to the position given by the value of <TT>pos</TT>; otherwise the exception <TT>wrongDevice</TT> is raised. 
<P>If the position given by the value of <TT>pos</TT> is beyond the value returned by a call of <TT>EndPos</TT>, <TT>&lsquo;read &lt;= IOChan.Flags()&rsquo;</TT> is false, and a call of an input operation raises the exception <TT>notAvailable</TT>; the value of <TT>&lsquo;write &lt;= IOChan.Flags()&rsquo;</TT> is implementation-defined and correspond to the availability of output operations in this case. If data are subsequently written at such a position, those positions that have not been written to are filled with implementation-defined padding values. 
<P><B>NOTE:</B> 
<P>Setting the read/write position beyond the value returned by <TT><A HREF="#0097" TARGET=body>EndPos</A></TT> does not of itself affect the size of the file. 
<P><HR>
<A NAME="0100">
<A HREF="#0090" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0099" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0101" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Close - Close random access file</H4>
 
<P><PRE>PROCEDURE&nbsp;Close&nbsp;(VAR&nbsp;cid:&nbsp;ChanId);
</PRE>

<P>Module <TT><A HREF="#0090" TARGET=body>RndFile</A></TT>
<P>If the channel identified by cid is open to a random access file, the procedure <TT>Close</TT> closes the channel and assign the value identifying the invalid channel to <TT>cid</TT>; otherwise, the exception <TT>wrongDevice</TT> is raised. 
<P><HR>
<A NAME="0101"><A NAME="Open">
<A HREF="#0072" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0100" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0102" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Module TermFile</H3>

<P>The module <TT>TermFile</TT> provides facilities that allow elementary access to an interactive terminal. 
<P>The types <TT>IOChan.ChanId</TT>, <TT>ChanConsts.FlagSet</TT>, and <TT>ChanConsts.OpenResults</TT> are re-expored. The singleton values of the type <TT>FlagSet</TT> are declared for convinience: 
<P><PRE>TYPE
&nbsp;&nbsp;ChanId&nbsp;=&nbsp;IOChan.ChanId;
&nbsp;&nbsp;FlagSet&nbsp;=&nbsp;ChanConsts.FlagSet;
&nbsp;&nbsp;OpenResults&nbsp;=&nbsp;ChanConsts.OpenResults;

CONST
&nbsp;&nbsp;read&nbsp;=&nbsp;FlagSet{ChanConsts.readFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;input&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;write&nbsp;=&nbsp;FlagSet{ChanConsts.writeFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;output&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;text&nbsp;=&nbsp;FlagSet{ChanConsts.textFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;text&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;raw&nbsp;=&nbsp;FlagSet{ChanConsts.rawFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;raw&nbsp;operations&nbsp;are&nbsp;requested/available&nbsp;*)
&nbsp;&nbsp;echo&nbsp;=&nbsp;FlagSet{ChanConsts.echoFlag};
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;echoing&nbsp;by&nbsp;interactive&nbsp;device&nbsp;on&nbsp;reading&nbsp;of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;characters&nbsp;from&nbsp;input&nbsp;stream&nbsp;requested/applies&nbsp;*)
</PRE>

<P>Channels connected to the terminal device are opened in <I>line mode</I> or in <I>single-character mode</I>. In line mode, items are echoed before being added to the input stream and are added a line at a time. In single character mode, items are added to the input stream as they are typed, and are echoed as they are removed from the input stream by a text read device operation, provided they have not already been echoed. 
<P>Typed characters are distributed between multiple channels according to the sequence of read requests. 
<P><B>NOTE:</B> 
<P>If all the channels open to the terminal are open in line mode, the terminal device operates exclusively in line mode; in that case, echoing might be performed by an underlying operating system. Similarly, if all the channels open to the terminal are open in single-character mode, the terminal device operates exclusively in single-character mode; in that case, echoing only occurs on reading from a channel and not on looking or skipping: this allows interactive input routines to suppress the echoing of unwanted or unexpected characters. 
<P>If an implementation allows it, there might be one or more channels open in line mode, and one or more channels open in single-character mode. In that case, echoing is postponed until the treatment of characters can be determined according to the sequence of calls of input operations. This behaviour allows programs that use the terminal in different modes to be written in a modular fashion, there being no need explicitly to save and restore the state of the terminal device. 
<P>In a request to open a channel to the terminal device, the flags <TT>read</TT>, <TT>write</TT>, <TT>text</TT>, <TT>raw</TT>, and <TT>echo</TT> apply. If <TT>raw</TT> is not included in the request parameter flags, inclusion of <TT>text</TT> is implied. If the <TT>read</TT> flag is not included in the request, inclusion of the <TT>write</TT> flag is implied. 
<P><UL>
<LI><A HREF="#0102" TARGET=body>Open - Open terminal</A>
<LI><A HREF="#0103" TARGET=body>IsTermFile - Query whether channel is opened to terminal</A>
<LI><A HREF="#0104" TARGET=body>Close - Close terminal</A>
</UL>
<P><HR>
<A NAME="0102"><A NAME="IsTermFile">
<A HREF="#0101" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0101" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0103" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>Open - Open terminal</H4>
 
<P><PRE>PROCEDURE&nbsp;Open&nbsp;(VAR&nbsp;cid:&nbsp;ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flags:&nbsp;FlagSet;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;res:&nbsp;OpenResults);
</PRE>

<P>Module <TT><A HREF="#0101" TARGET=body>TermFile</A></TT>
<P>If successful, the procedure <TT>Open</TT> assigns to <TT>cid</TT> the identity of a channel that is connected to the terminal device. 
<P>If the <TT>echo</TT> flag is included in the request, single-character mode is available if the call is to succeed and the channel operates in single-character mode. Without the <TT>echo</TT> flag, line mode is available if the call is to succeed and the channel operates in line mode. 
<P>If a channel cannot be opened as required, the value of <TT>res</TT> indicates the reason, and <TT>cid</TT> identifies the invalid channel. 
<P><HR>
<A NAME="0103"><A NAME="Close">
<A HREF="#0101" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0102" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0104" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>IsTermFile - Query whether channel is opened to terminal</H4>
 
<P><PRE>PROCEDURE&nbsp;IsTermFile&nbsp;(cid:&nbsp;ChanId):&nbsp;BOOLEAN;
</PRE>

<P>Module <TT><A HREF="#0101" TARGET=body>TermFile</A></TT>
<P>The function procedure <TT>IsTermFile</TT> returns <TT>TRUE</TT> if the channel identified by <TT>cid</TT> is open to the terminal device, and <TT>FALSE</TT> otherwise. 
<P><HR>
<A NAME="0104">
<A HREF="#0101" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0103" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0105" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>Close - Close terminal</H4>
 
<P><PRE>PROCEDURE&nbsp;Close&nbsp;(VAR&nbsp;cid:&nbsp;ChanId);
</PRE>

<P>Module <TT><A HREF="#0101" TARGET=body>TermFile</A></TT>
<P>If the channel identified by <TT>cid</TT> is open to the terminal device, the procedure <TT>Close</TT> closes the channel and assigns the value identifying the invalid channel to <TT>cid</TT>; otherwise, the exception <TT>wrongDevice</TT> is raised. 
<P><HR>
<A NAME="0105"><A NAME="ArgChan">
<A HREF="#0072" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0104" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0106" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Module ProgramArgs</H3>

<P>The module <TT>ProgramArgs</TT> provides a channel from which input can be taken from any arguments given to the program. 
<P><PRE>TYPE
&nbsp;&nbsp;ChanId&nbsp;=&nbsp;IOChan.ChanId;
</PRE>

<P>The initialization of the module <TT>ProgramArgs</TT> opens the channel from which the implementation-defined program arguments may be read. 
<P><UL>
<LI><A HREF="#0106" TARGET=body>ArgChan - Get program arguments channel id</A>
<LI><A HREF="#0107" TARGET=body>IsArgPresent - Query whether an argument is present</A>
<LI><A HREF="#0108" TARGET=body>NextArg - Skip to next argument</A>
</UL>
<P><HR>
<A NAME="0106"><A NAME="IsArgPresent">
<A HREF="#0105" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0105" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0107" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>ArgChan - Get program arguments channel id</H4>
 
<P><PRE>PROCEDURE&nbsp;ArgChan&nbsp;():&nbsp;ChanId;
</PRE>

<P>Module <TT><A HREF="#0105" TARGET=body>ProgramArgs</A></TT>
<P>The function procedure <TT>ArgChan</TT> returns a value identifying a channel from which the implementation-defined program arguments may be read. 
<P><HR>
<A NAME="0107"><A NAME="NextArg">
<A HREF="#0105" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0106" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0108" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>IsArgPresent - Query whether an argument is present</H4>
 
<P><PRE>PROCEDURE&nbsp;IsArgPresent&nbsp;():&nbsp;BOOLEAN;
</PRE>

<P>Module <TT><A HREF="#0105" TARGET=body>ProgramArgs</A></TT>
<P>The function procedure <TT>IsArgPresent</TT> returns <TT>TRUE</TT> if there is a current argument from which to read, and <TT>FALSE</TT> otherwise. 
<P>If there is no current argument, <TT>&lsquo;read &lt;= IOChan.Flags()&rsquo;</TT> is false, and attempting to read from the argument channel raises the exception <TT>notAvailable</TT>. 
<P><HR>
<A NAME="0108">
<A HREF="#0105" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0107" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0109" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>NextArg - Skip to next argument</H4>
 
<P><PRE>PROCEDURE&nbsp;NextArg&nbsp;();
</PRE>

<P>Module <TT><A HREF="#0105" TARGET=body>ProgramArgs</A></TT>
<P>After the call to the procedure <TT>NextArg</TT>, if there is another argument, subsequent input from the argument channel is taken from the start of that argument; otherwise a call of <TT><A HREF="#0107" TARGET=body>IsArgPresent</A></TT> returns <TT>FALSE</TT>. 
<P><B>NOTE:</B> 
<P>Provision of <TT>NextArg</TT> allows the treatment of arguments that contain spaces or line marks. 
<P><HR>
<A NAME="0109">
<A HREF="#0000" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0108" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0110" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H2>Interface to Channels for New Device Modules</H2>

<P>Additional device modules may be provided to allow the library to be used with other input sources and output destinations. These might include, for example, files opened with host-specific options or parameters or with host-specific behaviour, a windowing system, or a speech output device. 
<P><UL>
<LI><A HREF="#0110" TARGET=body>Module IOLink</A>
</UL>
<P><HR>
<A NAME="0110"><A NAME="AllocateDeviceId">
<A HREF="#0109" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0109" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0111" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Module IOLink</H3>

<P>The module <TT>IOLink</TT> provides facilities that allow a user to provide specialized device modules for use with channels, following the pattern of the rest of the library. 
<P>A device needs to identify itself in order to allow a check to be made that device-dependent operations are applied only for channels opened to that device. To this end, values of the hidden type <TT>DeviceId</TT> are used to identify new device modules, and are normally obtained by them during their initialization by a call to the procedure <TT><A HREF="#0111" TARGET=body>AllocateDeviceId</A></TT>. 
<P><PRE>TYPE
&nbsp;&nbsp;DeviceId;
</PRE>

<P>A device module procedure provided for opening a channel can obtain a new channel by calling the procedure <TT><A HREF="#0112" TARGET=body>MakeChan</A></TT>. If a channel is allocated, but the call of the device module open procedure is not successful for some reason, the device module should release the channel by calling the procedure <TT><A HREF="#0113" TARGET=body>UnMakeChan</A></TT>, and return the value identifying the invalid channel to its client. 
<P>A call to <TT><A HREF="#0113" TARGET=body>UnMakeChan</A></TT> is also made on a successful call of a device module procedure provided for closing a channel. 
<P>If a call of a device module &lsquo;open&rsquo; procedure is successful, then by calling the function procedure <TT><A HREF="#0114" TARGET=body>DeviceTablePtrValue</A></TT>, a device module can obtain a pointer (of the type <TT><A HREF="#0110" TARGET=body>DeviceTablePtr</A></TT>) to a &lsquo;device table&rsquo; (of a record type <TT><A HREF="#0110" TARGET=body>DeviceTable</A></TT>) for the channel. The fields of this record are initialized by <TT><A HREF="#0112" TARGET=body>MakeChan</A></TT>, but the procedure can then change any fields of the device table needed to install its own values for the device data, supported operations, and flags. 
<P>Device tables have: 
<OL>
 
<LI>a field in which the device module can store private data, </LI>
<LI>a field in which the value identifying the device module is stored, </LI>
<LI>a field in which the value identifying the channel is stored, </LI>
<LI>a field in which the read result is stored, </LI>
<LI>a field in which device error numbers are stored prior to the raising of a device error exception, </LI>
<LI>a field in which flags are stored indicating those which apply, </LI>
<LI>a field for each device procedure. </LI>
</OL>

<P>(The fields are initialized by <TT><A HREF="#0112" TARGET=body>MakeChan</A></TT> to the values shown in the definition module below.) 
<P>By calling the function procedure <TT><A HREF="#0115" TARGET=body>IsDevice</A></TT>, a device module can enquire whether it was responsible for opening a given channel. This allows it to implement a corresponding enquiry function that is exported from the device module itself. 
<P>Client modules may raise appropriate exceptions; to support this facility, the type <TT><A HREF="#0110" TARGET=body>DevExceptionRange</A></TT> and the procedure <TT><A HREF="#0116" TARGET=body>RAISEdevException</A></TT> can be used. 
<P><PRE>TYPE
&nbsp;&nbsp;DeviceTablePtr&nbsp;=&nbsp;POINTER&nbsp;TO&nbsp;DeviceTable;
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Values&nbsp;of&nbsp;this&nbsp;type&nbsp;are&nbsp;used&nbsp;to&nbsp;refer&nbsp;to&nbsp;device&nbsp;tables&nbsp;*)

TYPE
&nbsp;&nbsp;LookProc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;PROCEDURE&nbsp;(DeviceTablePtr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;CHAR,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;IOConsts.ReadResults);
&nbsp;&nbsp;SkipProc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;PROCEDURE&nbsp;(DeviceTablePtr);
&nbsp;&nbsp;SkipLookProc&nbsp;&nbsp;=&nbsp;PROCEDURE&nbsp;(DeviceTablePtr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;CHAR,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;IOConsts.ReadResults);
&nbsp;&nbsp;WriteLnProc&nbsp;&nbsp;&nbsp;=&nbsp;PROCEDURE&nbsp;(DeviceTablePtr);
&nbsp;&nbsp;TextReadProc&nbsp;&nbsp;=&nbsp;PROCEDURE&nbsp;(DeviceTablePtr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SYSTEM.ADDRESS,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CARDINAL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;CARDINAL);
&nbsp;&nbsp;TextWriteProc&nbsp;=&nbsp;PROCEDURE&nbsp;(DeviceTablePtr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SYSTEM.ADDRESS,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CARDINAL);
&nbsp;&nbsp;RawReadProc&nbsp;&nbsp;&nbsp;=&nbsp;PROCEDURE&nbsp;(DeviceTablePtr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SYSTEM.ADDRESS,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CARDINAL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;CARDINAL);
&nbsp;&nbsp;RawWriteProc&nbsp;&nbsp;=&nbsp;PROCEDURE&nbsp;(DeviceTablePtr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SYSTEM.ADDRESS,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CARDINAL);
&nbsp;&nbsp;GetNameProc&nbsp;&nbsp;&nbsp;=&nbsp;PROCEDURE&nbsp;(DeviceTablePtr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
&nbsp;&nbsp;ResetProc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;PROCEDURE&nbsp;(DeviceTablePtr);
&nbsp;&nbsp;FlushProc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;PROCEDURE&nbsp;(DeviceTablePtr);
&nbsp;&nbsp;FreeProc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;PROCEDURE&nbsp;(DeviceTablePtr);
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Carry&nbsp;out&nbsp;the&nbsp;operations&nbsp;involved&nbsp;in&nbsp;closing
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;corresponding&nbsp;channel,&nbsp;including&nbsp;flushing&nbsp;buffers,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;but&nbsp;do&nbsp;not&nbsp;unmake&nbsp;the&nbsp;channel.
&nbsp;&nbsp;&nbsp;&nbsp;*)

TYPE
&nbsp;&nbsp;DeviceData&nbsp;=&nbsp;SYSTEM.ADDRESS;

DeviceTable&nbsp;=
&nbsp;&nbsp;RECORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;Initialized&nbsp;by&nbsp;MakeChan&nbsp;to:&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;cd:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeviceData;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;the&nbsp;value&nbsp;NIL&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;did:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeviceId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;the&nbsp;value&nbsp;given&nbsp;in&nbsp;the&nbsp;call&nbsp;of&nbsp;MakeChan&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;cid:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;the&nbsp;identity&nbsp;of&nbsp;the&nbsp;channel&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;result:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IOConsts.ReadResults;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;the&nbsp;value&nbsp;notKnown&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;errNum:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IOChan.DeviceErrNum;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;undefined&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;flags:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChanConsts.FlagSet;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;ChanConsts.FlagSet{}&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;doLook:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LookProc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;raise&nbsp;exception&nbsp;notAvailable&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;doSkip:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SkipProc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;raise&nbsp;exception&nbsp;notAvailable&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;doSkipLook:&nbsp;&nbsp;SkipLookProc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;raise&nbsp;exception&nbsp;notAvailable&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;doLnWrite:&nbsp;&nbsp;&nbsp;WriteLnProc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;raise&nbsp;exception&nbsp;notAvailable&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;doTextRead:&nbsp;&nbsp;TextReadProc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;raise&nbsp;exception&nbsp;notAvailable&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;doTextWrite:&nbsp;TextWriteProc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;raise&nbsp;exception&nbsp;notAvailable&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;doRawRead:&nbsp;&nbsp;&nbsp;RawReadProc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;raise&nbsp;exception&nbsp;notAvailable&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;doRawWrite:&nbsp;&nbsp;RawWriteProc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;raise&nbsp;exception&nbsp;notAvailable&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;doGetName:&nbsp;&nbsp;&nbsp;GetNameProc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;return&nbsp;the&nbsp;empty&nbsp;string&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;doReset:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ResetProc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;do&nbsp;nothing&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;doFlush:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FlushProc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;do&nbsp;nothing&nbsp;*)
&nbsp;&nbsp;&nbsp;&nbsp;doFree:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FreeProc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;do&nbsp;nothing&nbsp;*)
&nbsp;&nbsp;END;

TYPE
&nbsp;&nbsp;DevExceptionRange&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;z[IOChan.notAvailable&nbsp;..&nbsp;IOChan.textParseError];
</PRE>

<P><UL>
<LI><A HREF="#0111" TARGET=body>AllocateDeviceId - Allocate device id</A>
<LI><A HREF="#0112" TARGET=body>MakeChan - Allocate a new channel for device</A>
<LI><A HREF="#0113" TARGET=body>UnMakeChan - Deallocate channel from device</A>
<LI><A HREF="#0114" TARGET=body>DeviceTablePtrValue - Get device table for channel</A>
<LI><A HREF="#0115" TARGET=body>IsDevice - Query channel&rsquo;s device</A>
<LI><A HREF="#0116" TARGET=body>RAISEdevException - Raise device exception</A>
<LI><A HREF="#0117" TARGET=body>IsIOException - Query exceptional state</A>
<LI><A HREF="#0118" TARGET=body>IOException - Query exception id</A>
</UL>
<P><HR>
<A NAME="0111"><A NAME="MakeChan">
<A HREF="#0110" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0110" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0112" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>AllocateDeviceId - Allocate device id</H4>
 
<P><PRE>PROCEDURE&nbsp;AllocateDeviceId&nbsp;(VAR&nbsp;did:&nbsp;DeviceId);
</PRE>

<P>Module <TT><A HREF="#0110" TARGET=body>IOLink</A></TT>
<P>The procedure <TT>AllocateDeviceId</TT> allocates an unique value of the type <TT>DeviceId</TT>, and assign this value to <TT>did</TT>. 
<P><HR>
<A NAME="0112"><A NAME="UnMakeChan">
<A HREF="#0110" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0111" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0113" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>MakeChan - Allocate a new channel for device</H4>
 
<P><PRE>PROCEDURE&nbsp;MakeChan&nbsp;(did:&nbsp;DeviceId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;cid:&nbsp;IOChan.ChanId);
</PRE>

<P>Module <TT><A HREF="#0110" TARGET=body>IOLink</A></TT>
<P>The procedure <TT>MakeChan</TT> attempts to allocate a new channel for the device module identified by <TT>did</TT>. If no more channels can be allocated, the value identifying the invalid channel is assigned to <TT>cid</TT>. Otherwise, a value identifying a new initialized channel is assigned to <TT>cid</TT>. 
<P><HR>
<A NAME="0113"><A NAME="DeviceTablePtrValue">
<A HREF="#0110" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0112" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0114" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>UnMakeChan - Deallocate channel from device</H4>
 
<P><PRE>PROCEDURE&nbsp;UnMakeChan&nbsp;(did:&nbsp;DeviceId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;cid:&nbsp;IOChan.ChanId);
</PRE>

<P>Module <TT><A HREF="#0110" TARGET=body>IOLink</A></TT>
<P>Provided the device module identified by <TT>did</TT> is the module that made the channel identified by <TT>cid</TT>, the procedure <TT>UnMakeChan</TT> deallocates the channel identified by <TT>cid</TT>, and assigns the value identifying the invalid channel to <TT>cid</TT>; otherwise the exception <TT>wrongDevice</TT> is raised. 
<P><HR>
<A NAME="0114"><A NAME="IsDevice">
<A HREF="#0110" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0113" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0115" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>DeviceTablePtrValue - Get device table for channel</H4>
 
<P><PRE>PROCEDURE&nbsp;DeviceTablePtrValue&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;did:&nbsp;DeviceId
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;):&nbsp;DeviceTablePtr;
</PRE>

<P>Module <TT><A HREF="#0110" TARGET=body>IOLink</A></TT>
<P>Provided that the device module identified by <TT>did</TT> is the module that made the channel identified by <TT>cid</TT>, the function procedure <TT>DeviceTablePtrValue</TT> returns a pointer to the device table for the channel identified by <TT>cid</TT>; otherwise the exception <TT>wrongDevice</TT> is raised. 
<P><HR>
<A NAME="0115"><A NAME="RAISEdevException">
<A HREF="#0110" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0114" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0116" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>IsDevice - Query channel&rsquo;s device</H4>
 
<P><PRE>PROCEDURE&nbsp;IsDevice&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;did:&nbsp;DeviceId
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;):&nbsp;BOOLEAN;
</PRE>

<P>Module <TT><A HREF="#0110" TARGET=body>IOLink</A></TT>
<P>The function procedure <TT>IsDevice</TT> returns <TT>TRUE</TT> if the device module identified by <TT>did</TT> is the module that made the channel identified by <TT>cid</TT>, and otherwise returns <TT>FALSE</TT>. 
<P><HR>
<A NAME="0116"><A NAME="IsIOException">
<A HREF="#0110" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0115" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0117" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>RAISEdevException - Raise device exception</H4>
 
<P><PRE>PROCEDURE&nbsp;RAISEdevException&nbsp;(cid:&nbsp;IOChan.ChanId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;did:&nbsp;DeviceId;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x:&nbsp;DevExceptionRange;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
</PRE>

<P>Module <TT><A HREF="#0110" TARGET=body>IOLink</A></TT>
<P>Provided that the device module identified by <TT>did</TT> is the module that made the channel identified by <TT>cid</TT>, the procedure <TT>RAISEdevException</TT> raises the exception given by <TT>x</TT>, and includes the string value in <TT>s</TT> in the exception message; otherwise the exception <TT>wrongDevice</TT> is raised. 
<P><HR>
<A NAME="0117"><A NAME="IOException">
<A HREF="#0110" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0116" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0118" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H4>IsIOException - Query exceptional state</H4>
 
<P><PRE>PROCEDURE&nbsp;IsIOException&nbsp;():&nbsp;BOOLEAN;
</PRE>

<P>Module <TT><A HREF="#0110" TARGET=body>IOLink</A></TT>
<P>If the calling coroutine is in the state of exceptional execution because of the raising of an exception from <TT>IOChan.ChanExceptions</TT>, the function procedure <TT>IsIOException</TT> returns <TT>TRUE</TT>; otherwise it returns <TT>FALSE</TT>. 
<P><HR>
<A NAME="0118">
<A HREF="#0110" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0117" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="isolib002.html#0119" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H4>IOException - Query exception id</H4>
 
<P><PRE>PROCEDURE&nbsp;IOException&nbsp;():&nbsp;IOChan.ChanExceptions;
</PRE>

<P>Module <TT><A HREF="#0110" TARGET=body>IOLink</A></TT>
<P>If the calling coroutine is in the state of exceptional execution because of the raising of an exception from <TT>IOChan.ChanExceptions</TT>, the function procedure <TT>IOException</TT> returns the value that identifies the raised exception; otherwise the language exception <TT>exException</TT> is raised. 
<P><B>NOTE:</B> 
<P>A single value of <TT>EXCEPTIONS.ExceptionSource</TT> is used to identify the source of input/output library exceptions corresponding to <TT>IOChan.ChanExceptions</TT>. The procedures <TT>IsIOException</TT> and <TT>IOException</TT> are included so that this value need not be exported for corresponding procedures to be provided through the <TT>IOChan</TT> interface. 
<P>
</BODY>
</HTML>
