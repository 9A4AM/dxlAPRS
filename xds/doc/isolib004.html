<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>String Manipulation</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<P><HR>
<A NAME="0180">
<A HREF="isolib000.html#root" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="isolib003.html#0179" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0181" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H1>String Manipulation</H1>

<P><UL>
<LI><A HREF="#0181" TARGET=body>Module Strings</A>
</UL>
<P><HR>
<A NAME="0181"><A NAME="Length">
<A HREF="#0180" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0180" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0182" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H2>Module Strings</H2>

<P>The module <TT>Strings</TT> provides facilities for manipulating character arrays as representations of strings. The procedures provided accept any character array type, but manipulate all as if their index types were whole numbers and zero-based. 
<P>The module also provides predicates that check whether an operation to assign, delete, insert, replace or append strings or characters will work without loss of information. These predicates check that parameters indexing the concrete representation of a string (i.e. the character array containing the string value) fall within its length, thereby allowing the programmer to maintain the string abstraction. 
<P>A general-purpose string type <TT>String1</TT> is provided for convenience when handling single characters by using a value constructor. An enumeration type <TT>CompareResults</TT> is provided for use when comparing string values: 
<P><PRE>TYPE
&nbsp;&nbsp;String1&nbsp;=&nbsp;ARRAY&nbsp;[0..0]&nbsp;OF&nbsp;CHAR;

&nbsp;&nbsp;CompareResults&nbsp;=&nbsp;(less,&nbsp;equal,&nbsp;greater);
</PRE>

<P><B>NOTES:</B> 
<UL>
 
<LI>The procedures provided accept any character array type (i.e. with any index type) but because of the use of open array parameters the procedures manipulate all as if their index types were whole numbers and zero-based. </LI>
<LI>The array type <TT>String1</TT> may be used as the array type identifier of an array constructor when constructing an array value from a value of the character type. The constructed array value may be used as actual parameter in calls of procedures having a formal open array value parameter, for example to assign, insert, replace, append, concatenate, or find a single character. </LI>
<LI>Since function procedures cannot return open arrays, many of the operations that might more logically have been provided as function procedures have to be provided as proper procedures. </LI>
<LI>Predicates with the prefix &lsquo;<TT>Can</TT>&rsquo; and the suffix &lsquo;<TT>All</TT>&rsquo; are provided to check the operation-completion condition of string operations (e.g. <TT><A HREF="#0189" TARGET=body>CanInsertAll</A></TT> checks the operation-completion condition for <TT><A HREF="#0190" TARGET=body>Insert</A></TT>). Failure to satisfy the operation-completion condition of a string handling procedure does not lead to an exception; i.e. the semantics of string operations are defined for all well-formed parameters. </LI>
<LI>Value parameters are used where a string value is not changed by a procedure. This is not just a matter of programming clarity, but allows the parameterization of programs using constants. </LI>
<LI>Because string constants cannot be assigned to, nor appended to, nor have characters replaced or inserted, the predicates that test the operation completion conditions of procedures use VAR-parameters for the string parameters. </LI>
<LI>The International Standard has not adopted a change to Modula-2 (described in the fourth edition of <I>Programming in Modula-2</I>) of always requiring a string terminator for a string value. </LI>
</UL>

<P><UL>
<LI><A HREF="#0182" TARGET=body>Length - Query string length</A>
<LI><A HREF="#0183" TARGET=body>CanAssignAll - Check whether Assign will succeed</A>
<LI><A HREF="#0184" TARGET=body>Assign - Assign string value</A>
<LI><A HREF="#0185" TARGET=body>CanExtractAll - Check whether Extract will succeed</A>
<LI><A HREF="#0186" TARGET=body>Extract - Extract substring</A>
<LI><A HREF="#0187" TARGET=body>CanDeleteAll - Check whether Delete will succeed</A>
<LI><A HREF="#0188" TARGET=body>Delete - Delete substring</A>
<LI><A HREF="#0189" TARGET=body>CanInsertAll - Check whether Insert will succeed</A>
<LI><A HREF="#0190" TARGET=body>Insert - Insert substring</A>
<LI><A HREF="#0191" TARGET=body>CanReplaceAll - Check whether Replace will succeed</A>
<LI><A HREF="#0192" TARGET=body>Replace - Replace substring</A>
<LI><A HREF="#0193" TARGET=body>CanAppendAll - Check whether Append will succeed</A>
<LI><A HREF="#0194" TARGET=body>Append - Append string</A>
<LI><A HREF="#0195" TARGET=body>CanConcatAll - Check whether Concat will succeed</A>
<LI><A HREF="#0196" TARGET=body>Concat - Concatenate strings</A>
<LI><A HREF="#0197" TARGET=body>Capitalize - Capitalize string</A>
<LI><A HREF="#0198" TARGET=body>Compare - Compare strings</A>
<LI><A HREF="#0199" TARGET=body>Equal - Compare strings</A>
<LI><A HREF="#0200" TARGET=body>FindNext - Search string forward</A>
<LI><A HREF="#0201" TARGET=body>FindPrev - Search string backward</A>
<LI><A HREF="#0202" TARGET=body>FindDiff - Find position of string difference</A>
</UL>
<P><HR>
<A NAME="0182"><A NAME="CanAssignAll">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0181" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0183" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Length - Query string length</H3>
 
<P><PRE>PROCEDURE&nbsp;Length&nbsp;(stringVal:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR):&nbsp;CARDINAL;
</PRE>

<P>Module <TT><A HREF="#0181" TARGET=body>Strings</A></TT>
<P>The function procedure <TT>Length</TT> returns the length of the string value in <TT>stringVal</TT>. This is the same as the value of <TT>LENGTH(stringVal)</TT>. 
<P><HR>
<A NAME="0183"><A NAME="Assign">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0182" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0184" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>CanAssignAll - Check whether Assign will succeed</H3>
 
<P><PRE>PROCEDURE&nbsp;CanAssignAll&nbsp;(sourceLength:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;destination:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;):&nbsp;BOOLEAN;
</PRE>

<P>Module <TT><A HREF="#0181" TARGET=body>Strings</A></TT>
<P>The function procedure <TT>CanAssignAll</TT> returns the value of the Boolean expression <TT>sourceLength &lt;= HIGH(destination) + 1</TT> 
<P><B>NOTES:</B> 
<UL>
 
<LI><TT>CanAssignAll</TT> may be used to check whether complete assignment of a string value to a string variable will be possible using, for example, the procedure <TT><A HREF="#0184" TARGET=body>Assign</A></TT>. </LI>
<LI>Since a string variable must have at least one element, single-character string assignment is always valid. </LI>
</UL>

<P><HR>
<A NAME="0184"><A NAME="CanExtractAll">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0183" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0185" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Assign - Assign string value</H3>
 
<P><PRE>PROCEDURE&nbsp;Assign&nbsp;(source:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;destination:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
</PRE>

<P>Module <TT><A HREF="#0181" TARGET=body>Strings</A></TT>
<P>The procedure <TT>Assign</TT> assigns the string value in <TT>source</TT> to <TT>destination</TT>. If the length of <TT>source</TT> exceeds the capacity of <TT>destination</TT>, the assigned value is truncated to the capacity of <TT>destination</TT>. If the length of <TT>source</TT> is less than the capacity of destination, a string terminator is appended to <TT>source</TT> when assignment takes place. 
<P>EXAMPLE - String assignment. 
<P>In these, and later, examples the following declarations are assumed: 
<P><PRE>VAR
&nbsp;&nbsp;small:&nbsp;ARRAY&nbsp;[0&nbsp;..&nbsp;4]&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;large:&nbsp;ARRAY&nbsp;[0&nbsp;..&nbsp;255]&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;alpha:&nbsp;ARRAY&nbsp;['A'&nbsp;..&nbsp;'E']&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;ch:&nbsp;CHAR;
&nbsp;&nbsp;found,&nbsp;areDiff:&nbsp;BOOLEAN;
&nbsp;&nbsp;pos:&nbsp;CARDINAL;
</PRE>
<OL>
 
<LI><TT>ch := &quot;X&quot;; </TT> <BR>
<TT>Assign(String1{ch}, small)</TT> <BR>
results in <TT>small</TT> having value <TT>&quot;X&quot;</TT> </LI>
<LI><TT>Assign(&quot;pq&quot;, small)</TT> <BR>
results in <TT>small</TT> having value <TT>&quot;pq&quot;</TT> </LI>
<LI><TT>Assign(&quot;&quot;, small)</TT> <BR>
results in <TT>small</TT> having value &quot;&quot; </LI>
<LI><TT>Assign(&quot;Hello!&quot;, small)</TT> <BR>
results in <TT>small</TT> having value <TT>&quot;Hello&quot;</TT> <I>without</I> string terminator </LI>
<LI>the call <BR>
<TT>CanAssignAll(6, small)</TT> <BR>
returns the value <TT>FALSE</TT> </LI>
<LI><TT>Assign(&quot;Go&quot;, alpha)</TT> <BR>
results in <TT>alpha</TT> having value <TT>&quot;Go&quot;</TT> </LI>
<LI><TT>small := &quot;Hello&quot;; large := &quot;&quot;;</TT> <BR>
<TT>IF CanAssignAll(LENGTH(small), large)</TT> <BR>
<TT>THEN </TT> <BR>
<TT>&nbsp;&nbsp; Assign(small, large)</TT> <BR>
<TT>END</TT> <BR>
results in <TT>large</TT> having value &quot;Hello&quot; </LI>
</OL>

<P><HR>
<A NAME="0185"><A NAME="Extract">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0184" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0186" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>CanExtractAll - Check whether Extract will succeed</H3>
 
<P><PRE>PROCEDURE&nbsp;CanExtractAll&nbsp;(sourceLength,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startPos,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numberToExtract:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;destination:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;):&nbsp;BOOLEAN;
</PRE>

<P>Module <TT><A HREF="#0181" TARGET=body>Strings</A></TT>
<P>The function procedure <TT>CanExtractAll</TT> returns the value of the Boolean expression <BR>
<TT>(startPos + numberToExtract &lt;= sourceLength) AND <BR>
(numberToExtract &lt;= HIGH(destination) + 1)</TT> 
<P><B>NOTE:</B> 
<P><TT>CanExtractAll</TT> may be used to check whether complete extraction of a substring from a string variable will be possible using, for example, the procedure <TT><A HREF="#0186" TARGET=body>Extract</A></TT>. 
<P><HR>
<A NAME="0186"><A NAME="CanDeleteAll">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0185" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0187" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Extract - Extract substring</H3>
 
<P><PRE>PROCEDURE&nbsp;Extract&nbsp;(source:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startPos,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numberToExtract:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;destination:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
</PRE>

<P>Module <TT><A HREF="#0181" TARGET=body>Strings</A></TT>
<P>The procedure <TT>Extract</TT> creates a new string value of at most <TT>numberToExtract</TT> characters extracted from <TT>source</TT>. Extraction starts at position <TT>startPos</TT> in <TT>source</TT>, and continues as long as there are characters left to extract from <TT>source</TT> and no more than <TT>numberToExtract</TT> characters have been extracted. If the length of the created string value exceeds the capacity of <TT>destination</TT>, the string value is truncated to the capacity of <TT>destination</TT>, and the truncated value is assigned to <TT>destination</TT>. If the length of the created string value is less than the capacity of <TT>destination</TT>, a string terminator is appended to the string value, and the resulting value is assigned to <TT>destination</TT>. An empty string value is extracted if <TT>startPos</TT> is greater than or equal to <TT>LENGTH(source)</TT>. 
<P>EXAMPLE - String extraction. 
<OL>
 
<LI><TT>large := &quot;ABCDE&quot;; small := &quot;&quot;;</TT> <BR>
<TT>IF CanExtractAll(LENGTH (large), 2, 3, small) THEN</TT> <BR>
<TT>&nbsp;&nbsp; Extract(large, 2, 3, small)</TT> <BR>
<TT>END</TT> <BR>
results in <TT>small</TT> having value <TT>&quot;CDE&quot;</TT> </LI>
<LI><TT>large := &quot;ABCDE&quot;; small := &quot;&quot;;</TT> <BR>
<TT>Extract(large, 2, 3, small)</TT> <BR>
results in <TT>small</TT> having value <TT>&quot;CDE&quot;</TT> </LI>
</OL>

<P><HR>
<A NAME="0187"><A NAME="Delete">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0186" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0188" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>CanDeleteAll - Check whether Delete will succeed</H3>
 
<P><PRE>PROCEDURE&nbsp;CanDeleteAll&nbsp;(stringLength,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startPos,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numberToDelete:&nbsp;CARDINAL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;):&nbsp;BOOLEAN;
</PRE>

<P>Module <TT><A HREF="#0181" TARGET=body>Strings</A></TT>
<P>The function procedure <TT>CanDeleteAll</TT> returns the value of the Boolean expression <TT>startPos + numberToDelete &lt;= stringLength</TT> 
<P><B>NOTE:</B> 
<P><TT>CanDeleteAll</TT> may be used to check whether complete deletion of a substring value from a string variable will be possible using, for example, the procedure <TT><A HREF="#0188" TARGET=body>Delete</A></TT>. 
<P><HR>
<A NAME="0188"><A NAME="CanInsertAll">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0187" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0189" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Delete - Delete substring</H3>
 
<P><PRE>PROCEDURE&nbsp;Delete&nbsp;(VAR&nbsp;stringVar:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startPos,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numberToDelete:&nbsp;CARDINAL);
</PRE>

<P>Module <TT><A HREF="#0181" TARGET=body>Strings</A></TT>
<P>The procedure <TT>Delete</TT> creates a new string value by deleting at most <TT>numberToDelete</TT> characters from <TT>stringVar</TT>. Deletion starts at position <TT>startPos</TT> in <TT>stringVar</TT> and continues as long as there are characters left to delete in <TT>stringVar</TT> and no more than <TT>numberToDelete</TT> characters have been deleted. If any characters are deleted, a string terminator is appended to the created string value, and the resulting value is assigned to <TT>stringVar</TT>. The string value in <TT>stringVar</TT> is not altered if <TT>startPos</TT> is greater than or equal to <TT>LENGTH(stringVar)</TT>. 
<P>EXAMPLE - String deletion. 
<OL>
 
<LI><TT>small := &quot;ABCDE&quot;;</TT> <BR>
<TT>IF CanDeleteAll(LENGTH(small), 2, 2) THEN</TT> <BR>
<TT>&nbsp;&nbsp; Delete(small, 2, 2)</TT> <BR>
<TT>END</TT> <BR>
results in <TT>small</TT> having value <TT>&quot;ABE&quot;</TT> </LI>
<LI>after the assignment <BR>
<TT>&nbsp;&nbsp; small := &quot;ABC&quot;;</TT> <BR>
the call <BR>
<TT>&nbsp;&nbsp; CanDeleteAll(3, 2, 2)</TT> <BR>
returns the value <TT>FALSE</TT> </LI>
<LI><TT>small := &quot;ABC&quot;;</TT> <BR>
<TT>Delete(small, 2, 2)</TT> <BR>
results in <TT>small</TT> having value <TT>&quot;AB&quot;</TT> </LI>
</OL>

<P><HR>
<A NAME="0189"><A NAME="Insert">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0188" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0190" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>CanInsertAll - Check whether Insert will succeed</H3>
 
<P><PRE>PROCEDURE&nbsp;CanInsertAll&nbsp;(sourceLength,&nbsp;startPos:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;destination:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;):&nbsp;BOOLEAN;
</PRE>

<P>Module <TT><A HREF="#0181" TARGET=body>Strings</A></TT>
<P>The function procedure <TT>CanInsertAll</TT> returns the value of the Boolean expression <BR>
<TT>(startPos &lt;= LENGTH(destination)) AND <BR>
(sourceLength + LENGTH(destination) &lt;= HIGH(destination) + 1)</TT> 
<P><B>NOTE:</B> 
<P><TT>CanInsertAll</TT> may be used to check whether complete insertion of a string value into a string variable will be possible using, for example, the procedure <TT><A HREF="#0190" TARGET=body>Insert</A></TT>. 
<P><HR>
<A NAME="0190"><A NAME="CanReplaceAll">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0189" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0191" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Insert - Insert substring</H3>
 
<P><PRE>PROCEDURE&nbsp;Insert&nbsp;(source:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startPos:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;destination:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
</PRE>

<P>Module <TT><A HREF="#0181" TARGET=body>Strings</A></TT>
<P>The procedure <TT>Insert</TT> creates a new string value by inserting the substring <TT>source</TT> into <TT>destination</TT>. The string in <TT>destination</TT> is first splitted at the position given by <TT>startPos</TT>; the created string value is the concatenation of the first part of <TT>destination</TT>, the substring <TT>source</TT>, and the second part of <TT>destination</TT>. If the length of the created string value exceeds the capacity of <TT>destination</TT>, the string value is truncated to the capacity of <TT>destination</TT>, and the truncated value is assigned to <TT>destination</TT>. If the length of the created string value is less than the capacity of <TT>destination</TT>, a string terminator is appended to the string value, and the resulting value is assigned to <TT>destination</TT>. The string value in <TT>destination</TT> is not altered if <TT>startPos</TT> is greater than or equal to <TT>LENGTH(destination)</TT>. 
<P>EXAMPLE - String insertion. 
<OL>
 
<LI>after the assignment <BR>
<TT>&nbsp;&nbsp; small := &quot;ABCD&quot;;</TT> <BR>
the call <BR>
<TT>&nbsp;&nbsp; CanInsertAll(LENGTH(&quot;XYZ&quot;), 2, small)</TT> <BR>
returns the value <TT>FALSE</TT> </LI>
<LI><TT>small := &quot;ABCD&quot;;</TT> <BR>
<TT>Insert(&quot;XYZ&quot;, 2, small)</TT> <BR>
results in <TT>small</TT> having value <TT>&quot;ABXYZ&quot;</TT> <I>without</I> terminator </LI>
<LI><TT>large := &quot;ABC&quot;;</TT> <BR>
<TT>IF CanInsertAll(3, 2, large) THEN</TT> <BR>
<TT>&nbsp;&nbsp; Insert(&quot;XYZ&quot;, 2, large)</TT> <BR>
<TT>END</TT> <BR>
results in <TT>large</TT> having value <TT>&quot;ABXYZC&quot;</TT> </LI>
<LI><TT>large := &quot;ABCD&quot;; ch := &quot;X&quot;;</TT> <BR>
<TT>Insert(String1{ch}, 2, large)</TT> <BR>
results in <TT>large</TT> having value <TT>&quot;ABXCD&quot;</TT> </LI>
</OL>

<P><HR>
<A NAME="0191"><A NAME="Replace">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0190" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0192" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>CanReplaceAll - Check whether Replace will succeed</H3>
 
<P><PRE>PROCEDURE&nbsp;CanReplaceAll&nbsp;(sourceLength,&nbsp;startPos:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;destination:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;):&nbsp;BOOLEAN;
</PRE>

<P>The function procedure <TT>CanReplaceAll</TT> returns is the value of the Boolean expression <TT>sourceLength + startPos &lt;= LENGTH(destination)</TT> 
<P><B>NOTES:</B> 
<UL>
 
<LI><TT>CanReplaceAll</TT> may be used to check whether complete replacement of a substring value within a string variable will be possible using, for example, the procedure <TT><A HREF="#0192" TARGET=body>Replace</A></TT>. </LI>
<LI>The preservation of the string abstraction is taken as the goal of the string module. This means that the operation completion condition of <TT>CanReplaceAll</TT> only tests whether the proposed replacement is valid within the given string length; the procedure <TT><A HREF="#0192" TARGET=body>Replace</A></TT> always preserves the length of its <TT>destination</TT> string. </LI>
</UL>

<P><HR>
<A NAME="0192"><A NAME="CanAppendAll">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0191" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0193" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Replace - Replace substring</H3>
 
<P><PRE>PROCEDURE&nbsp;Replace&nbsp;(source:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startPos:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;destination:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
</PRE>

<P>The procedure <TT>Replace</TT> modifies the string value from <TT>destination</TT> by overwriting characters in <TT>destination</TT> with characters extracted from the string value in <TT>source</TT>. Overwriting begins at the position given by <TT>startPos</TT> and continues as long as there are characters left to overwrite in <TT>destination</TT> and characters left to extract from <TT>source</TT>. The string value in <TT>destination</TT> is not altered if <TT>startPos</TT> is greater than or equal to <TT>LENGTH(destination)</TT>. 
<P><B>NOTE:</B> 
<P>The length of the string value in <TT>destination</TT> is always preserved by <TT>Replace</TT>. 
<P>EXAMPLE - String replacement. 
<OL>
 
<LI>after the assignment <BR>
<TT>&nbsp;&nbsp; small := &quot;ABC&quot;</TT> <BR>
the call <BR>
<TT>&nbsp;&nbsp; CanReplaceAll(LENGTH(&quot;XY&quot;), 2, small)</TT> <BR>
returns the value <TT>FALSE</TT> </LI>
<LI><TT>small := &quot;ABC&quot;;</TT> <BR>
<TT>Replace(&quot;XY&quot;, 2, small)</TT> <BR>
results in <TT>small[0]</TT> having value <TT>&quot;ABX&quot;</TT> </LI>
<LI><TT>large := &quot;ABCDEF&quot;;</TT> <BR>
<TT>IF CanReplaceAll(3, 2, large)</TT> <BR>
<TT>THEN</TT> <BR>
<TT>&nbsp;&nbsp; Replace(&quot;XYZ&quot;, 2, large)</TT> <BR>
<TT>END</TT> <BR>
results in <TT>large</TT> having value <TT>&quot;ABXYZF&quot;</TT> </LI>
</OL>

<P><HR>
<A NAME="0193"><A NAME="Append">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0192" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0194" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>CanAppendAll - Check whether Append will succeed</H3>
 
<P><PRE>PROCEDURE&nbsp;CanAppendAll&nbsp;(sourceLength:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;destination:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;):&nbsp;BOOLEAN;
</PRE>

<P>The function procedure <TT>CanAppendAll</TT> returns the value of the Boolean expression <BR>
<TT>LENGTH(destination) + sourceLength &lt;= HIGH(destination) + 1</TT> 
<P><B>NOTE:</B> 
<P><TT>CanAppendAll</TT> may be used to check whether it will be possible to append a string value to another string value held within a string variable using, for example, the procedure <TT><A HREF="#0194" TARGET=body>Append</A></TT>. 
<P><HR>
<A NAME="0194"><A NAME="CanConcatAll">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0193" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0195" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Append - Append string</H3>
 
<P><PRE>PROCEDURE&nbsp;Append&nbsp;(source:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;destination:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
</PRE>

<P>The procedure <TT>Append</TT> creates a new string value by appending the string value in <TT>source</TT> onto <TT>destination</TT>. If the length of the created string value exceeds the capacity of <TT>destination</TT>, the string value is truncated to the capacity of <TT>destination</TT>, and the truncated value is assigned to <TT>destination</TT>. If the length of the created string value is less than the capacity of <TT>destination</TT>, a string terminator is appended to the string value, and the resulting value is assigned to <TT>destination</TT>. 
<P>EXAMPLE - Appending to strings. 
<OL>
 
<LI>after the assignment <BR>
<TT>&nbsp;&nbsp; small := &quot;pqr&quot;</TT> <BR>
the call <BR>
<TT>&nbsp;&nbsp; CanAppendAll(LENGTH(&quot;XYZ&quot;), small)</TT> <BR>
returns the value <TT>FALSE</TT> </LI>
<LI><TT>small := &quot;pqr&quot;;</TT> <BR>
<TT>Append(&quot;XYZ&quot;, small)</TT> <BR>
results in <TT>small</TT> having value <TT>&quot;pqrXY&quot;</TT> <I>without</I> terminator </LI>
<LI><TT>small := &quot;pqr&quot;;</TT> <BR>
<TT>ch := &quot;s&quot;;</TT> <BR>
<TT>Append(String1{ch}, small)</TT> <BR>
results in <TT>small</TT> having value <TT>&quot;pqrs&quot;</TT> </LI>
</OL>

<P><HR>
<A NAME="0195"><A NAME="Concat">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0194" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0196" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>CanConcatAll - Check whether Concat will succeed</H3>
 
<P><PRE>PROCEDURE&nbsp;CanConcatAll&nbsp;(source1Length,&nbsp;source2Length:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;destination:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;):&nbsp;BOOLEAN;
</PRE>

<P>The function procedure <TT>CanConcatAll</TT> returns the value of the Boolean expression <BR>
<TT>source1Length + source2Length &lt;= HIGH(destination) + 1</TT> 
<P><B>NOTE:</B> 
<P><TT>CanConcatAll</TT> may be used to check whether complete concatenation of two string values will be possible within the capacity of a specified string variable using, for example, the procedure <TT><A HREF="#0196" TARGET=body>Concat</A></TT>. 
<P><HR>
<A NAME="0196"><A NAME="Capitalize">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0195" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0197" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Concat - Concatenate strings</H3>
 
<P><PRE>PROCEDURE&nbsp;Concat&nbsp;(source1,&nbsp;source2:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;destination:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
</PRE>

<P>The procedure <TT>Concat</TT> creates a new string value by appending the substring value <TT>source2</TT> onto <TT>source1</TT>. If the length of the created string value exceeds the capacity of <TT>destination</TT>, the string value is truncated to the capacity of <TT>destination</TT>, and the truncated value is assigned to <TT>destination</TT>. If the length of the created string value is less than the capacity of <TT>destination</TT>, a string terminator is appended to the string value, and the resulting value is assigned to <TT>destination</TT>. 
<P>EXAMPLE - String concatenation. 
<OL>
 
<LI>after the assignment <BR>
<TT>&nbsp;&nbsp; small := &quot;pqr&quot;</TT> <BR>
the call <BR>
<TT>&nbsp;&nbsp; CanConcatAll(4, LENGTH(small), small)</TT> <BR>
returns the value <TT>FALSE</TT> </LI>
<LI><TT>small := &quot;pqr&quot;;</TT> <BR>
<TT>Concat(&quot;WXYZ&quot;, small, small)</TT> <BR>
results in <TT>small</TT> having value <TT>&quot;WXYZp&quot;</TT> <I>without</I> terminator </LI>
<LI><TT>small := &quot;jk&quot;; large := &quot;&quot;;</TT> <BR>
<TT>ch := &quot;s&quot;;</TT> <BR>
<TT>Concat(String1{ch}, small, large)</TT><BR>
results in <TT>large</TT> having value <TT>&quot;skj&quot;</TT> </LI>
</OL>

<P><HR>
<A NAME="0197"><A NAME="Compare">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0196" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0198" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Capitalize - Capitalize string</H3>
 
<P><PRE>PROCEDURE&nbsp;Capitalize&nbsp;(VAR&nbsp;stringVar:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR);
</PRE>

<P>The procedure <TT>Capitalize</TT> applies the standard function <TT>CAP</TT> to each character of the string value in <TT>stringVar</TT>. 
<P><B>NOTE:</B> 
<P><TT>Capitalize</TT> may be used to achieve case-insensitive use of the procedures <TT><A HREF="#0198" TARGET=body>Compare</A></TT>, <TT><A HREF="#0200" TARGET=body>FindNext</A></TT>, <TT><A HREF="#0201" TARGET=body>FindPrev</A></TT> and <TT><A HREF="#0202" TARGET=body>FindDiff</A></TT>. 
<P>EXAMPLE - String capitalization. 
<P>The following example assumes a capitalization mapping which maps p to P, q to Q and r to R.<BR>
<OL>
 
<LI><TT>small := &quot;pqr&quot;;</TT> <BR>
<TT>Capitalize(small)</TT> <BR>
results in <TT>small</TT> having value <TT>&quot;PQR&quot;</TT> </LI>
</OL>

<P><HR>
<A NAME="0198"><A NAME="Equal">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0197" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0199" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Compare - Compare strings</H3>
 
<P><PRE>PROCEDURE&nbsp;Compare&nbsp;(stringVal1,&nbsp;stringVal2:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;):&nbsp;CompareResults;
</PRE>

<P>The function procedure <TT>Compare</TT> returns a value of the enumeration type <TT>CompareResults</TT> depending on the lexical ordering of the type <TT>CHAR</TT>. The value returned is <TT>less</TT>, <TT>equal</TT> or <TT>greater</TT> according as the string value in <TT>stringVal1</TT> is lexically less than, equal to, or greater than the string value in <TT>stringVal2</TT>. 
<P><B>NOTES:</B> 
<UL>
 
<LI>The result of this function is dependent upon the full collating sequence of character values. This sequence is implementation-defined, although it must have certain properties. </LI>
<LI>In general, the result of this function is case-sensitive. </LI>
</UL>

<P>EXAMPLE - String comparison. 
<OL>
 
<LI><TT>Compare(&quot;&quot;, &quot;&quot;)</TT> returns <TT>equal</TT> </LI>
<LI><TT>Compare(&quot;&quot;, &quot;abc&quot;)</TT> returns <TT>less</TT> </LI>
<LI><TT>Compare(&quot;abc&quot;, &quot;&quot;)</TT> returns <TT>greater</TT> </LI>
<LI><TT>Compare(&quot;pqr&quot;, &quot;pqr&quot;)</TT> returns <TT>equal</TT> </LI>
<LI><TT>Compare(&quot;pqr&quot;, &quot;pqrstuv&quot;)</TT> returns <TT>less</TT> </LI>
<LI><TT>Compare(&quot;pqrstuv&quot;, &quot;pqr&quot;)</TT> returns <TT>greater</TT> </LI>
<LI><TT>Compare(&quot;abc&quot;, &quot;pqr&quot;)</TT> returns <TT>less</TT> </LI>
<LI><TT>Compare(&quot;pqr&quot;, &quot;abc&quot;)</TT> returns <TT>greater</TT> </LI>
<LI><TT>Compare(&quot;abcdef &quot;, &quot;p&quot;)</TT> returns <TT>less</TT> </LI>
<LI><TT>Compare(&quot;p&quot;, &quot;abcdef &quot;)</TT> returns <TT>greater</TT> </LI>
</OL>

<P><HR>
<A NAME="0199"><A NAME="FindNext">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0198" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0200" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>Equal - Compare strings</H3>
 
<P><PRE>PROCEDURE&nbsp;Equal&nbsp;(stringVal1,&nbsp;stringVal2:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR):&nbsp;BOOLEAN;
</PRE>

<P>The function procedure <TT>Equal</TT> returns the value of the Boolean expression <BR>
<TT>Strings.Compare(stringVal1, stringVal2) = Strings.equal</TT> 
<P><HR>
<A NAME="0200"><A NAME="FindPrev">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0199" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0201" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>FindNext - Search string forward</H3>
 
<P><PRE>PROCEDURE&nbsp;FindNext&nbsp;(pattern,&nbsp;stringToSearch:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startPos:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;patternFound:&nbsp;BOOLEAN;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;posOfPattern:&nbsp;CARDINAL);
</PRE>

<P>The procedure <TT>FindNext</TT> searches forwards for the next occurrence of <TT>pattern</TT> in <TT>stringToSearch</TT>, starting the search in <TT>stringToSearch</TT> at position <TT>startPos</TT>. If <TT>pattern</TT> is found, the value <TT>TRUE</TT> is assigned to <TT>patternFound</TT>, and <TT>posOfPattern</TT> contains the starting position of <TT>pattern</TT> in <TT>stringToSearch</TT>; <TT>posOfPattern</TT> is in the range <TT>[startPos..LENGTH(stringToSearch)-1]</TT>. Otherwise the value <TT>FALSE</TT> is assigned to <TT>patternFound</TT> and <TT>posOfPattern</TT> is unchanged. 
<P><B>NOTES:</B> 
<UL>
 
<LI>The <TT>pattern</TT> might be found at the given value of <TT>startPos</TT>. </LI>
<LI>If <TT>startPos &gt; LENGTH(stringToSearch) - LENGTH(pattern)</TT> then <TT>patternFound</TT> is returned as <TT>FALSE</TT>. </LI>
</UL>

<P>EXAMPLE - Forwards string search. 
<OL>
 
<LI><TT>large := &quot;Hello hello hello&quot;;</TT> <BR>
<TT>FindNext(&quot;ll&quot;, large, 0, found, pos)</TT> <BR>
results in: <BR>
<TT>found</TT> having value <TT>TRUE</TT> <BR>
<TT>pos</TT> having value <TT>2</TT> </LI>
<LI><TT>large := &quot;Hello hello hello&quot;;</TT> <BR>
<TT>FindNext(&quot;ll&quot;, large, 0, found, pos);</TT> <BR>
<TT>FindNext(&quot;ll&quot;, large, pos+1, found, pos)</TT> <BR>
results in: <BR>
<TT>found</TT> having value <TT>TRUE</TT> <BR>
<TT>pos</TT> having value <TT>8</TT> </LI>
<LI><TT>large := &quot;abcdefghijklmnopqrstuvwxyz&quot;;</TT> <BR>
<TT>ch := &quot;x&quot;;</TT> <BR>
<TT>FindNext(String1fchg, large, 0, found, pos)</TT> <BR>
results in: <BR>
<TT>found</TT> having value <TT>TRUE</TT> <BR>
<TT>pos</TT> having value <TT>23</TT> </LI>
<LI><TT>large := &quot;abcdefghijklmnopqrstuvwxyz&quot;;</TT> <BR>
<TT>ch := &quot;x&quot;;</TT> <BR>
<TT>FindNext(String1fchg, large, 26, found, pos)</TT> <BR>
results in: <BR>
<TT>found</TT> having value <TT>FALSE</TT> <BR>
<TT>pos</TT> remains unchanged </LI>
</OL>

<P><HR>
<A NAME="0201"><A NAME="FindDiff">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0200" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0202" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A></A>
<BR>
<H3>FindPrev - Search string backward</H3>
 
<P><PRE>PROCEDURE&nbsp;FindPrev&nbsp;(pattern,&nbsp;stringToSearch:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startPos:&nbsp;CARDINAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;patternFound:&nbsp;BOOLEAN;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;posOfPattern:&nbsp;CARDINAL);
</PRE>

<P>The procedure <TT>FindPrev</TT> looks backwards for an occurrence of <TT>pattern</TT> in the string value in <TT>stringToSearch</TT>, starting the search in <TT>stringToSearch</TT> at position <TT>startPos</TT>. If <TT>pattern</TT> is found, the value <TT>TRUE</TT> is assigned to <TT>patternFound</TT>, and <TT>posOfPattern</TT> contains the starting position of <TT>pattern</TT> in <TT>stringToSearch</TT>; <TT>posOfPattern</TT> is in the range <TT>[0..startPos]</TT>. Otherwise the value <TT>FALSE</TT> is assigned to <TT>patternFound</TT> and <TT>posOfPattern</TT> is unchanged. 
<P><B>NOTES:</B> 
<UL>
 
<LI>The <TT>pattern</TT> might be found at the given value of <TT>startPos</TT>. </LI>
<LI>If <TT>startPos &gt; LENGTH(stringToSearch)-LENGTH(pattern)</TT> the whole string value is searched. </LI>
</UL>

<P>EXAMPLE - Backwards string search. 
<OL>
 
<LI><TT>large := &quot;aabbbcccc&quot;;</TT> <BR>
<TT>FindPrev(&quot;cc&quot;, large, 200, found, pos)</TT> <BR>
results in: <BR>
<TT>found</TT> having value <TT>TRUE</TT> <BR>
<TT>pos</TT> having value <TT>7</TT> </LI>
<LI><TT>large := &quot;aabbbcccc&quot;;</TT> <BR>
<TT>FindPrev(&quot;cc&quot;, large, 200, found, pos);</TT> <BR>
<TT>FindPrev(&quot;cc&quot;, large, pos-1, found, pos)</TT> <BR>
results in: <BR>
<TT>found</TT> having value <TT>TRUE</TT> <BR>
<TT>pos</TT> having value <TT>6</TT> </LI>
<LI><TT>large := &quot;Maybe this makes sense&quot;;</TT> <BR>
<TT>FindPrev(&quot;se&quot;, large, 200, found, pos)</TT> <BR>
results in: <BR>
<TT>found</TT> having value <TT>TRUE</TT> <BR>
<TT>pos</TT> having value <TT>20</TT> </LI>
<LI><TT>large := &quot;Maybe this makes sense&quot;;</TT> <BR>
<TT>FindPrev(&quot;se&quot;, large, 20, found, pos);</TT> <BR>
<TT>FindPrev(&quot;se&quot;, large, pos-1, found, pos)</TT> <BR>
results in: <BR>
<TT>found</TT> having value <TT>TRUE</TT> <BR>
<TT>pos</TT> having value <TT>17</TT> </LI>
</OL>

<P><HR>
<A NAME="0202">
<A HREF="#0181" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0201" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="#0203" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H3>FindDiff - Find position of string difference</H3>
 
<P><PRE>PROCEDURE&nbsp;FindDiff&nbsp;(stringVal1,&nbsp;stringVal2:&nbsp;ARRAY&nbsp;OF&nbsp;CHAR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;differenceFound:&nbsp;BOOLEAN;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VAR&nbsp;posOfDifference:&nbsp;CARDINAL);
</PRE>

<P>The procedure <TT>FindDiff</TT> compares the string values in <TT>stringVal1</TT> and <TT>stringVal2</TT>. The value <TT>FALSE</TT> is assigned to <TT>differenceFound</TT> if the string values are equal and <TT>TRUE</TT> otherwise. If <TT>differenceFound</TT> is <TT>TRUE</TT>, the position of the first difference between the string values is assigned to <TT>posOfDifference</TT>; otherwise <TT>posOfDifference</TT> is unchanged. 
<P><A NAME="0203">
<A HREF="isolib001.html#0118" TARGET=body><IMG ALT="Super" SRC="super.gif" BORDER=0></A>
<A HREF="#0202" TARGET=body><IMG ALT="Prev" SRC="prev.gif" BORDER=0></A>
<A HREF="isolib005.html#0204" TARGET=body><IMG ALT="Next" SRC="next.gif" BORDER=0></A></A>
<BR>
<H5>Examples</H5>
 - Finding string differences. 
<OL>
 
<LI><TT>FindDiff(&quot;&quot;, &quot;&quot;, areDiff, pos)</TT> results in: <BR>
<TT>areDiff</TT> having value <TT>FALSE</TT> <BR>
<TT>pos</TT> being unchanged </LI>
<LI><TT>FindDiff(&quot;abc&quot;, &quot;&quot;, areDiff, pos)</TT> results in: <BR>
<TT>areDiff</TT> having value <TT>TRUE</TT> <BR>
<TT>pos</TT> having value <TT>0</TT> </LI>
<LI><TT>FindDiff(&quot;&quot;, &quot;abc&quot;, areDiff, pos)</TT> results in: <BR>
<TT>areDiff</TT> having value <TT>TRUE</TT> <TT>pos</TT> having value <TT>0</TT> </LI>
<LI><TT>FindDiff(&quot;pqr&quot;, &quot;pqt&quot;, areDiff, pos)</TT> results in: <BR>
<TT>areDiff</TT> having value <TT>TRUE</TT> <BR>
<TT>pos</TT> having value <TT>2</TT> </LI>
<LI><TT>FindDiff(&quot;pqr&quot;, &quot;pqrstuv&quot;, areDiff, pos)</TT> results in: <BR>
<TT>areDiff</TT> having value <TT>TRUE</TT> <BR>
<TT>pos</TT> having value <TT>3</TT> </LI>
<LI><TT>FindDiff(&quot;pqrstuv&quot;, &quot;pqr&quot;, areDiff, pos)</TT> results in: <BR>
<TT>areDiff</TT> having value <TT>TRUE</TT> <BR>
<TT>pos</TT> having value <TT>3</TT> </LI>
</OL>

<P></BODY>
</HTML>
